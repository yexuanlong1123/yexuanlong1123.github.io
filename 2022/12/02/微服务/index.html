<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>微服务 | Hello World</title><meta name="author" content="孤江自流"><meta name="copyright" content="孤江自流"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="认识微服务 单体架构：将业务的所有功能集中在一个项目中开发，打成一个包部署。  优点：架构简单、部署成本低 缺点：耦合度高、当有一个模块出现BUG，可能会导致整个系统崩溃。   分布式架构：根据业务功能对系统进行拆分，每个业务模块作为独立项目开发，称为一个服务。  优点：降低耦合度、有利于服务的升级和扩展。 缺点：研发成本高   微服务是一种经过良好架构设计的分布式架构方案，微服务架构特征  单一">
<meta property="og:type" content="article">
<meta property="og:title" content="微服务">
<meta property="og:url" content="http://example.com/2022/12/02/%E5%BE%AE%E6%9C%8D%E5%8A%A1/index.html">
<meta property="og:site_name" content="Hello World">
<meta property="og:description" content="认识微服务 单体架构：将业务的所有功能集中在一个项目中开发，打成一个包部署。  优点：架构简单、部署成本低 缺点：耦合度高、当有一个模块出现BUG，可能会导致整个系统崩溃。   分布式架构：根据业务功能对系统进行拆分，每个业务模块作为独立项目开发，称为一个服务。  优点：降低耦合度、有利于服务的升级和扩展。 缺点：研发成本高   微服务是一种经过良好架构设计的分布式架构方案，微服务架构特征  单一">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/mv.jpg">
<meta property="article:published_time" content="2022-12-02T04:31:48.000Z">
<meta property="article:modified_time" content="2023-02-06T05:13:32.209Z">
<meta property="article:author" content="孤江自流">
<meta property="article:tag" content="springcloud">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/mv.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/12/02/%E5%BE%AE%E6%9C%8D%E5%8A%A1/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="/LonelyBoy" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '微服务',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-02-06 13:13:32'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Hello World" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/mv.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Hello World"><span class="site-name">Hello World</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">微服务</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-12-02T04:31:48.000Z" title="发表于 2022-12-02 12:31:48">2022-12-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-02-06T05:13:32.209Z" title="更新于 2023-02-06 13:13:32">2023-02-06</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="微服务"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="认识微服务"><a href="#认识微服务" class="headerlink" title="认识微服务"></a>认识微服务</h1><ul>
<li><p>单体架构：将业务的所有功能集中在一个项目中开发，打成一个包部署。</p>
<ul>
<li>优点：架构简单、部署成本低</li>
<li>缺点：耦合度高、当有一个模块出现BUG，可能会导致整个系统崩溃。</li>
</ul>
</li>
<li><p>分布式架构：根据业务功能对系统进行拆分，每个业务模块作为独立项目开发，称为一个服务。</p>
<ul>
<li>优点：降低耦合度、有利于服务的升级和扩展。</li>
<li>缺点：研发成本高</li>
</ul>
</li>
<li><p>微服务是一种经过良好架构设计的分布式架构方案，微服务架构特征</p>
<ul>
<li>单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责，避免重复业务开友</li>
<li>面向服务：微服务对外暴露业务接口</li>
<li>自治：团队独立、技术独立、数据独立、部署独立</li>
<li>隔离性强：服务调用做好隔离、容错、降级、避免出现级联问题</li>
</ul>
</li>
</ul>
<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221204133958073.png" alt="image-20221204133958073"></p>
<h2 id="微服务结构"><a href="#微服务结构" class="headerlink" title="微服务结构"></a>微服务结构</h2><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221204134435078.png" alt="image-20221204134435078"></p>
<h2 id="微服务技术对比"><a href="#微服务技术对比" class="headerlink" title="微服务技术对比"></a>微服务技术对比</h2><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221204135049357.png" alt="image-20221204135049357"></p>
<h1 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h1><ul>
<li>SpringCloud集成了各种微服务功能组件，并基于SpringBoot实现了这些组件的自动装配，从而提供了良好的开箱即用体验:</li>
</ul>
<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221204135842628.png" alt="image-20221204135842628"></p>
<h1 id="服务拆分"><a href="#服务拆分" class="headerlink" title="服务拆分"></a>服务拆分</h1><ol>
<li>不同微服务，不要重复开发相同业务</li>
<li>微服务数据独立，不要访问其它微服务的数据库</li>
<li>微服务可以将自己的业务暴露为接口，供其它微服务调用</li>
</ol>
<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221204140506901.png" alt="image-20221204140506901"></p>
<h2 id="微服务远程调用"><a href="#微服务远程调用" class="headerlink" title="微服务远程调用"></a>微服务远程调用</h2><p>概述：在微服务体系架构中，每个业务服务都是一个独立的服务模块，每个模块都有属于自己的数据库，所以要联表查询数据是不能像单体项目一样可以直接进行多表查询，而是要通过每个服务模块暴露出部分接口供给其它服务模块调用。</p>
<ul>
<li><p>远程调用的实质：就是给目标服务模块发送一个HTTP的请求，让目标服务进行一个响应并返回数据即可。</p>
</li>
<li><p>远程调用的API是RestTemplate，该API应交给Spring的IOC容器管理。</p>
</li>
<li><p>服务调用关系（两者身份是相对的）</p>
<ul>
<li>服务提供者：暴露接口给其它服务调用。</li>
<li>服务消费者：调用来自其它服务模块的提供的接口。</li>
</ul>
</li>
</ul>
<h1 id="Eureka注册中心"><a href="#Eureka注册中心" class="headerlink" title="Eureka注册中心"></a>Eureka注册中心</h1><p>服务调用出现的问题</p>
<ul>
<li>服务消费者该如何获取服务提供者的地址信息？</li>
<li>如果有多个服务提供者，消费者该如何选择？</li>
<li>消费者如何得知服务提供者的健康状态？</li>
</ul>
<p>Eureka介绍：主要作用是记录每个服务提供者的地址信息</p>
<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221204153807427.png" alt="image-20221204153807427"></p>
<p>Eureka架构</p>
<ol>
<li><p>EurekaService：服务端，注册中心——专门记录服务信息和服务接口的健康监测。</p>
</li>
<li><p>EurekaClient：客户端</p>
<ul>
<li>服务提供者：注册服务提供者的信息，并每隔30秒会进行一个监测，保证接口是否可以正常供应</li>
<li>服务消费者：根据服务名称从EurekaServer拉取服务列表，基于服务列表做负载均衡，选中一个微服务后发起远程调用</li>
</ul>
</li>
</ol>
<h2 id="搭建EurekaServer"><a href="#搭建EurekaServer" class="headerlink" title="搭建EurekaServer"></a>搭建EurekaServer</h2><p>搭建EurekaServer服务步骤如下</p>
<ol>
<li>创建项目，引入spring-cloud-starter-netflix-eureka-server的依赖</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>编写启动类，添加@EnableEurekaServer注解</li>
<li>添加application.yml文件，编写下面的配置</li>
</ol>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8888</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eurekaServer</span></span><br><span class="line"><span class="comment"># 注册信息</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:8888/eureka</span></span><br></pre></td></tr></table></figure>

<h2 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h2><ol>
<li>在目标项目中引入坐标spring-cloud-starter-netflix-eureka-client</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--  引入eureka的客户端--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在application.yml的配置参数如下</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置服务的名称</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">application:</span></span><br><span class="line">    	<span class="attr">name:</span> <span class="string">userService</span></span><br><span class="line"><span class="comment"># 注册信息</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:8888/eureka</span></span><br></pre></td></tr></table></figure>

<h2 id="使用Eureka实现负载均衡"><a href="#使用Eureka实现负载均衡" class="headerlink" title="使用Eureka实现负载均衡"></a>使用Eureka实现负载均衡</h2><ol>
<li>在RestTemplate加载Bean的方法上加注解@LoadBalanced即可实现。</li>
<li>在RestTemplate远程调用时可以使用已在eureka服务器中注册的服务名称进行调用，RestTemplate会在eureka服务发现指定的端口并进行远程连接。</li>
</ol>
<h1 id="Ribbon负载均衡原理"><a href="#Ribbon负载均衡原理" class="headerlink" title="Ribbon负载均衡原理"></a>Ribbon负载均衡原理</h1><p>​	在order-service服务发出了一个请求，若在order-service中加载Bean的RestTemplate方法上有@LoadBalanced时，其发出的请求会被LoadBalancerInterceptor类（负载均衡拦截器）拦截下来，然后到enreka-server（服务中心）根据别名（userservice）查找已注册的服务列表，若存在该服务名称则就返回相关的服务列表到Ribbon中，该返回的列表是真实的ip地址号，在Ribbon中进一步的进行负载均衡的算法。</p>
<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221210152342658.png" alt="image-20221210152342658"></p>
<ul>
<li>Ribbon内部结构图</li>
</ul>
<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221210153437529.png" alt="image-20221210153437529"></p>
<h2 id="负载均衡的策略"><a href="#负载均衡的策略" class="headerlink" title="负载均衡的策略"></a>负载均衡的策略</h2><p>下图是Ribbon负载均衡策略继承关系</p>
<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221210153849904.png" alt="image-20221210153849904"></p>
<p><strong>每个类的含义如下图</strong></p>
<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221210154712521.png" alt="image-20221210154712521"></p>
<p>调整负载均衡的规则，默认是轮询的方式作为负载均衡</p>
<ul>
<li>将需要目标策略加载成Bean即可（作用范围：全局）</li>
<li>在application.yml配置文件中配置如下参数即可（作用范围：局部，在哪个微服务中配置就作用在其微服务）</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 微服务名称</span></span><br><span class="line"><span class="attr">userService:</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.RandomRule</span> <span class="comment">#负载均衡规则</span></span><br></pre></td></tr></table></figure>

<p>Ribbon默认是采用懒加载，即第一次访问时才会去创建LoadBalanceClient，请求时间会很长。而饥饿加载则会在项目启动时创建，降低第一次访问的耗时，通过下面配置开启饥饿加载。</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="attr">eager-load:</span></span><br><span class="line">    <span class="attr">clients:</span> <span class="string">userService</span>  <span class="comment">#指定对哪个服务进行饥饿加载</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment">#开启饥饿加载</span></span><br></pre></td></tr></table></figure>

<h1 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h1><p>概述：Nacos是阿里巴巴的产品，现在是SpringCloud中的一个组件。相比Eureka功能更加丰富，在国内受欢迎程度较高。安装自行百度</p>
<p>在Windows系统下启动Nacos命令：startup.cmd -m standalone</p>
<p>整合Nacos步骤如下</p>
<ol>
<li>在父工程引入所有的阿里巴巴的版本控制</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在目标服务包下引入nacos的客户端</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- nacos客户端依赖包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在目标服务包下修改配置</li>
</ol>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#配置nacos服务器的地址</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>以上配置完成后，不用加任何的代码即可实现微服务间的请求负载均衡。</li>
</ol>
<h2 id="nacos的设置"><a href="#nacos的设置" class="headerlink" title="nacos的设置"></a>nacos的设置</h2><p>分级存储模型：分级模型就是将同种实例服务分布在不同地区的服务器中，避免一个服务器挂掉了使该实例服务不能提供服务的情况发生，所以一个服务实例通常会部署在不同的服务器上，每个地区的服务实例会进行一个集群，当本地的服务实例不能用时，会搜索其它地区的服务实例。</p>
<ol>
<li>集群配置</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"> <span class="attr">naocs:</span></span><br><span class="line">	<span class="attr">discovery:</span></span><br><span class="line">  	 <span class="attr">cluster-name:</span> <span class="string">HZ</span> <span class="comment">#配置集群名称，以地名命名</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>NaocsRule负载均衡策略</p>
<ol>
<li>优先选择同集群服务实例列表</li>
<li>本地集群找不到提供者，才去其它集群寻找，并且会报警告</li>
<li>确定了可用实例列表后，再采用随机负载均衡挑选实例</li>
</ol>
</li>
<li><p>Naocs的实例权重设置</p>
<ol>
<li>Nacos控制台可以设置实例的权重值0~1之间</li>
<li>同集群内的多个实例，权重越高被访问的频率越高</li>
<li>权重设置为0则完全不会被访问</li>
</ol>
</li>
<li><p>Naocs的环境隔离</p>
<ol>
<li>namespace用来做环境隔离</li>
<li>每个namespace都有唯一id</li>
<li>不同namespace下的服务不可见（不同环境中的服务访问的话会报错，No instances available for userService）</li>
</ol>
</li>
</ol>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>nacos与eureka的整体原理差不多，服务提供者都要在注册中心进行一个注册，每隔一段时间注册中心都会进行一次服务的健康检测来检测一下服务提供者提供的服务是否可用，但nacos比eureka功能更完善，<strong>nacos和eureka的细节区别：</strong>nacos中存在临时实例和非临时实例，临时实例是存在服务列表缓存中，而服务消费者先从服务列表查找是否有自己需要的服务（读取缓存，速度更快）。服务消费者会定时从注册中心拉取服务，从而更新服务列表缓存，临时服务需要主动将自己的健康情况推送到注册中心中，若注册中心一定时间未检测到临时实例服务的健康情况，注册中心会将其服务去除掉，但非临时实例是相反的，注册中心会主动的询问非临时实例是否处于健康状态，就算是非健康状态注册中心也不会将其剔除，那以上的说法会产生一个新的问题，那就是当注册中心有一个临时实例挂掉了，但服务列表缓存未及时的更新，那么针对该问题，当有一个临时实例或非临时实例挂掉了，注册中心会主动将更新好的服务列表发送给服务消费者。</p>
<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221211133647023.png" alt="image-20221211133647023"></p>
<h2 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h2><p>当nacos注册中心若存在很多的微服务，若需要进行系统升级，那每个微服务的配置都给重新配置，这样就会变得非常的麻烦，nacos提供了配置管理服务将所有的微服务同一配置管理，只要在配置管理修改配置参数，各个微服务再进行读取配置管理中的配置参数即可完成修改。那么如何实现呢？</p>
<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221211141202582.png" alt="image-20221211141202582"></p>
<p><strong>配置管理的实现步骤如下</strong></p>
<ol>
<li>第一步需要在nocas注册中心新建一个配置管理文件，步骤如下（最后点击发布即可）</li>
</ol>
<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221211143706538.png" alt="image-20221211143706538"></p>
<p>文件类型选择yaml类型</p>
<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221211144015549.png" alt="image-20221211144015549"></p>
<ol start="2">
<li>如何让微服务读取到nacos中的配置文件呢？首先在目标服务实例中引入nacos的配置管理坐标</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入nacos的配置管理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其次在resource目录下新建一个bootsrap.yml文件，注意，该文件名称一定是这样命名的，因为bootsrap.yml配置文件加载的优先级比application.yml高，然后再文件中加上以下参数即可，当配置完成后可以用@Value注解读取配置文件中的信息。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">userService</span> <span class="comment">#服务名称</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span> <span class="comment"># 配置环境，这里的环境一定要与你在nacos注册中心文件命名的那个环境一样</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment"># 配置nacos的注册中心地址</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment"># 文件的后缀名</span></span><br></pre></td></tr></table></figure>

<p>从nacos中获取配置文件的信息整体流程如下</p>
<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221211150233950.png" alt="image-20221211150233950"></p>
<h3 id="nacos的配置自动更新（热更新）"><a href="#nacos的配置自动更新（热更新）" class="headerlink" title="nacos的配置自动更新（热更新）"></a>nacos的配置自动更新（热更新）</h3><p>概述：自动更新是不需要重启服务器就可以完成配置文件信息的更新</p>
<ul>
<li>方式一：使用注解@RefreshScope配合@value使用即可完成。@RefreshScope放在类上</li>
<li>方式二：使用注解@ConfigurationProperties完成自动更新。</li>
</ul>
<h3 id="nacos的文件加载优先级"><a href="#nacos的文件加载优先级" class="headerlink" title="nacos的文件加载优先级"></a>nacos的文件加载优先级</h3><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221211153109271.png" alt="image-20221211153109271"></p>
<h1 id="HTTP客户端Feign"><a href="#HTTP客户端Feign" class="headerlink" title="HTTP客户端Feign"></a>HTTP客户端Feign</h1><p>RestTemplate远程调用的问题：</p>
<ol>
<li>代码可读性差，编程体验不统一</li>
<li>参数复杂URL难以维护</li>
</ol>
<p>Feign的介绍：Feign是一个声明式的http客户端，其内部已经整合了ribbon，不用自己配置即可做到负载均衡，其作用就是帮助我们优雅的实现http请求的发送，解决上面提到的问题。官方地址: <a target="_blank" rel="noopener" href="https://github.com/OpenFeign/feign">https://github.com/OpenFeign/feign</a></p>
<p><strong>Feigh的使用步骤如下</strong></p>
<ol>
<li>引入依赖</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入fright依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>在启动类上开启feigh客户端驱动@EnableFeignClients</p>
</li>
<li><p>定义一个包专门来请求别的微服务模块，并编写接口如下图（注意@FeignClient()参数中不要加&#x2F;）</p>
</li>
</ol>
<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221215140003411.png" alt="image-20221215140003411"></p>
<ol start="4">
<li>在业务层注入客户端的接口，如上的UserClient的bean即可直接调用接口中的方法完成微服务间的调用。</li>
</ol>
<p><strong>Fign的自定义配置</strong></p>
<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221215141415617.png" alt="image-20221215141415617"></p>
<p><strong>Feign的日志配置</strong></p>
<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221215141232182.png" alt="image-20221215141232182"></p>
<h2 id="Feign的性能优化"><a href="#Feign的性能优化" class="headerlink" title="Feign的性能优化"></a>Feign的性能优化</h2><p>Feign优化分为两个方面，第一Feign的日志级别不要开的太高，最好在BASIC级别即可，在日志这方面只有优化这个，第二在请求连接方面的优化。因为Feign默认的请求调用是不支持连接池的使用，每次都要创建请求和销毁请求，比较消耗性能，可以自己配置Feign的连接池，将请求连接交给连接池管理这样就不用每次请求都要进行创建和销毁，从而提高了性能，步骤如下</p>
<ol>
<li>引入依赖（使用HttpClient连接池）</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入fright的httpClient连接池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>修改配置文件，配置参数如下</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">httpclient:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment">#开启连接池的使用</span></span><br><span class="line">    <span class="attr">max-connections-per-route:</span> <span class="number">50</span> <span class="comment">#单个服务接口的最大连接数</span></span><br><span class="line">    <span class="attr">max-connections:</span> <span class="number">200</span> <span class="comment">#最大连接数</span></span><br><span class="line">    <span class="attr">time-to-live:</span> <span class="number">90</span> <span class="comment">#连接存活的时间，若超过90S未使用会自动取消连接</span></span><br></pre></td></tr></table></figure>

<h2 id="Feign的最佳实践"><a href="#Feign的最佳实践" class="headerlink" title="Feign的最佳实践"></a>Feign的最佳实践</h2><p>概述：Feign的远程调用中，服务消费者接口定义和服务提供者的接口定义必须一致，例如，参数个数等等，这样的用法修改起来比较麻烦，所有提供了以下两种思路</p>
<ol>
<li>继承：给消费者的FeignClient和提供者的controller定义统一的父接口作为标准。（耦合度高）</li>
</ol>
<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221215145243158.png" alt="image-20221215145243158"></p>
<ol start="2">
<li>抽取：将Feign提供的调用接口抽取成一个微服务模块，然后让这个模块对外提供服务接口，供给服务消费者调用。</li>
</ol>
<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221215145213059.png" alt="image-20221215145213059"></p>
<p><strong>实现Feign的抽取步骤如下</strong></p>
<ol>
<li>创建一个新的微服务模块（maven模块）</li>
<li>将服务提供者和服务消费者所需要的实体类、配置和调用接口放在feign-api的服务模块中</li>
<li>在服务消费者的模块引入依赖，注意在这一步中需要在@EnableFeignClients中添加一个参数，否则会在Springboot启动时报Bean找不到的错误，该参数是可以让组件扫描到feign-api模块中，从而成功的加载Bean对象，如下</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients(clients = &#123;在feign-api模块中的接口.class&#125;)</span> <span class="comment">//将feign-api的接口加载到此服务模块中</span></span><br></pre></td></tr></table></figure>

<h1 id="Gateway网关"><a href="#Gateway网关" class="headerlink" title="Gateway网关"></a>Gateway网关</h1><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221215160258517.png" alt="image-20221215160258517"></p>
<p>在SpringCloud中网关的实现包括两种:</p>
<ul>
<li>gateway</li>
<li>zuul</li>
</ul>
<p>Zuul是基于Servlet的实现，属于阻塞式编程。而SpringCloudGateway则是基于Spring5中提供的WebFlux，属于响应式编程的实现，具备更好的性能。</p>
<h2 id="开发网关的步骤"><a href="#开发网关的步骤" class="headerlink" title="开发网关的步骤"></a>开发网关的步骤</h2><p>先创建一个新的maven模块，引入nacos和注册发现的依赖</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注册发现依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 路由 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>修改配置参数，基本的配置如下</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10011</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment"># nacos地址</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://userService</span> <span class="comment"># 以lb是LoadBalance 负载均衡</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/user/**</span> <span class="comment"># 只要请求路径中有user，则将该请求引导userService服务中</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">order-service</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://orderService</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/order/**</span></span><br></pre></td></tr></table></figure>

<p>当上面的步骤做完之后即可直接访问网关的路径，网关会给你的请求进行一个引导访问你需要的资源。</p>
<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221224150013734.png" alt="image-20221224150013734"></p>
<h2 id="路由过滤器GatewayFilter的配置"><a href="#路由过滤器GatewayFilter的配置" class="headerlink" title="路由过滤器GatewayFilter的配置"></a>路由过滤器GatewayFilter的配置</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10011</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment"># nacos地址</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://userService</span> <span class="comment"># 以lb是LoadBalance 负载均衡</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/user/**</span> <span class="comment"># 只要请求路径中有user，则将该请求引导userService服务中</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">filters:</span></span><br><span class="line">        		<span class="comment"># 局部过滤器</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">order-service</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://orderService</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/order/**</span></span><br><span class="line">      <span class="attr">default-filters:</span> <span class="comment"># 默认路由过滤器，会对所有的请求生效，若需要局部，可以在指定的路由下配置</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">AddRequestHeader=name,zhangsan</span></span><br></pre></td></tr></table></figure>

<h2 id="网关的全局过滤器"><a href="#网关的全局过滤器" class="headerlink" title="网关的全局过滤器"></a>网关的全局过滤器</h2><p>全局过滤器的作用是什么?</p>
<ol>
<li>对所有路由都生效的过滤器，并且可以自定义处理逻辑</li>
</ol>
<p>实现全局过滤器的步骤?</p>
<ol>
<li>实现GlobalFilter接口</li>
<li>添加@Order注解或实现Ordered接口</li>
<li>编写处理逻辑</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 请求访问权限过滤器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Order(-1)</span> <span class="comment">//过滤的优先级</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthorizationFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理用户的请求</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exchange：可以获取到用户的请求头或者是响应头进行处理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> chain：用来放行请求的</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> m</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">        <span class="comment">//1. 获取ServerHttpRequest对象</span></span><br><span class="line">        <span class="type">ServerHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> exchange.getRequest();</span><br><span class="line">        <span class="comment">//2. 获取请求头</span></span><br><span class="line">        MultiValueMap&lt;String, String&gt; queryParams = request.getQueryParams();</span><br><span class="line">        <span class="comment">//3. 从请求头中通过键取出值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">authorization</span> <span class="operator">=</span> queryParams.getFirst(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">        <span class="comment">//4. 判断该请求头是否是admin权限的用户</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;admin&quot;</span>.equals(authorization)) &#123;</span><br><span class="line">            <span class="comment">//是，放行</span></span><br><span class="line">            <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置一下状态码</span></span><br><span class="line">        exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">        <span class="comment">//否，拦截</span></span><br><span class="line">        <span class="keyword">return</span> exchange.getResponse().setComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>路由过滤器、defaultFilter、全局过滤器的执行顺序?</p>
<ul>
<li><p>order值越小，优先级越高</p>
</li>
<li><p>当order值一样时，顺序是defaultFilter最先，然后是局部的路由过滤器，最后是全局过滤器</p>
</li>
</ul>
<h2 id="跨域请求问题"><a href="#跨域请求问题" class="headerlink" title="跨域请求问题"></a>跨域请求问题</h2><p>引起原因：客户端和服务器的域名不同或者是端口号不同导致的，跨域问题是游览器不允许页面对不同的域进行一个ajax的请求，但在服务端中就不存在该问题了。如下图所示是属于跨域请求</p>
<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221229162011088.png" alt="image-20221229162011088"></p>
<p>解决方案：CORS</p>
<p>只需要在网关下配置如下参数即可解决</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">globalcors:</span> <span class="comment">#全局的跨域处理</span></span><br><span class="line">        <span class="attr">add-to-simple-url-handler-mapping:</span> <span class="literal">true</span> <span class="comment">#解决options请求被拦截问题corsConfigurations:</span></span><br><span class="line">          <span class="string">&#x27;[/**]&#x27;</span><span class="string">:</span></span><br><span class="line">            <span class="attr">allowedOrigins:</span>  <span class="comment">#允许哪些网站的跨域请求</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;http://logalhost:8090&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;http://www.leyou.com&quot;</span></span><br><span class="line">            <span class="attr">allowedMethods:</span> <span class="comment">#允许的跨域ajax的请求方式</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;GET&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;POST&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;DELETE&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;PUT&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;OPTIONS&quot;</span></span><br><span class="line">            <span class="attr">allowedHeaders:</span> <span class="string">&quot;*&quot;</span> <span class="comment">#允许在请求中携带的头信息</span></span><br><span class="line">            <span class="attr">allowCredentials:</span> <span class="literal">true</span> <span class="comment">#是否允许携带</span></span><br><span class="line">            <span class="attr">cookiemaxAge:</span> <span class="number">360000</span> <span class="comment">#这次跨域检测的有效期s</span></span><br></pre></td></tr></table></figure>

<p>还有一种解决方案，添加一个Bean给IOC容器管理即可，让spring框架知道请求可以跨域即可。如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解决跨域请求问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GulimallCorsWebConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CorsWebFilter <span class="title function_">corsWebFilter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">UrlBasedCorsConfigurationSource</span> <span class="variable">source</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlBasedCorsConfigurationSource</span>();</span><br><span class="line">        <span class="comment">//配置跨域参数</span></span><br><span class="line">        <span class="type">CorsConfiguration</span> <span class="variable">configuration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorsConfiguration</span>();</span><br><span class="line">        configuration.setAllowedHeaders(Collections.singletonList(<span class="string">&quot;*&quot;</span>));</span><br><span class="line">        configuration.setAllowedMethods(Collections.singletonList(<span class="string">&quot;*&quot;</span>));</span><br><span class="line">        configuration.setAllowedOrigins(Collections.singlsetonList(<span class="string">&quot;*&quot;</span>));</span><br><span class="line">        <span class="comment">// 设置同意信任的url请求</span></span><br><span class="line">        configuration.setAllowCredentials(<span class="literal">true</span>);</span><br><span class="line">        source.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>,configuration);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CorsWebFilter</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><p><strong>项目部署问题：</strong>大型项目组件较多，运行环境也较为复杂，依赖关系复杂，容易出现兼容性问题。开发、测试、生产环境有差异</p>
<p><strong>Docker如何解决依赖兼容的问题？</strong></p>
<ul>
<li>Docker会将应用的Libs（函数库)、Deps（依赖)、配置与应用一起打包</li>
<li>将每个应用放到一个隔离容器去运行，避免互相干扰</li>
</ul>
<p>Docker是一个快速交付应用、运行应用技术。可以将程序及其依赖、运行环境一起打包为一个镜像，可以迁移到任意Linux操作系统，运行时利用沙箱机制形成隔离容器，各个应用互不干扰。启动、移除都可以通过一行命令完成，方便快捷</p>
<h2 id="Docker的架构"><a href="#Docker的架构" class="headerlink" title="Docker的架构"></a>Docker的架构</h2><p>Docker是采用C&#x2F;S的结构的程序，由两部分组成</p>
<ul>
<li>服务端(server)：Docker守护进程，负责处理Docker指令，管理镜像、容器等，DockerHup是Docker的服务器</li>
<li>客户端(client)：通过命令或RestAPI向Docker服务端发送指令。可以在本地或远程向服务端发送指令。</li>
</ul>
<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221229163742167.png" alt="image-20221229163742167"></p>
<h2 id="Docker的安装（Linux版本）"><a href="#Docker的安装（Linux版本）" class="headerlink" title="Docker的安装（Linux版本）"></a>Docker的安装（Linux版本）</h2><p>首先需要CentOS7的虚拟机</p>
<ol>
<li>安装yum的工具包，在控制台中输入以下命令即可</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils \</span><br><span class="line">          device-mapper-persistent-data \</span><br><span class="line">          lvm2 --skip-broken</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>更新本地镜像源</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager </span><br><span class="line">		--add-repo \</span><br><span class="line">			https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">			</span><br><span class="line">sed -i &#x27;s/down1oad.docker.com/mirrors.aliyun.com\/docker-ce/g&#x27; /etc/yum.repos.d/docker-ce.repo</span><br><span class="line">		</span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>然后输入命令</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y docker-ce</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>安装完成后启动前需要关闭掉linux的防火墙，否则Docker会启动失败，关闭防火墙的命令如下</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭当前防火墙，但下一次开机会自启防火墙</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">永久关闭</span></span><br><span class="line">systemctl disable firewalld</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>启动Docker服务</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>查看是否启动成功</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">若有版本号出现说明启动成功</span></span><br><span class="line">docker -v </span><br></pre></td></tr></table></figure>

<ol start="7">
<li>因为Docker的服务器在国外，故下载速度很慢，可以配置到国内的服务器上（需要自己到阿里云官网去开通镜像服务）</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">先创建一个目录</span></span><br><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一个json文件</span></span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27; </span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://n0dwemtq.mirror.aliyunce.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启</span></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<h2 id="Docker的基本操作"><a href="#Docker的基本操作" class="headerlink" title="Docker的基本操作"></a>Docker的基本操作</h2><p><strong>镜像相关的命令如图所示</strong></p>
<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221230095046053.png" alt="image-20221230095046053"></p>
<p>Docker的命令可以在控制台上进行查询通过如下命令即可</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker --help</span><br><span class="line">docker [具体的命令] --help</span><br></pre></td></tr></table></figure>

<p><strong>容器的相关命令</strong></p>
<p>docker exec：进入容器执行命令</p>
<p>docker logs：查看容器运行日志</p>
<p>docker ps：查看所有运行的容器及状态</p>
<p>docker rm：删除指定的容器</p>
<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221230101316509.png" alt="image-20221230101316509"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令解读</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker run：创建一个容器并运行</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--name containerName：起一个容器名称</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-p 80:80：端口映射，左是用户机的端口，右是服务器端口</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-d nginx：镜像名称</span></span><br><span class="line">docker run --name containerName -p 80:80 -d nginx</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令解读</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker <span class="built_in">exec</span> :进入容器内部，执行一个命令</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">it:给当前进入的容器创建一个标准输入、输出终端，允许我们与容器交互</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">mn :要进入的容器的名称</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">bash:进入容器后执行的命令，bash是一个linux终端交互命令</span></span><br><span class="line">docker exec -it mn bash</span><br></pre></td></tr></table></figure>

<p><strong>数据卷的相关命令</strong></p>
<p>数据卷的存在解决了：不便于修改，数据不可复用，升级维护困难</p>
<p>数据卷就是和容器内部的文件的映射，当数据卷修改时容器内部的文件也会修改。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker volume [comment]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">comment有如下选择</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">create：创建一个volume</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">inspect：显示一个或多个volume的信息</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ls</span>：列出所有的volume</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">prune：删除未使用的volume</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">rm</span>：删除一个或多个指定的volume</span></span><br></pre></td></tr></table></figure>

<p><strong>挂载数据卷</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在创建并运行容器时加上-v volumeName: /targetContainerPath即可,当volumeName不存在，会自动创建</span></span><br><span class="line">docker run --name containerName -p 80:80 -v volumeName: /targetContainerPath -d nginx</span><br></pre></td></tr></table></figure>

<h2 id="自定义镜像"><a href="#自定义镜像" class="headerlink" title="自定义镜像"></a>自定义镜像</h2><p><strong>镜像结构是分层的结构，每一层都有自己的配置</strong></p>
<p>Baselmage层：包含基本的系统函数库、环境变量、文件系统</p>
<p>Entrypoint：入口，是镜像中应用启动的命令</p>
<p>其它在Baselmage基础上添加依赖、安装程序、完成整个应用的安装和配置</p>
<p><strong>自定义镜像的步骤如下</strong></p>
<ol>
<li><p>首先定义一个自定义文件，该文件是描述镜像构建的过程</p>
</li>
<li><p>该文件的第一行必须是FROM，是从哪一层开始构建的</p>
</li>
<li><p>基础镜像可以是ubuntu也可以是别构建好的镜像java:8-alpine</p>
</li>
<li><p>准备好项目运行的压缩包并放到同一目录中</p>
</li>
<li><p>最后运行如下命令即可构建一个镜像</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t imageName:version .</span><br></pre></td></tr></table></figure>

<p><strong>自定义文件的构建</strong></p>
<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221230170937335.png" alt="image-20221230170937335"></p>
<p>自动补全命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -L \</span><br><span class="line">https://raw.githubusercontent.com/docker/compose/1.29.1/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose</span><br></pre></td></tr></table></figure>

<p>修改域名</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;199.232.68.133 raw.githubusercontent.com&quot; &gt;&gt; /etc/hosts</span><br></pre></td></tr></table></figure>

<h2 id="镜像仓库"><a href="#镜像仓库" class="headerlink" title="镜像仓库"></a>镜像仓库</h2><ul>
<li><p>公有仓库：DockerHub–&gt;<a target="_blank" rel="noopener" href="https://hub.docker.com/">Docker</a></p>
</li>
<li><p>私有仓库：需要自己搭建</p>
</li>
</ul>
<p><strong>搭建私有仓库的步骤如下</strong></p>
<ol>
<li>首先创建一个文件取名：docker-compose.yml</li>
<li>在配置一下daemen.json的文件，顺序执行以下命令即可，目的是为了让你创建的仓库被信任</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打开要修改的文件</span></span><br><span class="line">vi /etc/docker/daemon.json</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加内容：端口号是自己电脑或虚拟机的ip</span></span><br><span class="line">&quot;insecure-registries&quot;:[&quot;http://192.168.177.131:8088&quot;] </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重加载</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启docker</span></span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在docker-compose.yml中的内容如下</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">version: &#x27;3.0&#x27;</span><br><span class="line">services:</span><br><span class="line">  registry:</span><br><span class="line">    image: registry</span><br><span class="line">    volumes:</span><br><span class="line">      - ./registry-data:/var/lib/registry</span><br><span class="line">  ui:</span><br><span class="line">    image: joxit/docker-registry-ui:static</span><br><span class="line">    ports:</span><br><span class="line">      - 8088:80 # 左边的端口号是为了让外界访问此仓库的，可以修改</span><br><span class="line">    environment: </span><br><span class="line">      - REGISTRY_TITLE=RegistryOfMysties # 可以顺便起个仓库名称</span><br><span class="line">      - REGISTRY_URL=http://registry:5000</span><br><span class="line">    depends_on:</span><br><span class="line">      - registry</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>但上面的配置做完之后，再执行以下命令启动</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看启动日志</span></span><br><span class="line">docker-compose logs -f</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>然后在游览器访问</li>
</ol>
<p><strong>私有仓库镜像的相关操作</strong></p>
<p>推送镜像到私有镜像服务必须先tag，步骤如下：</p>
<ol>
<li>重新命名镜像名称，名称前缀是私有仓库的ip，例如：192.168.177.131:8088&#x2F;</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag nginx:latest 192.168.177.131:8088/nginx:1.0</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>推送本地镜像到私有仓库</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push 192.168.177.131:8088/nginx:1.0</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>从私有仓库中拉取镜像</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull 192.168.177.131:8088/nginx:1.0</span><br></pre></td></tr></table></figure>

<h1 id="MQ（MessageQueue）"><a href="#MQ（MessageQueue）" class="headerlink" title="MQ（MessageQueue）"></a>MQ（MessageQueue）</h1><p><strong>同步调用：</strong>就是每增加一个新的业务时，都需要新增一个远程调用到其它的微服务实例上，所以该调用方式存在的问题，耦合度高，性能下降，资源浪费，级联失败。</p>
<p>异步调用会解决同步调用的问题，单异步也有缺点：依赖于Broker的可靠性、安全性、吞吐能力，架构复杂了，业务没有明显的流程线，不好追踪管理</p>
<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221231141749235.png" alt="image-20221231141749235"></p>
<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221231142431990.png" alt="image-20221231142431990"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">孤江自流</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/12/02/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">http://example.com/2022/12/02/%E5%BE%AE%E6%9C%8D%E5%8A%A1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Hello World</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/springcloud/">springcloud</a></div><div class="post_share"><div class="social-share" data-image="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/mv.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/12/16/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/" title="java反射机制"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">java反射机制</div></div></a></div><div class="next-post pull-right"><a href="/2022/11/23/java%E6%A8%A1%E6%8B%9F%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C/" title="java模拟进程运行"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">java模拟进程运行</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/01/01/%E5%A4%A7%E5%9E%8B%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/" title="线上商城开发"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-01</div><div class="title">线上商城开发</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/mv.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">孤江自流</div><div class="author-info__description">日常学习笔记</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A4%E8%AF%86%E5%BE%AE%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.</span> <span class="toc-text">认识微服务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.</span> <span class="toc-text">微服务结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8A%80%E6%9C%AF%E5%AF%B9%E6%AF%94"><span class="toc-number">1.2.</span> <span class="toc-text">微服务技术对比</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SpringCloud"><span class="toc-number">2.</span> <span class="toc-text">SpringCloud</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E6%8B%86%E5%88%86"><span class="toc-number">3.</span> <span class="toc-text">服务拆分</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8"><span class="toc-number">3.1.</span> <span class="toc-text">微服务远程调用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Eureka%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83"><span class="toc-number">4.</span> <span class="toc-text">Eureka注册中心</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%90%AD%E5%BB%BAEurekaServer"><span class="toc-number">4.1.</span> <span class="toc-text">搭建EurekaServer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C"><span class="toc-number">4.2.</span> <span class="toc-text">服务注册</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Eureka%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">4.3.</span> <span class="toc-text">使用Eureka实现负载均衡</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Ribbon%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%8E%9F%E7%90%86"><span class="toc-number">5.</span> <span class="toc-text">Ribbon负载均衡原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84%E7%AD%96%E7%95%A5"><span class="toc-number">5.1.</span> <span class="toc-text">负载均衡的策略</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Nacos"><span class="toc-number">6.</span> <span class="toc-text">Nacos</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#nacos%E7%9A%84%E8%AE%BE%E7%BD%AE"><span class="toc-number">6.1.</span> <span class="toc-text">nacos的设置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">6.2.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86"><span class="toc-number">6.3.</span> <span class="toc-text">配置管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#nacos%E7%9A%84%E9%85%8D%E7%BD%AE%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%EF%BC%88%E7%83%AD%E6%9B%B4%E6%96%B0%EF%BC%89"><span class="toc-number">6.3.1.</span> <span class="toc-text">nacos的配置自动更新（热更新）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nacos%E7%9A%84%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">6.3.2.</span> <span class="toc-text">nacos的文件加载优先级</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HTTP%E5%AE%A2%E6%88%B7%E7%AB%AFFeign"><span class="toc-number">7.</span> <span class="toc-text">HTTP客户端Feign</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Feign%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">7.1.</span> <span class="toc-text">Feign的性能优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Feign%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">7.2.</span> <span class="toc-text">Feign的最佳实践</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Gateway%E7%BD%91%E5%85%B3"><span class="toc-number">8.</span> <span class="toc-text">Gateway网关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E5%8F%91%E7%BD%91%E5%85%B3%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="toc-number">8.1.</span> <span class="toc-text">开发网关的步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E8%BF%87%E6%BB%A4%E5%99%A8GatewayFilter%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="toc-number">8.2.</span> <span class="toc-text">路由过滤器GatewayFilter的配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E5%85%B3%E7%9A%84%E5%85%A8%E5%B1%80%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">8.3.</span> <span class="toc-text">网关的全局过滤器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E9%97%AE%E9%A2%98"><span class="toc-number">8.4.</span> <span class="toc-text">跨域请求问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Docker"><span class="toc-number">9.</span> <span class="toc-text">Docker</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker%E7%9A%84%E6%9E%B6%E6%9E%84"><span class="toc-number">9.1.</span> <span class="toc-text">Docker的架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker%E7%9A%84%E5%AE%89%E8%A3%85%EF%BC%88Linux%E7%89%88%E6%9C%AC%EF%BC%89"><span class="toc-number">9.2.</span> <span class="toc-text">Docker的安装（Linux版本）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">9.3.</span> <span class="toc-text">Docker的基本操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E9%95%9C%E5%83%8F"><span class="toc-number">9.4.</span> <span class="toc-text">自定义镜像</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93"><span class="toc-number">9.5.</span> <span class="toc-text">镜像仓库</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MQ%EF%BC%88MessageQueue%EF%BC%89"><span class="toc-number">10.</span> <span class="toc-text">MQ（MessageQueue）</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/03/03/spring-secuerity/" title="spring-security">spring-security</a><time datetime="2023-03-02T16:00:00.000Z" title="发表于 2023-03-03 00:00:00">2023-03-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/02/28/java%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C/" title="基于JSR303的数据校验">基于JSR303的数据校验</a><time datetime="2023-02-28T11:27:00.000Z" title="发表于 2023-02-28 19:27:00">2023-02-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/02/18/mysql%E8%BF%9B%E9%98%B6%E9%83%A8%E5%88%86/" title="Mysql进阶部分">Mysql进阶部分</a><time datetime="2023-02-18T08:00:00.000Z" title="发表于 2023-02-18 16:00:00">2023-02-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/02/17/redis%E5%9F%BA%E7%A1%80%E4%B8%8E%E8%BF%9B%E9%98%B6/" title="redis基础与进阶">redis基础与进阶</a><time datetime="2023-02-17T02:16:00.000Z" title="发表于 2023-02-17 10:16:00">2023-02-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/02/15/nginx%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/" title="nginx基础详解">nginx基础详解</a><time datetime="2023-02-15T02:34:00.000Z" title="发表于 2023-02-15 10:34:00">2023-02-15</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 孤江自流</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>