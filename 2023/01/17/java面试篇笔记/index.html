<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>java面试篇笔记 | Welcome To New World</title><meta name="author" content="孤江自流"><meta name="copyright" content="孤江自流"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="查找算法概述：最常见的查找算法有两种，一种是顺序查找，另一种是二分查找。  顺序查找的特点：适用范围广，可以查找像数组和链表这两种数据结构并且数据元素可以无序的，但查询效率低，时间复杂度O(n) 二分查找的特点：适用范围相对顺序查找小，只能查找像数组这样的数据结构并且要求数据必须是有序，查询效率高，时间复杂度O(logn)，那么以下代码是这两种算法的实现  12345678910111213141">
<meta property="og:type" content="article">
<meta property="og:title" content="java面试篇笔记">
<meta property="og:url" content="http://example.com/2023/01/17/java%E9%9D%A2%E8%AF%95%E7%AF%87%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Welcome To New World">
<meta property="og:description" content="查找算法概述：最常见的查找算法有两种，一种是顺序查找，另一种是二分查找。  顺序查找的特点：适用范围广，可以查找像数组和链表这两种数据结构并且数据元素可以无序的，但查询效率低，时间复杂度O(n) 二分查找的特点：适用范围相对顺序查找小，只能查找像数组这样的数据结构并且要求数据必须是有序，查询效率高，时间复杂度O(logn)，那么以下代码是这两种算法的实现  12345678910111213141">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/mv.jpg">
<meta property="article:published_time" content="2023-01-17T11:20:00.000Z">
<meta property="article:modified_time" content="2023-02-04T07:11:43.497Z">
<meta property="article:author" content="孤江自流">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/mv.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/01/17/java%E9%9D%A2%E8%AF%95%E7%AF%87%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="/LonelyBoy" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'java面试篇笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-02-04 15:11:43'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Welcome To New World" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/mv.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Welcome To New World"><span class="site-name">Welcome To New World</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">java面试篇笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-01-17T11:20:00.000Z" title="发表于 2023-01-17 19:20:00">2023-01-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-02-04T07:11:43.497Z" title="更新于 2023-02-04 15:11:43">2023-02-04</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="java面试篇笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h1><p>概述：最常见的查找算法有两种，一种是顺序查找，另一种是二分查找。</p>
<ul>
<li>顺序查找的特点：适用范围广，可以查找像数组和链表这两种数据结构并且数据元素可以无序的，但查询效率低，时间复杂度O(n)</li>
<li>二分查找的特点：适用范围相对顺序查找小，只能查找像数组这样的数据结构并且要求数据必须是有序，查询效率高，时间复杂度O(logn)，那么以下代码是这两种算法的实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  顺序查找算法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderSearch</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        System.out.println(orderSortMulti(arr,<span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 只要查找到第一个目标元素就返回</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 从该数组中查找目标元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target 目标元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 目标元素所在的下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">orderSort</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">// 顺序遍历查找即可</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 查询不到返回-1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  若目标元素在数组中有多个，例如&#123;5,1,4,5,6,7,2,0&#125; 在这一数组中要找目标为5，那要如何实现呢？</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">orderSortMulti</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(target == arr[i]) &#123;</span><br><span class="line">                result.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  二分查找</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinarySearch</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] array = &#123;<span class="number">1</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>,<span class="number">26</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> binarySearch(array, <span class="number">19</span>,<span class="number">0</span>,array.length);</span><br><span class="line">        System.out.println(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//二分查找实现方法 -- 迭代方式  前提:有已排序数组A（假设已经做好)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">//1. 定义左边界和右边界</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="comment">//2.获取中间索引mid = Floor((L+R)/2)</span></span><br><span class="line">        <span class="type">int</span> mid;</span><br><span class="line">        <span class="comment">//循环</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123; <span class="comment">//4.当left&gt;right时，表示没有找到，应结束循环</span></span><br><span class="line">            mid = left + (left - right) / <span class="number">2</span>; <span class="comment">//解决整数溢出问题</span></span><br><span class="line">            <span class="comment">//5.中间索引的值 A[M]与待搜索的值T进行比较</span></span><br><span class="line">            <span class="keyword">if</span>(arr[mid] &gt; target) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 未找到目标值的下标</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//二分查找方法 -- 递归方式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> target,<span class="type">int</span> left,<span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="comment">//判断是否已经结束</span></span><br><span class="line">        <span class="keyword">if</span>(left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//1. 判断中间值是否大于目标值</span></span><br><span class="line">        <span class="keyword">if</span>(arr[mid] &gt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span> binarySearch(arr,target,left,mid - <span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[mid] &lt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span> binarySearch(arr,target,mid + <span class="number">1</span>,right);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//2. 相等直接返回下标即可</span></span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上的代码有一个毛病，就是二分查找若数组中有多个目标数据，例如在{1,2,4,5,6,6,6,6,7,8,9}中查找6这个目标数据所在的下标，那应该如何实现呢？</p>
<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="冒泡排序算法"><a href="#冒泡排序算法" class="headerlink" title="冒泡排序算法"></a>冒泡排序算法</h2><p>概述：冒泡排序是比较排序，<strong>以升序为主</strong>，即给定一个无序的数组，每轮排序所有相邻的元素都会进行一个比较，若前一个数与后一个数大则进行数交换位置的操作，最后将最大的那个数排到数组最后一个位置，这就是冒泡排序，以下是冒泡排序的实现代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  冒泡排序算法的实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BubbleSort</span> &#123;</span><br><span class="line">    <span class="comment">// 记录循环的次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">24</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        bubbleSort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="comment">// 因为是每次两个数进行比较，所以总的排序次数是arr.length - 1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">           <span class="comment">// 注意arr.length - 1 - i这里的-i是将冒泡的最后有序部分剔除掉，避免重复无效的排序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="comment">// 说明两个相邻的数，左边的数比右边的大就进行交换操作</span></span><br><span class="line">                    swap(arr,j,j+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                count ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;总的循环次数为：&quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数交换</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 无序数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i 相邻两个数的左边下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j 相邻两个数的右边下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230117195938657.png" alt="image-20230117195938657"></p>
<p>在以上的冒泡排序算法中还存在一个问题，那就是若本来就有序的数组还是会重复无效的进行比较排序，这样就显得多此一举，故我们可以定义一个标志位进行一个判断，若一个数组已经是处于一个有序状态，则就可以提前结束循环，从而避免无效的排序循环。具体实现如下代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  冒泡排序算法的实现--优化version1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BubbleSort</span> &#123;</span><br><span class="line">    <span class="comment">// 记录循环的次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        bubbleSort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="comment">// 标志位</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 因为是每次两个数进行比较，所以总的排序次数是arr.length - 1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 改变标志位，说明该轮循环有进行交换操作</span></span><br><span class="line">                	  flag = <span class="literal">true</span>;</span><br><span class="line">                   <span class="comment">// 说明两个相邻的数，左边的数比右边的大就进行交换操作</span></span><br><span class="line">                    swap(arr,j,j+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                count ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!flag) &#123;</span><br><span class="line">                <span class="comment">// 在某一轮未进行比较操作，则可以说明该数组已经处于有序状态了</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;总的循环次数为：&quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数交换</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 无序数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i 相邻两个数的左边下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j 相邻两个数的右边下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>冒泡排序总结</strong></p>
<p>主要核心思想是：依次比较数组中相邻的两个元素，若前面的元素比后面的元素大，则需要进行交换，最后会将最大的数放到数组的最后位置。重复此操作最后数组就会变成有序的。时间复杂度是O(n^2)，空间复杂度是O(n)，并且是稳定排序。</p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>概述：在选择排序中数组分为有序部分和无序部分，每轮的排序都会将无序部分中最小的值排到有序部分上，例如，数组[8,2,1,4,5]，会先假定第一个值8为最小值，然后跟8后面的部分（无序部分）进行比较，若发现有比8还小的值（无序部分中最小的值），则将最小的值和8的位置进行交换，第二轮会假定2为最小值，以此类推，最终都会变得有序，以下是具体代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  选择排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">8</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        selectionSort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selectionSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 先假定数组的第一个为最小的值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="comment">// 在遍历寻找minIndex后边的值，是否存在比当前的值还小，若存在，则需要进行交换</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> minIndex + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[minIndex] &gt; arr[j]) &#123;</span><br><span class="line">                    minIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(minIndex != i) &#123;</span><br><span class="line">                <span class="comment">//说明在minIndex后边存在比当前的值还小，进行交换</span></span><br><span class="line">                swap(arr,minIndex,i);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Arrays.toString(arr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 数据元素交换，将i所在位置和j所在位置进行交换</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230117220509754.png" alt="image-20230117220509754"></p>
<p><strong>选择排序的总结</strong></p>
<p>选择排序的时间复杂度是O(n^2)，空间复杂度O(n)，是属于不稳定排序算法。</p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>概述：插入排序也分为有序部分和无序部分，有序部分会不断扩大，最终都将变成有序的数组，具体代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsertSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">9</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">        insertSort(arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 插入排序的实现方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="comment">// 首先从无序部分开始遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i]; <span class="comment">// 先暂时保存无序部分的第一个值，为后续的插入做准备</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - <span class="number">1</span>; <span class="comment">//有序部分的最后一个元素的索引</span></span><br><span class="line">            <span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; j--) &#123; <span class="comment">// temp依次比较有序部分的值，找到自己的合适位置</span></span><br><span class="line">                <span class="keyword">if</span>(temp &lt; arr[j]) &#123;</span><br><span class="line">                    <span class="comment">// 说明temp的值与当前的值小，当前的值需要往后移一位</span></span><br><span class="line">                    arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 说明temp值已经找到了合适的位置，结束循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前面的循环出来后，j + 1所在的索引就是temp值所在的位置</span></span><br><span class="line">            arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            System.out.println(Arrays.toString(arr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>插入排序的总结</strong></p>
<p>插入排序分为有序区域和无序区域，每轮排序都会从无序区域的第一个元素插入到有序区域的合适位置上（在有序部分碰到比temp值小的就可以确定temp的值所插入的位置），需要保证有序区域的有序性，重复以上步骤最终可以得到整体有序的数组。时间复杂度为O(n^2)，是稳定排序。<strong>执行的效率：插入排序 &gt; 选择排序 &gt; 冒泡排序</strong></p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>概述：快速排序是需要选择一个基准点pivot，然后进行每轮的排序，基准点的左边的值都比基准点本身的值小，右边的值都比基准点本身的值大，每次都会进行一个分区比较，每个区中都有一个基准点，最终分区的元素为0时，说明数组已经是基于有序了。这里体现的是分而治之的思想。以下代码是快速排序的实现过程（两种方式）</p>
<ul>
<li>单边循环快排</li>
</ul>
<p>在单边循环中一般选择数组最右边的元素作为基准点，这里实现的代码有两个指针<strong>i和j</strong>，<strong>i</strong>代表的是维护比基准点值小的左边界和每次交换的目标索引，<strong>j</strong>代表的是寻找比基准点还小的值与<strong>i</strong>所在的位置进行交换，最后<strong>i</strong>会和基准点进行交换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  快速排序--单边</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">5</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        quickSort(arr,<span class="number">0</span>,arr.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> left,<span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right) &#123;</span><br><span class="line">            <span class="comment">// 没有元素可以再进行分区，结束递归分区</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1. 进行一个分区并返回分区后基准点所在的索引位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivotIndex</span> <span class="operator">=</span> portion(arr, left, right);</span><br><span class="line">        <span class="comment">// 2. 根据基准点所在的位置对基准点左边在进行分区</span></span><br><span class="line">        quickSort(arr, left, pivotIndex - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 3. 根据基准点所在的位置对基准点右边进行分区</span></span><br><span class="line">        quickSort(arr, pivotIndex + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 待排序的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left 数组左边的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right 数组右边的所有</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 经过分区后i指针所在的位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">portion</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="comment">// 最右边的元素作为基准点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[right];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="comment">// j指针寻找比pivot小的值所在的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> left; j &lt; right; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &lt; pivot) &#123;</span><br><span class="line">                <span class="comment">// 说明找到了，就与i进行交换</span></span><br><span class="line">                swap(arr,i,j);</span><br><span class="line">                i ++; <span class="comment">// i需要右移一位</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后将i与基准点所在位置进行交换</span></span><br><span class="line">        swap(arr,i,right);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数交换</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 无序数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i 相邻两个数的左边下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j 相邻两个数的右边下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230118150315998.png" alt="image-20230118150315998"></p>
<ul>
<li>双边循环快排</li>
</ul>
<p>概述：双边循环也称为双指针循环，一般数组的最左边元素是作为基准点，在双指针中假设是i和j，i的职责是从左往右寻找比级基准点大的元素，j的职责是从右往左寻找比基准点小的元素，若ij分别找到各自的元素则进行交换，最后i和j相交时则结束寻找，此时的i就是分区的位置，最后i和基准点需要进行一次交换。</p>
<p><strong>细节问题</strong>：在i和j指针寻找的顺序，必须先寻找小的值，然后再寻找大的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  快速排序--双边循环</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">5</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">        quickSort(arr,<span class="number">0</span>,arr.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> left,<span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right) &#123;</span><br><span class="line">            <span class="comment">// 没有元素可以再进行分区，结束递归分区</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1. 进行一个分区并返回分区后基准点所在的索引位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivotIndex</span> <span class="operator">=</span> portion(arr, left, right);</span><br><span class="line">        <span class="comment">// 2. 根据基准点所在的位置对基准点左边在进行分区</span></span><br><span class="line">        quickSort(arr, left, pivotIndex - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 3. 根据基准点所在的位置对基准点右边进行分区</span></span><br><span class="line">        quickSort(arr, pivotIndex + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">portion</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> left,<span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="comment">// 选择最左边的作为基准点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[left];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; <span class="comment">// 负责找比基准点大的元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> right;<span class="comment">// 负责找比基准点小的元素</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">           <span class="comment">// 先找小的值</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt; pivot) &#123;</span><br><span class="line">                j --;</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="comment">// 再找大的值</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt;= pivot ) &#123;</span><br><span class="line">                i ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// i 和 j 进行交换</span></span><br><span class="line">            swap(arr,i,j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后i和基准点进行交换</span></span><br><span class="line">        swap(arr,i,left);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数交换</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 无序数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i 相邻两个数的左边下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j 相邻两个数的右边下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>快速排序的总结</strong></p>
<p>平均时间复杂度O(nlog2n)，最坏的时间复杂度O(n^2)，对于数据量比较大时使用该算法会有比较明显的优势，是不稳定排序</p>
<h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><h2 id="ArrayList的扩容机制"><a href="#ArrayList的扩容机制" class="headerlink" title="ArrayList的扩容机制"></a>ArrayList的扩容机制</h2><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230118160852310.png" alt="image-20230118160852310"></p>
<h2 id="LinkedList和ArrayList的比对"><a href="#LinkedList和ArrayList的比对" class="headerlink" title="LinkedList和ArrayList的比对"></a>LinkedList和ArrayList的比对</h2><p><strong>LinkedList</strong></p>
<ul>
<li>LinkedList底层是双向链表实现，无需连续内存空间，随机访问慢，头尾插入和删除操作的效率高（因为链表的插入和删除操作不用移动元素），但在插入和删除中间的元素时性能较低（若只考虑插入和删除的操作，则效率高，若考虑定位查找到目标数据或目标位置然后再进行增删操作，则总体的效率低），占用内存大。</li>
</ul>
<p><strong>ArrayList</strong></p>
<ul>
<li>ArrayList底层是基于数组实现的，需要连续的内存空间来存储数据，可以通过计算来确定数组的下标，从而确定需要访问的目标数据，故随机访问速度快。在一定长度的数组头部和中间数据进行增删操作效率比LinkedList低，但在尾部进行插入和删除的效率比LinkedList高。可以利用CPU缓存和局部性原理（CPU每次读取数据进行计算时都会读取目标数据的相邻元素一起读到缓存中）。占用内存小</li>
</ul>
<h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><p>HashMap的底层数据结构JDK1.7和JDK1.8版本有什么区别？</p>
<ul>
<li><strong>在JDK1.7版本中HashMap是采用数组+链表，在JDK1.8是数组 +（链表 | 红黑树）</strong></li>
</ul>
<p>如何解决HashMap底层的链表过长问题？</p>
<ul>
<li><strong>通过给HashMap的数组扩容，但在某个特殊的情况下并不能有效的解决。</strong></li>
<li><strong>通过树化链表可以有效解决，前提条件是在HashMap的数组长度达到（&gt;&#x3D;64）才能触发树化效果并且在某个数组下的节点大到8个节点</strong></li>
</ul>
<p>为何需要使用红黑树？为什么不是一上来就树化？</p>
<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230119150749106.png" alt="image-20230119150749106"></p>
<p>HashMap的索引计算？</p>
<ul>
<li><strong>通过调用hash的方法来计算对象的HashCode，然后再模于数组的长度 - 1，&gt;&gt; 公式：hash值 mod 数组长度 - 1</strong></li>
</ul>
<p>为何需要进行二次的hashCode的计算？</p>
<ul>
<li><strong>二次hashCode的计算是为了综合高位数据，使得哈希分布更为均匀。</strong></li>
</ul>
<p>数组容量为何是2的n次幂？</p>
<ul>
<li><strong>因为2的n次幂可以通过位与运算得到取模运算同样的结果，并且位与运算效率更高，扩容时若 hash &amp; 旧容量长度 &#x3D;&#x3D; 0，则元素的位置不变，否则新位置&#x3D;旧位置+旧容量的长度。</strong></li>
</ul>
<p>HashMap_put()的流程？</p>
<ul>
<li><strong>HashMap是懒惰创建数组的，首次使用才创建数组计算索引（桶下标)</strong></li>
<li><strong>如果桶下标还没人占用，创建Node占位返回</strong></li>
<li><strong>如果桶下标已经有人占用</strong><ul>
<li><strong>已经是TreeNode走红黑树的添加或更新逻辑</strong></li>
<li><strong>是普通Node，走链表的添加或更新逻辑，如果链表长度超过树化阈值，走树化逻辑</strong></li>
</ul>
</li>
<li><strong>返回前检查容量是否超过阈值，一旦超过进行扩容不同</strong></li>
</ul>
<p>HashMap_put()在JDK1.7和JDK1.8的不同？</p>
<ol>
<li><strong>链表插入节点时，1.7是头插法，1.8是尾插法。</strong></li>
<li><strong>1.7是大于阈值（数组长度 * 负载因子(0.75)）且没有空位才进行扩容，1.8是大于阈值就进行扩容。</strong></li>
<li><strong>1.8比1.7的效率更高。</strong></li>
</ol>
<p>加载（负载）因子为何是0.75？</p>
<ul>
<li><strong>在空间占用与查询时间之间取得较好的权衡</strong></li>
<li><strong>大于这个值，空间节省了，但链表就会比较长影响性能</strong></li>
<li><strong>小于这个值，冲突减少了，但扩容就会更频繁，空间占用多</strong></li>
</ul>
<p>多线程下HashMap会出现什么问题（在JDK1.7版本下发生）？</p>
<ol>
<li><p><strong>并发丢失数据。</strong></p>
</li>
<li><p><strong>由于头插法导致并发下扩容死链问题。</strong></p>
</li>
</ol>
<p>HashMap中的key是否可以为null，作为key的对象有和要求？</p>
<ol>
<li><strong>HashMap中的key是可以为null的，但在其它的map集合中是不可以为null的，例如HashTable。</strong></li>
<li><strong>作为key的对象，必须实现hashCode和equals的方法，并且key对象是不可修改的。</strong></li>
</ol>
<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230119203801278.png" alt="image-20230119203801278"></p>
<h1 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h1><p>以下是单例模式的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> a_based_item1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  饿汉式单例--在该类初始化的时候就创建实例对象，线程是安全的。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 预防反射破坏单例</span></span><br><span class="line">        <span class="keyword">if</span>(INSTANCE != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;单例不可重复创建&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Singleton单例模式初始化。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">otherMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;otherMethod其它方法执行。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>单例被破坏的三最种情况</strong></p>
<ol>
<li>反射破坏单例，这是可以预防的，如上代码。</li>
<li>反序列化破坏单例（可解决）</li>
<li>unsafe破坏单例（不可解决）</li>
</ol>
<p>以下是懒汉式单例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  懒汉式单例--类在加载时不实例化对象，只有等到第一次用的时候才去实例化。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;懒汉式单例初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton2</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 创建实例</span></span><br><span class="line">            INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton2</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在多线程序会破坏单例的证明如下测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  多线程下破坏懒汉式单例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonTest2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建10个线程</span></span><br><span class="line">        creatThreadByNum(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">creatThreadByNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="type">Singleton2</span> <span class="variable">instance</span> <span class="operator">=</span> Singleton2.getInstance();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;&gt;&gt;&quot;</span> + instance);</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.setName(<span class="string">&quot;线程&quot;</span> + (i + <span class="number">1</span>));</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230120144155537.png" alt="image-20230120144155537"></p>
<p><strong>以下代码是解决多线程下破坏懒汉式单例的方案DCL（Double Check Lock）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  懒汉式单例--DCL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;懒汉式单例初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 需要加volatile，可以解决共享变量的可见性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">Singleton2</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 加锁，防止多线程同时满足条件，同时进行创建实例的代码块</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton2.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton2</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230120144624401.png" alt="image-20230120144624401"></p>
<h1 id="并发篇"><a href="#并发篇" class="headerlink" title="并发篇"></a>并发篇</h1><h2 id="Java线程的六种状态"><a href="#Java线程的六种状态" class="headerlink" title="Java线程的六种状态"></a>Java线程的六种状态</h2><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230120150100666.png" alt="image-20230120150100666"></p>
<p><strong>下图是操作系统中的线程状态</strong></p>
<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230121140706806.png" alt="image-20230121140706806"></p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p><strong>java.util.concurrent.ThreadPoolExecutor</strong></p>
<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230121142617613.png" alt="image-20230121142617613"></p>
<h2 id="Wait-VS-Sleep"><a href="#Wait-VS-Sleep" class="headerlink" title="Wait VS Sleep"></a>Wait VS Sleep</h2><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230121150713734.png" alt="image-20230121150713734"></p>
<h2 id="Lock-VS-Synchronized"><a href="#Lock-VS-Synchronized" class="headerlink" title="Lock VS Synchronized"></a>Lock VS Synchronized</h2><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230121152148928.png" alt="image-20230121152148928"></p>
<p><strong>公平锁与非公平锁的区别？</strong></p>
<ul>
<li>公平锁是在阻塞队列中的线程分别以先进先出的形式依次执行线程</li>
<li>非公平锁不是以先进先出的形式出现，有可能出现其他线程插队的情况。</li>
</ul>
<h2 id="Volatile关键字"><a href="#Volatile关键字" class="headerlink" title="Volatile关键字"></a>Volatile关键字</h2><p><strong>线程安全包括三个方面：可见性、有序性、原子性</strong></p>
<ul>
<li>可见性：是一个线程对某个变量进行修改，其它线程是能看到最新的结果</li>
<li>有序性：一个线程中的代码是按照编码顺序执行的</li>
<li>原子性：一个线程中的代码是以一个整体运行的，在运行期间不可以有其它线程代码插队</li>
</ul>
<p><strong>Volatile关键字可以保证可见性和有序性，不能保证原子性</strong></p>
<h2 id="乐观锁VS悲观锁"><a href="#乐观锁VS悲观锁" class="headerlink" title="乐观锁VS悲观锁"></a>乐观锁VS悲观锁</h2><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230124144738446.png" alt="image-20230124144738446"></p>
<h2 id="HashTable-VS-ConcrrentHashMap"><a href="#HashTable-VS-ConcrrentHashMap" class="headerlink" title="HashTable VS ConcrrentHashMap"></a>HashTable VS ConcrrentHashMap</h2><ol>
<li>HashTable和ConcrrentHashMap都是线程安全的（相同点）。</li>
<li>HashTable由于底层是用同一把锁，则每次只能有一个线程操作，则并发度较低。</li>
<li>ConcrrentHashMap在JDK1.8版本之前采用segment+数组+链表，每个segment对应一把锁，多个线程访问时都会获取不同的锁，则不会冲突。</li>
<li>在JDK1.8之后ConcrrentHashMap采用头节点作为锁，若多个线程访问不同的头节点，则不会冲突。</li>
</ol>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><ol>
<li>ThreadLocal是可以实现【资源对象】的线程隔离，让每个线程都用自己的【资源对象】，从而避免线程安全的问题。</li>
<li>ThreadLocal可以实现同个线程间资源共享。</li>
</ol>
<p>以下代码是证明以上ThreadLocal的特点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> Integer age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  ThreadLocal证明测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalTest</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  ThreadLocal是底层是基于map实现的，是key-value结构</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;User&gt; tl = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        testOne();</span><br><span class="line">        testTwo(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  测试一：【同个线程间】在从ThreadLocal获取资源对象是否相同？</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testOne</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            tl.set(<span class="keyword">new</span> <span class="title class_">User</span>());</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：&quot;</span> + tl.get());</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：&quot;</span> + tl.get());</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：&quot;</span> + tl.get());</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  测试二：【不同线程间】从ThreadLocal获取资源对象是否相同？</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testTwo</span><span class="params">(<span class="type">int</span> threadNum)</span> &#123;</span><br><span class="line">        <span class="comment">// 根据threadNum创建线程数量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadNum; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                tl.set(<span class="keyword">new</span> <span class="title class_">User</span>());</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：&quot;</span> + tl.get());</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230126135721217.png" alt="image-20230126135721217"></p>
<p><strong>ThreadLocal的原理</strong></p>
<p>ThreadLocal类中存在成员变量ThreadLocalMap，ThreadLocalMap本质上还是key-value结构，用于存储资源对象</p>
<ul>
<li>当调用set方法是需要存储两个值的，ThreadLocal本身是作为key，资源对象是作为value存储的。</li>
<li>当调用get方法是根据ThreadLocal本身去寻找value值。</li>
<li>调用remove方法，是以ThreadLocal本身作为key去移除相关的资源值。</li>
</ul>
<p><strong>为什么ThreadLocalMap的key（即ThreadLocal）是弱引用？</strong></p>
<ol>
<li>因为ThreadLocal可能会长时间存在线程中，若key不需要再使用，则会在内存不足时将该key释掉。</li>
<li>第一步只是让key释放掉，但其value未被释放，还需要进一步的根据key是否为null来释放值的内存，释放的时机有如下<ol>
<li>获取key时发现为null</li>
<li>set key时，会使用启发式扫描，清除临近的null key，启发次数与元素个数，是否发现 null key有关</li>
<li>remove时(推荐)，因为一般使用ThreadLocal时都把它作为静态变量，因此GC（jvm的垃圾回收机制）无法回收</li>
</ol>
</li>
</ol>
<h1 id="JVM虚拟机"><a href="#JVM虚拟机" class="headerlink" title="JVM虚拟机"></a>JVM虚拟机</h1><ul>
<li>程序私有：程序计数器（记录CPU已经执行到哪行代码）、虚拟机栈</li>
<li>程序共有：堆、方法区</li>
</ul>
<p><em><strong>下图是JVM虚拟机执行java程序代码的整体概况</strong></em></p>
<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230126142916151.png" alt="image-20230126142916151"></p>
<p>不会出现内存溢出的区域：程序计数器</p>
<p><strong>出现OutOfMemoryError（OOM）的情况</strong></p>
<ul>
<li>堆内存耗尽：对象越来越多且一直在使用，无法被垃圾回收</li>
<li>方法区内存耗尽：加载的类越来越多，很多框架在启动时会动态的加载所需要的类</li>
<li>虚拟机栈积累：每个线程最多占用1M的内存，线程个数越来越多，而又长时间不销毁</li>
</ul>
<p><strong>出现OutOverflowError的情况</strong></p>
<ul>
<li>虚拟机栈内部：方法调用次数过多</li>
</ul>
<h2 id="JVM中的内存参数"><a href="#JVM中的内存参数" class="headerlink" title="JVM中的内存参数"></a>JVM中的内存参数</h2><p>对于JVM内存参数有：-Xmx10240m、-Xms10240m、-Xmn5120m、-XX:SurvivoRatio&#x3D;3、其最小内存值和Survivo区总大小分别是？</p>
<ul>
<li>-Xmx10240m是代表最大内存10G，-Xms10240m是代表最小内存10G</li>
<li>-Xmn5120m代表新生代的内存是5G，那么老年代是占用5G</li>
<li>-XX:SurvivoRatio&#x3D;3代表在新生代内存的比例</li>
</ul>
<h2 id="JVM中的垃圾回收算法"><a href="#JVM中的垃圾回收算法" class="headerlink" title="JVM中的垃圾回收算法"></a>JVM中的垃圾回收算法</h2><p><strong>标记清理、标记整理、标记复制这三种垃圾回收算法</strong></p>
<p>下图是标记清理，清理未标记的类对象，该垃圾回收算法是有缺点的，在白色区域是代表已清理的类对象所遗留下的内存空间，有些内存空间被可用的类对象所隔离开来，就产生了内存碎片。</p>
<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230126201031183.png" alt="image-20230126201031183"></p>
<p><strong>标记整理</strong>是为了解决标记清理算法缺点，每次清理完成后都会对可用的类对象进行一个整理，这样就避免了产生内存碎片，但多了一步整理的操作，故效率就会降低。</p>
<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230126201517144.png" alt="image-20230126201517144"></p>
<p><strong>标记复制</strong>是需要两个存储空间A和B，假如A需要进行对象清理操作，就可以把在A区域标记的对象复制到B的空闲区域中，然后将A区域的所有空间都清理掉即可，缺点是需要额外的空间。</p>
<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230126201758602.png" alt="image-20230126201758602"></p>
<h2 id="GC和分代回收算法"><a href="#GC和分代回收算法" class="headerlink" title="GC和分代回收算法"></a>GC和分代回收算法</h2><p>GC存在的目标是无用对象自动释放、减少内存碎片、加快分配速度。以下是GC的要点</p>
<ol>
<li>回收区域是堆内存，不包括虚拟机栈，在方法调用结束会自动释放方法</li>
<li>占用内存判断无用对象，使用<strong>可达性分析算法</strong>，<strong>三色标记法</strong>标记存活对象，回收未标记对象</li>
<li>GC具体的实现称为<strong>垃圾回收器</strong></li>
<li>GC大都采用了分代回收思想，理论依据是大部分对象朝生夕灭，用完立刻就可以回收，另有少部分对象会长时间存活，每次很难回收，根据这两类对象的特性将回收区域分为新生代和老年代，不同区域应用不同的回收策略</li>
<li>根据GC的规模可以分成 Minor GC，Mixed GC,Full Gc</li>
</ol>
<h2 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h2><p><strong>伊甸园(eden)：</strong>最初的对象分配在此区域，与幸存区合成称为新生代。</p>
<p><strong>幸存区(survivor)：</strong>当伊甸园的内存不足时，触发垃圾回收后的幸存对象分配到此区域，分为from和to区域，采用标记复制法</p>
<p><strong>老年代(old)：</strong>但幸存区对象熬过几次的垃圾回收（最多15次）后就会晋升为老年代</p>
<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230127135449616.png" alt="image-20230127135449616"></p>
<p><strong>GC的规模</strong></p>
<p>​	Minor GC发生在新生代的垃圾回收，暂停时间短</p>
<p>​	Mixed GC新生代＋老年代部分区域的垃圾回收，G1收集器特有</p>
<p>​	Full GC新生代＋老年代完整垃圾回收，暂停时间长，应尽力避免</p>
<p><strong>三色标记</strong></p>
<ol>
<li>黑色：已标记</li>
<li>灰色：标记中</li>
<li>白色：还未标记</li>
</ol>
<h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><p>介绍三种垃圾回收器的特点？</p>
<p><strong>Parallel GC(并行垃圾回收器)</strong></p>
<ol>
<li>eden内存不足发生Minor GC，标记复制STW</li>
<li>old内存不足发生Full GC，标记整理STW</li>
<li>注重吞吐量</li>
</ol>
<p><strong>ConcurrentMarkSweep GC(并发垃圾回收器)</strong></p>
<ol>
<li>old并发标记，重新标记时需要STW，并发清除</li>
<li>Failback Full GC（当总内存不足时会触发回退机制）</li>
<li>注重响应时间</li>
</ol>
<p><strong>G1 GC</strong></p>
<ol>
<li>响应时间与吞吐量兼顾</li>
<li>划分成多个区域，每个区域都可以充当eden,survivor, old,humongous</li>
<li>新生代回收：eden内存不足，标记复制STW(Stop The Word 是GC事件发生过程中，会产生应用程序的停顿)</li>
<li>并发标记：old并发标记，重新标记时需要STW</li>
<li>混合收集：并发标记完成，开始混合收集，参与复制的有eden、survivor、old，其中old会根据暂停时间目标，选择部分回收价值高的区域，复制时STW</li>
<li>Failback ull GC(回退)</li>
</ol>
<h2 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h2><p>概述：大部分的内存溢出是出现在误用了错误的线程池而出现的OutOfMemoryError保错，那么以下是误用线程池的例子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  内存溢出测试</span></span><br><span class="line"><span class="comment"> *  -Xmx64m</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OutOfMemoryTest</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个线程池，初始化线程数2</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        generousCreateThread();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  测试线程数创建过多而导致的内存溢出问题</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">generousCreateThread</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 死循环</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            threadPool.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">30</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">                count ++;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230127145448373.png" alt="image-20230127145448373"></p>
<p><strong>线程创建过多：</strong>造成以上错误的原因是使用了 Executors.newFixedThreadPool()创建线程池，而这种方式创建最大的线程数是Integer.MAX_VALUE的最大值，但线程数超过了最大值必然会出现内存溢出的错误，那么如何解决这种错误呢？根据alibaba的开发手册，在开发中尽量不使用Executors.newFixedThreadPool()创建线程池，一般使用ThreadPoolExecutor创建，自己定义线程池的配置参数。在此文章的并发篇有说到ThreadPoolExecutor创建线程池的配置参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  使用ThreadPoolExecutor创建线程池，看是否会出现内存溢出错误？</span></span><br><span class="line"><span class="comment"> *  -Xmx64m</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OutOfMemoryTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化容量为5的堵塞队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ArrayBlockingQueue&lt;Runnable&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">2</span>,<span class="number">4</span>,<span class="number">0</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">            queue);</span><br><span class="line">    <span class="comment">// 记录线程的名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; records = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        generousCreateThread();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  测试线程数创建过多而导致的内存溢出问题</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">generousCreateThread</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 死循环</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                threadPool.submit(() -&gt; &#123;</span><br><span class="line">                    records.add(Thread.currentThread().getName());</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String name: records) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程名称：&quot;</span> + name);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;提交线程任务的次数：&quot;</span> +  records.size() );</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230127151428616.png" alt="image-20230127151428616"></p>
<p><strong>每次从数据库查询的数据量过多也会导致内存溢出问题，所以说在查询数据库时需要加上limit条件，避免数据查询过多</strong></p>
<p><strong>加载的类太多也会导致内存溢出，溢出的是元空间的区域</strong></p>
<h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><p><strong>加载阶段</strong></p>
<ol>
<li>将类的字节码载入方法区，并创建类.class对象</li>
<li>如果此类的父类还未加载，则先加载父类</li>
<li>加载是懒惰执行方式（真正用到此类才进行初始化）</li>
</ol>
<p><strong>链接阶段</strong></p>
<ol>
<li>验证：验证加载的Class对象是否规范、合法性和安全检查</li>
<li>准备：为static变量分配空间和设置默认值</li>
<li>解析：将常量池的符号引用解析为直接引用</li>
</ol>
<p><strong>初始化</strong></p>
<ol>
<li>执行静态代码块和非final的变量赋值</li>
<li>初始化为懒惰执行</li>
</ol>
<h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><p>双亲委派：类加载是优先委派上级类加载器加载，存在以下两种情况</p>
<ul>
<li>若在上级加载器中能找到目标类，则由上级类加载器加载，加载的类对下级类加载器可见。</li>
<li>若上级加载器未找到目标类，则下级加载器才有资格执行加载。</li>
</ul>
<h2 id="对象的引用类型有几种"><a href="#对象的引用类型有几种" class="headerlink" title="对象的引用类型有几种"></a>对象的引用类型有几种</h2><p><strong>强引用</strong></p>
<ol>
<li><p>普通变量赋值即为强引用，例如：A a &#x3D; new A();</p>
</li>
<li><p>通过GC root 引用链的强引用用不到该对象，则会被垃圾回收，若该对象还再被使用，则不能被回收</p>
</li>
</ol>
<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230128142606197.png" alt="image-20230128142606197"></p>
<p><strong>软引用</strong></p>
<ol>
<li>例如：SoftReference s &#x3D; new SoftReference (new A());</li>
<li>如果仅有软引用该对象时，首次垃圾回收不会回收该对象，当内存不足时垃圾回收会将该对象回收</li>
<li>在垃圾回收时需要配合引用队列来释放</li>
<li>典型例子是反射数据</li>
</ol>
<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230128142908493.png" alt="image-20230128142908493"></p>
<p><strong>弱引用</strong></p>
<ol>
<li>例如：WeakReference w &#x3D; new WeakReference (new A());</li>
<li>只要发生垃圾回收，就会将弱引用的对象回收</li>
<li>在垃圾回收时需要配合引用队列来释放</li>
<li>典型例子是ThreadLocalMap中的Entry对象</li>
</ol>
<p><strong>虚引用</strong></p>
<ol>
<li><p>例如：PhantomReference p &#x3D;  new PhantomReference (new A());</p>
</li>
<li><p>必须配合引用队列一起使用，当虚引用引用的对象被回收时，会将虚引用对象入队，由Reference Handler线程释放其关联的外部资源</p>
</li>
</ol>
<h2 id="ThreadLocalMap的弱引用"><a href="#ThreadLocalMap的弱引用" class="headerlink" title="ThreadLocalMap的弱引用"></a>ThreadLocalMap的弱引用</h2><p>在文章的并发篇有写到ThreadLocal的特点，在日常开发中也经常用到ThreadLocal来存储用户的信息并且保证了每个线程中都有自己所属的用户信息，保证了线程安全，但ThreadLocal的ThreadLocalMap中的Entry是弱引用，一旦发生垃圾回收就会将其的key给回收掉，而值value并未被回收，这样就造成了内存泄露，以前是主动调用ThreadLocal类提供的remove方法删除掉value数据来解决，那么以下例子是从另一种方法解决的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  ThreadLocalMap，使用引用队列解决内存泄露问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalMapTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">MyWeakReference</span> <span class="variable">wr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyWeakReference</span>();</span><br><span class="line">        <span class="comment">// 存键值new String是引用</span></span><br><span class="line">        wr.put(<span class="number">0</span>,<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>),<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="comment">// 第二个的数据是强引用</span></span><br><span class="line">        wr.put(<span class="number">1</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        wr.put(<span class="number">2</span>,<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;c&quot;</span>),<span class="string">&quot;hi~~&quot;</span>);</span><br><span class="line">        wr.put(<span class="number">3</span>,<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;d&quot;</span>),<span class="string">&quot;hehehe&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;还未进行垃圾回收的结果：&quot;</span> + wr);</span><br><span class="line">        <span class="comment">// 启用垃圾回收机制</span></span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;垃圾回收后的结果：&quot;</span> + wr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用clean方法将值处理掉</span></span><br><span class="line">        wr.clean();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;清除key为null数据后的结果：&quot;</span> + wr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyWeakReference</span> &#123;</span><br><span class="line">        <span class="comment">// 创建引用队列，当若引用被回收是，会放到引用队列中</span></span><br><span class="line">        <span class="keyword">static</span> ReferenceQueue&lt;Object&gt; queue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 创建一个Entry继承弱引用</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;String&gt; &#123;</span><br><span class="line">            String value;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="title function_">Entry</span><span class="params">(String key,String value)</span> &#123;</span><br><span class="line">               <span class="built_in">super</span>(key,queue);</span><br><span class="line">               <span class="built_in">this</span>.value = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 定义一个数组长度为4</span></span><br><span class="line">        Entry[] table = <span class="keyword">new</span> <span class="title class_">Entry</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  该方法的作用是在垃圾回收时，将回收的key对应的value清除掉</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clean</span><span class="params">()</span> &#123;</span><br><span class="line">            Object temp;</span><br><span class="line">            <span class="keyword">while</span> ((temp = queue.poll()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 说明有弱引用的对象被回收，则从该队列中取出对象置为null即可</span></span><br><span class="line">               <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; table.length; i++) &#123;</span><br><span class="line">                   <span class="keyword">if</span>(table[i] == temp) &#123;</span><br><span class="line">                       <span class="comment">// 说明两个是同个对象，且key已经被回收了</span></span><br><span class="line">                       table[i] = <span class="literal">null</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 编写存入数据的方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> index,String key,String value)</span> &#123;</span><br><span class="line">            table[index] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key,value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Entry entry : table) &#123;</span><br><span class="line">                <span class="keyword">if</span> (entry != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">k</span> <span class="operator">=</span> entry.get();</span><br><span class="line">                    <span class="keyword">if</span> (k != <span class="literal">null</span> &amp;&amp; k.equals(key)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> entry.value;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            str.append(<span class="string">&quot;[  &quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (Entry e: table) &#123;</span><br><span class="line">                <span class="keyword">if</span>(e != <span class="literal">null</span>) &#123;</span><br><span class="line">                    str.append(<span class="string">&quot;key:&quot;</span>).append(e.get()).append(<span class="string">&quot; value:&quot;</span>).append(e.value).append(<span class="string">&quot; | &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            str.deleteCharAt(str.lastIndexOf(<span class="string">&quot;|&quot;</span>));</span><br><span class="line">            str.append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> str.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230128160434391.png" alt="image-20230128160434391"></p>
<h1 id="框架篇"><a href="#框架篇" class="headerlink" title="框架篇"></a>框架篇</h1><h2 id="Refresh的工作流程"><a href="#Refresh的工作流程" class="headerlink" title="Refresh的工作流程"></a>Refresh的工作流程</h2><p>概述：本篇文章是针对spring的加载过程的核心方法refresh各个功能进行梳理，refresh方法是初始化ioc容器的核心方法，<strong>Spring</strong>容器创建之后，会调用它的refresh<strong>方法刷新</strong>Spring应用的上下文。</p>
<p><strong>Refresh方法下的其它12个方法的名称如下</strong></p>
<ol>
<li><p>prepareRefresh（刷新前的准备工作）</p>
</li>
<li><p>prepareBeanFactory（Bean工厂的准备）</p>
</li>
<li><p>obtainFreshBeanFactory（获得新Bean工厂）</p>
</li>
<li><p>postProcessBeanFactory（处理后的Bean工厂）</p>
</li>
<li><p>invokeBeanFactoryPostProcessors（执行BeanFactory后置处理器）</p>
</li>
<li><p>registerBeanPostProcessors（注册bean后置处理器）</p>
</li>
<li><p>initMessageSource（初始化信息资源、国际化）</p>
</li>
<li><p>initApplicationEventMulticaster（初始化app事件发布器）</p>
</li>
<li><p>onRefresh（空方法，留给子类扩展，在容器刷新时重写可以进行一些操作）</p>
</li>
<li><p>registerListeners（注册监听器，接收来自app事件发布器发布的事件）</p>
</li>
<li><p>finishBeanFactoryInitialization（完成bean工厂的初始化）</p>
</li>
<li><p>finishRefresh（完成bean创建和初始化过程，通知生命周期处理器 lifecycleProcessor 刷新过程，同时发出 ContextRefreshEvent 通知。）</p>
</li>
</ol>
<h3 id="prepareRefresh"><a href="#prepareRefresh" class="headerlink" title="prepareRefresh"></a>prepareRefresh</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">prepareRefresh</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">//记录时间</span></span><br><span class="line">    <span class="built_in">this</span>.startupDate = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">//设置当前容器未关闭</span></span><br><span class="line">    <span class="built_in">this</span>.closed.set(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//设置当前容器已激活</span></span><br><span class="line">    <span class="built_in">this</span>.active.set(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.logger.isInfoEnabled()) &#123;</span><br><span class="line">    	<span class="comment">//打印容器刷新日志</span></span><br><span class="line">        <span class="built_in">this</span>.logger.info(<span class="string">&quot;Refreshing &quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//初始化一下属性(该方法默认是空的,是提供给子类来实现的,</span></span><br><span class="line">	<span class="comment">//假设我们有些工作需要在初始化bean以前就要加载设置等,可以通过重写这个方法来完成)</span></span><br><span class="line">    <span class="built_in">this</span>.initPropertySources();</span><br><span class="line">    <span class="comment">//校验设置的属性是否合法</span></span><br><span class="line">    <span class="built_in">this</span>.getEnvironment().validateRequiredProperties();</span><br><span class="line">    <span class="comment">//初始化一个集合属性,提供用来保存后面创建的事件,如果有事件发生会放入这个集合中</span></span><br><span class="line">    <span class="built_in">this</span>.earlyApplicationEvents = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="obtainFreshBeanFactory（获取Bean工厂）"><a href="#obtainFreshBeanFactory（获取Bean工厂）" class="headerlink" title="obtainFreshBeanFactory（获取Bean工厂）"></a>obtainFreshBeanFactory（获取Bean工厂）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title function_">obtainFreshBeanFactory</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">//刷新bean工厂,创建一个 DefaultListableBeanFactory类型的 bean工厂</span></span><br><span class="line">		<span class="comment">//赋值给 beanFactory 属性,对创建的这个 beanFactory 设置一个序列号</span></span><br><span class="line">        <span class="built_in">this</span>.refreshBeanFactory();</span><br><span class="line">        <span class="comment">//获取beanFactory,就上将上一步设置好序列号的的beanFactory返回回来</span></span><br><span class="line">        <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="built_in">this</span>.getBeanFactory();</span><br><span class="line">        <span class="comment">//打印日志</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.logger.debug(<span class="string">&quot;Bean factory for &quot;</span> + <span class="built_in">this</span>.getDisplayName() + <span class="string">&quot;: &quot;</span> + beanFactory);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//将创建好的 beanFactory 返回</span></span><br><span class="line">        <span class="keyword">return</span> beanFactory;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<ol>
<li>BeanFactory是负责将Bean创建、依赖注入和初始化工作</li>
<li>BeanDefinition是Bean的设计蓝图，其规定了Bean的单例多例、依赖关系和创建销毁</li>
<li>BeanDefinition所获取的Bean来源有xml、配置类、组件扫描等等</li>
</ol>
<h3 id="prepareBeanFactory（Bean工厂的准备）"><a href="#prepareBeanFactory（Bean工厂的准备）" class="headerlink" title="prepareBeanFactory（Bean工厂的准备）"></a>prepareBeanFactory（Bean工厂的准备）</h3><p>因为上一步获取Bean工厂是空的工厂，还未进行设置，那么这一步是为了上一步获取的工厂进行预处理设置，由于源码很多，以下的代码是简化的代码，整体思路是跟源码一样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">   <span class="comment">// 设置类加载器</span></span><br><span class="line">    beanFactory.setBeanClassLoader(<span class="built_in">this</span>.getClassLoader());</span><br><span class="line">   <span class="comment">// 设置语言解析器，例如解析#、&amp;等</span></span><br><span class="line">    beanFactory.setBeanExpressionResolver(<span class="keyword">new</span> <span class="title class_">StandardBeanExpressionResolver</span>(beanFactory.getBeanClassLoader()));</span><br><span class="line">    beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> <span class="title class_">ResourceEditorRegistrar</span>(<span class="built_in">this</span>, <span class="built_in">this</span>.getEnvironment()));</span><br><span class="line">   <span class="comment">// 添加Bean的后置处理器 </span></span><br><span class="line">   beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">ApplicationContextAwareProcessor</span>(<span class="built_in">this</span>));</span><br><span class="line">   <span class="comment">// 忽略自动装配的接口，就是在实现这些接口中不能自动注入</span></span><br><span class="line">    beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class="line">   <span class="comment">//注册解析依赖，可以自动解析</span></span><br><span class="line">    beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line">    beanFactory.registerResolvableDependency(ResourceLoader.class, <span class="built_in">this</span>);</span><br><span class="line">   <span class="comment">// 添加一个ApplicationListenerDetector后置处理器</span></span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">ApplicationListenerDetector</span>(<span class="built_in">this</span>));</span><br><span class="line">   <span class="comment">// 根据beanFactory中是否符合以下名称的Bean，根据是否存在进行注册或者添加</span></span><br><span class="line">    <span class="keyword">if</span> (beanFactory.containsBean(<span class="string">&quot;loadTimeWeaver&quot;</span>)) &#123;</span><br><span class="line">        beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">LoadTimeWeaverAwareProcessor</span>(beanFactory));</span><br><span class="line">        beanFactory.setTempClassLoader(<span class="keyword">new</span> <span class="title class_">ContextTypeMatchClassLoader</span>(beanFactory.getBeanClassLoader()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.containsLocalBean(<span class="string">&quot;environment&quot;</span>)) &#123;</span><br><span class="line">        beanFactory.registerSingleton(<span class="string">&quot;environment&quot;</span>, <span class="built_in">this</span>.getEnvironment());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="postProcessBeanFactory（处理后的Bean工厂）"><a href="#postProcessBeanFactory（处理后的Bean工厂）" class="headerlink" title="postProcessBeanFactory（处理后的Bean工厂）"></a>postProcessBeanFactory（处理后的Bean工厂）</h3><p>这步是空方法，留给子类进行实现的<strong>（体现了设计模式的模板方法）</strong>，是作为BeanFactory的扩展点，以上的步骤可以看成是BeanFactory的创建及预准备阶段。</p>
<h3 id="invokeBeanFactoryPostProcessors（执行BeanFactory后置处理器）"><a href="#invokeBeanFactoryPostProcessors（执行BeanFactory后置处理器）" class="headerlink" title="invokeBeanFactoryPostProcessors（执行BeanFactory后置处理器）"></a>invokeBeanFactoryPostProcessors（执行BeanFactory后置处理器）</h3><p>在原始的BeanFactory中的功能并不是很多，很多的功能都要靠此方法进行一个扩展，像@Configuration、@Bean 等注解是无法解析的，那需要调用此方法进行一个扩展，执行ConfigurationClassPostProcessor即可解析像@Configuration、@Bean、@lmport、@PropertySource的注解进行解析。</p>
<h3 id="registerBeanPostProcessors（注册bean后置处理器）"><a href="#registerBeanPostProcessors（注册bean后置处理器）" class="headerlink" title="registerBeanPostProcessors（注册bean后置处理器）"></a>registerBeanPostProcessors（注册bean后置处理器）</h3><p>registerBeanPostProcessors是往BeanFactory中注册后置处理器，例如往BeanFactory中注册一下的后置处理器可以解析对应的注解。</p>
<ul>
<li><p>AutowiredAnnotationBeanPostProcessor功能有：解析@Autowired，@Value注解</p>
</li>
<li><p>CommonAnnotationBeanPostProcessor功能有：解析@Resource，@PostConstruct，@preDestroy</p>
</li>
<li><p>AnnotationAwareAspectJAutoProxyCreator功能有：为符合切点的目标bean自动创建代理</p>
</li>
</ul>
<h2 id="Spring-Bean的生命周期"><a href="#Spring-Bean的生命周期" class="headerlink" title="Spring Bean的生命周期"></a>Spring Bean的生命周期</h2><p><strong>阶段1：处理别名，检查缓存</strong></p>
<ul>
<li>先把Bean的别名解析实际的名称</li>
<li>若要BeanFactory本身需要加&amp;符号进行获取</li>
<li>singletonObjects（一级缓存）：放单例成品对象</li>
<li>earlySingletonObjects（二级缓存）：放单例工厂的产品</li>
<li>singletonFactories（三级缓存）：放单例工厂</li>
</ul>
<p><strong>阶段2：处理父子容器</strong></p>
<ul>
<li>父子容器中的bean名称可以一样</li>
<li>优先从子容器中找找bean，找到了直接返回，找不到再继续从父容器找</li>
</ul>
<p><strong>阶段3：dependOn</strong></p>
<ul>
<li>dependOn可以控制Bean的创建次顺</li>
</ul>
<p><strong>阶段4：按照scope创建</strong></p>
<ul>
<li>singleton Scope从单例池中获取bean对象，若没有，则新创建bean对象放到单例池中</li>
<li>prototype Scope表示从不缓存bean对象，每次都创建新的bean</li>
</ul>
<p><strong>阶段5-1：创建bean（创建阶段）</strong></p>
<p>AutowiredAnnotationBeanPostProcessor选择构造</p>
<ul>
<li>优先选择带@Autowired注解的构造</li>
<li>若有唯一的带参构造，也会入选</li>
</ul>
<p>采用默认构造</p>
<ul>
<li>若上面未找到符合条件的，则会采用默认构造器，即使是私有的构造方法也会进行暴力反射进行构造</li>
</ul>
<p><strong>阶段5-2：依赖注入</strong></p>
<ul>
<li>注解匹配注入：会根据@Autowired、@Value和@Resource进行注入</li>
<li>根据bean名字和成员方法名称（就是setXxx后面的Xxx进行匹配）进行注入</li>
<li>根据bean类型进行注入</li>
</ul>
<p><strong>阶段5-3：初始化</strong></p>
<p><strong>阶段5-4：注册可销毁的bean</strong></p>
<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230129165105425.png" alt="image-20230129165105425"></p>
<p><strong>阶段6：类型转换</strong></p>
<ul>
<li>bean会根据实际类型进行转换</li>
</ul>
<p><strong>阶段7：销毁Bean</strong></p>
<h2 id="Spring事务失效场景"><a href="#Spring事务失效场景" class="headerlink" title="Spring事务失效场景"></a>Spring事务失效场景</h2><p><strong>场景一：</strong>抛出检查异常，导致事务不能回滚</p>
<ul>
<li>原因：spring的事务默认回滚非检查异常</li>
<li>解决：配置@Transactional注解的属性rollbackFor</li>
</ul>
<p><strong>场景二：</strong>在业务方法内部使用try-catch处理掉异常</p>
<ul>
<li>原因：事务通知只有捉到目标所抛出的异常，才会进行回滚，但你使用try-catch处理异常且并未抛出异常，那么事务通知无法悉知</li>
<li>解决1：当捕捉到异常时再抛出原异常。</li>
<li>解决2：在catch代码块中手动设置TransactionStatus.setRollbackOnly();</li>
</ul>
<p><strong>场景三：</strong>aop切面顺序导致事务不能正确回滚</p>
<ul>
<li>原因：事务切面优先级最低，但如果自定义的切面方法优先级高于事务切面且在此切面中有异常产生而并未抛出导致的</li>
<li>解决：同场景二的解决方一样，在自定义切面方法中将异常原样抛出</li>
</ul>
<p><strong>场景四：</strong>在加上注解@Transactional的方法不是public修饰的</p>
<ul>
<li><p>原因：spring创建事务代理、添加事务通知的前提条件方法是public</p>
</li>
<li><p>解决：将方法改为public修饰的</p>
</li>
</ul>
<p><strong>场景五：</strong>父子容器导致的事务失效</p>
<ul>
<li>原因：子容器的组件扫描范围过大，导致未加事务配置的service被扫描进来</li>
<li>解决：将所有的bean放在同一个容器中</li>
</ul>
<p><strong>场景六：</strong>调用本类的方法导致的事务失效</p>
<ul>
<li>原因：本类方法调用不经过代理，因此spring框架无法完成事务增强操作</li>
<li>解决1：通过@Autowird注入本类的代理对象，通过代理对象调用本类的方法</li>
<li>解决2：使用AopContext.currentProxy拿到本类的代理对象进行调用</li>
</ul>
<p><strong>场景七：</strong>@Transactional注解不能保证业务操作的原子性</p>
<ul>
<li>原因：事务的原子性仅涵盖insert update delete select … for update这种的SQL语句中</li>
</ul>
<p><strong>场景八：</strong>在并发情况下@Transactional会导致的Synchronized锁失效</p>
<ul>
<li>原因：若Synchronized仅能保证目标方法的原子性，加上@Transactional的方法会经过代理增强进行事务的控制，而代理方法并未在Syn范围内。</li>
<li>解决1：Synchronized锁范围应扩大到代理方法调用</li>
<li>解决2：使用insert update delete select … for update语句进行数据库CRUD操作</li>
</ul>
<h2 id="Spring-MVC的执行流程"><a href="#Spring-MVC的执行流程" class="headerlink" title="Spring MVC的执行流程"></a>Spring MVC的执行流程</h2><p><strong>初始化阶段</strong></p>
<ol>
<li>当Web容器第一次用的DispatcherServlet会创建其对象并调用init方法</li>
<li>init方法内部会创建Spring Web容器，并调用容器的refresh方法</li>
<li>refresh方法会初始化Spring Mvc的重要组件，例如：HandlerMapping、MultipartResolver、HandlerAdapter等</li>
<li>容器初始化成功后会将上一步初始化好的重要组件赋值给DispatcherServlet的成员变量，以待后用</li>
</ol>
<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230201100033499.png" alt="image-20230201100033499"></p>
<p><strong>匹配阶段</strong></p>
<ol>
<li><p>用户发送的请求统一到达前端控制器 DispatcherServlet</p>
</li>
<li><p>DispatcherServlet遍历所有HandlerMapping，找到与路径匹配的处理器</p>
</li>
<li><p>将HandlerMethod 连同匹配到的拦截器，生成调用链对象HandlerExecutionChain返回</p>
</li>
<li><p>遍历HandlerAdapter 处理器适配器，找到能处理HandlerMethod的适配器对象，开始调用</p>
</li>
</ol>
<p> <strong>执行阶段</strong></p>
<ol>
<li>执行拦截器preHandle</li>
<li>由HandlerAdapter 调用HandlerMethod</li>
<li>若没有异常，则返回ModeAndView对象，执行拦截器的preHandle方法，解析视图得到view对象，进行视图渲染</li>
<li>若有异常，进入HandlerExceptionResolve异常处理逻辑</li>
<li>最后执行拦截器afterCompletion方法</li>
<li>如果控制器方法标注了@ResponseBody，则在第二步生成json对象，不会进行视图渲染</li>
</ol>
<p><strong>整体流程如下</strong></p>
<ol>
<li>用户点击某个请求路径，发起一个 HTTP request 请求，该请求会被提交到 DispatcherServlet（前端控制器）；</li>
<li>由 DispatcherServlet 请求一个或多个 HandlerMapping（处理器映射器），并返回一个执行链（HandlerExecutionChain）。</li>
<li>DispatcherServlet 将执行链返回的 Handler 信息发送给 HandlerAdapter（处理器适配器）；</li>
<li>HandlerAdapter 根据 Handler 信息找到并执行相应的 Handler（常称为 Controller）；</li>
<li>Handler 执行完毕后会返回给 HandlerAdapter 一个 ModelAndView 对象（Spring MVC的底层对象，包括 Model 数据模型和 View 视图信息）；</li>
<li>HandlerAdapter 接收到 ModelAndView 对象后，将其返回给 DispatcherServlet ；</li>
<li>DispatcherServlet 接收到 ModelAndView 对象后，会请求 ViewResolver（视图解析器）对视图进行解析；</li>
<li>ViewResolver 根据 View 信息匹配到相应的视图结果，并返回给 DispatcherServlet；</li>
<li>DispatcherServlet 接收到具体的 View 视图后，进行视图渲染，将 Model 中的模型数据填充到 View 视图中的 request 域，生成最终的 View（视图）；</li>
<li>视图负责将结果显示到浏览器（客户端）。</li>
</ol>
<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/1139441444-0.png" alt="Spring MVC执行流程"></p>
<h2 id="SpringBoot的自动装配"><a href="#SpringBoot的自动装配" class="headerlink" title="SpringBoot的自动装配"></a>SpringBoot的自动装配</h2><p>自动装配是由核心注解是@SpringBootApplication，而@SpringBootApplication<strong>主要</strong>是由@SpringBootConfiguration、@ComponentScan、@EnableAutoConfiguration这三个注解组成的，下面就依次介绍这三个注解的作用。</p>
<p><strong>@SpringBootConfiguration：</strong>该注解内部包含@Configuration，可以作为配置类，同时也标记着SpringBoot的启动入口。</p>
<p><strong>@ComponentScan：</strong>是用于扫描子包下的或者指定包下的组件，类上有加@Component、@Service、@Mapper等注解都会被其扫描到并加载成Bean。</p>
<p><strong>@EnableAutoConfiguration：</strong>有以下两个注解组成</p>
<ul>
<li>@AutoConfigurationPackage：用来记住扫描的起始包</li>
<li>@lmport(AutoConfigurationImportSelector.class)：用来加载META-INF&#x2F;spring.factories中的自动配置类</li>
</ul>
<h2 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h2><p>概述：Bean的循环依赖有三个发生场景，分别是自己依赖注入自己的Bean实例、两个类互相依赖对方的Bean对象、三个类依赖对方的Bean对象，下图是对以上叙述的场景图</p>
<p><strong>BeanA和BeanB的相互依赖图如下</strong></p>
<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230204130449677.png" alt="image-20230204130449677"></p>
<p><strong>自己依赖自己</strong></p>
<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230204131401160.png" alt="image-20230204131401160"></p>
<p><strong>三个类依赖对方的Bean对象</strong></p>
<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230204132206960.png" alt="image-20230204132206960"></p>
<p>那么如何解决以上所展示的问题呢？在Spring中使用三级缓存来解决循环依赖的问题，以下是三级缓存的详情介绍。</p>
<p><em><strong>一级缓存的作用：限制每个Bean实例在BeanFactory中只存在一份（单例）</strong></em></p>
<p>​	下图是一级缓存的原理图：singletonObjects是一级缓存池，getBean的流程是第一次在singletonObjects池中获取目标Bean，获取不到目标Bean则表示池中还未存在该Bean，需要建立目标Bean存入singletonObjects池中，当第二次从singletonObjects池中获取时就会存在目标Bean，就直接返回即可，这样就避免了重复创建相同的Bean了。</p>
<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230204132758724.png" alt="image-20230204132758724"></p>
<p><strong>一级缓存不能解决循环依赖问题，下图可以证明这一点</strong></p>
<p>​	A和B相互依赖时，但A第一次从缓存池中获取自身Bean时，由于第一次缓存中未存在A的Bean所以需要创建A的Bean放入缓存池中，当走到a.setB(?)时，需要调用B的getBean()方法，B也是从缓存池中第一次获取自己的Bean，也获取不到需要创建B的Bean放入到缓存池中，当走到b.setA(?)时又调用了A的getBean()方法，由于创建的A还未放入到缓存池中这样就会导致一直重复以上操作，1红线的箭头和2红线箭头就是一个死循环。</p>
<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230204133755849.png" alt="image-20230204133755849"></p>
<p><em><strong>二级缓存（在Spring中是三级缓存）作用：解决两个类相互依赖问题</strong></em></p>
<p>​	三级缓存执行流程：其中singtonFactories是三级级缓存池，A先从singletonObjects池中获取目标Bean，第一次获取不到目标则需要创建A的Bean先放入到三级级缓存池（singtonFactories）中，执行到a.setB(?)时进行B的getBean操作，首先将B的Bean放入singtonFactories池中，当Bean的执行到b.setA(?)时是从三级缓存池（singtonFactories）中获取到a，然后就可以执行b的初始化和singletons.put(b)放入一级缓存池中，最后在执行A的a.setB(?)操作也是先从singtonFactories池中获取到b，将b赋值给A就可以执行a.init和singletons.put(a)的操作了。</p>
<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230204135810407.png" alt="image-20230204135810407"></p>
<p><strong>二级缓存不能解决循环依赖中有代理的情况</strong></p>
<p>​	执行流程和上面的一样，唯一不同的是b.setA(?)操作是从singtonFactories中获取的原始对象复值给B的，而我们是需要使用代理对象来进行操作的，这样就造成了两个类相互依赖其中的一方会拿不到目标代理对象。</p>
<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230204141057848.png" alt="image-20230204141057848"></p>
<p><em><strong>三级缓存（Spring中叫它二级缓存）解决循环依赖中代理创建过晚问题</strong></em></p>
<p>​	其中ealySingletonObjects是二级缓存，执行流流跟以上的流程差不多，关键的点在于singletonFactories池中是存储创建Bean的工厂对象，在工厂对象中会创建出代理对象。</p>
<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230204142740445.png" alt="image-20230204142740445"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">孤江自流</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/01/17/java%E9%9D%A2%E8%AF%95%E7%AF%87%E7%AC%94%E8%AE%B0/">http://example.com/2023/01/17/java%E9%9D%A2%E8%AF%95%E7%AF%87%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Welcome To New World</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></div><div class="post_share"><div class="social-share" data-image="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/mv.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/01/26/java%E5%AE%9E%E7%8E%B0%E4%BA%8C%E7%BB%B4%E7%A0%81/" title="java实现二维码"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">java实现二维码</div></div></a></div><div class="next-post pull-right"><a href="/2023/01/01/%E5%A4%A7%E5%9E%8B%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/" title="线上商城开发"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">线上商城开发</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/mv.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">孤江自流</div><div class="author-info__description">日常学习笔记</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">查找算法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">排序算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">2.1.</span> <span class="toc-text">冒泡排序算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">2.2.</span> <span class="toc-text">选择排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">2.3.</span> <span class="toc-text">插入排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">2.4.</span> <span class="toc-text">快速排序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#List"><span class="toc-number">3.</span> <span class="toc-text">List</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ArrayList%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="toc-number">3.1.</span> <span class="toc-text">ArrayList的扩容机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LinkedList%E5%92%8CArrayList%E7%9A%84%E6%AF%94%E5%AF%B9"><span class="toc-number">3.2.</span> <span class="toc-text">LinkedList和ArrayList的比对</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HashMap"><span class="toc-number">4.</span> <span class="toc-text">HashMap</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.</span> <span class="toc-text">单例设计模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%AF%87"><span class="toc-number">6.</span> <span class="toc-text">并发篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%AD%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="toc-number">6.1.</span> <span class="toc-text">Java线程的六种状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">6.2.</span> <span class="toc-text">线程池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Wait-VS-Sleep"><span class="toc-number">6.3.</span> <span class="toc-text">Wait VS Sleep</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lock-VS-Synchronized"><span class="toc-number">6.4.</span> <span class="toc-text">Lock VS Synchronized</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Volatile%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">6.5.</span> <span class="toc-text">Volatile关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81VS%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">6.6.</span> <span class="toc-text">乐观锁VS悲观锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashTable-VS-ConcrrentHashMap"><span class="toc-number">6.7.</span> <span class="toc-text">HashTable VS ConcrrentHashMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLocal"><span class="toc-number">6.8.</span> <span class="toc-text">ThreadLocal</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JVM%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="toc-number">7.</span> <span class="toc-text">JVM虚拟机</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E5%8F%82%E6%95%B0"><span class="toc-number">7.1.</span> <span class="toc-text">JVM中的内存参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-number">7.2.</span> <span class="toc-text">JVM中的垃圾回收算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GC%E5%92%8C%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-number">7.3.</span> <span class="toc-text">GC和分代回收算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6"><span class="toc-number">7.4.</span> <span class="toc-text">分代回收</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">7.5.</span> <span class="toc-text">垃圾回收器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="toc-number">7.6.</span> <span class="toc-text">内存溢出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">7.7.</span> <span class="toc-text">类加载的过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="toc-number">7.8.</span> <span class="toc-text">双亲委派机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%87%A0%E7%A7%8D"><span class="toc-number">7.9.</span> <span class="toc-text">对象的引用类型有几种</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLocalMap%E7%9A%84%E5%BC%B1%E5%BC%95%E7%94%A8"><span class="toc-number">7.10.</span> <span class="toc-text">ThreadLocalMap的弱引用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A1%86%E6%9E%B6%E7%AF%87"><span class="toc-number">8.</span> <span class="toc-text">框架篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Refresh%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">8.1.</span> <span class="toc-text">Refresh的工作流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#prepareRefresh"><span class="toc-number">8.1.1.</span> <span class="toc-text">prepareRefresh</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#obtainFreshBeanFactory%EF%BC%88%E8%8E%B7%E5%8F%96Bean%E5%B7%A5%E5%8E%82%EF%BC%89"><span class="toc-number">8.1.2.</span> <span class="toc-text">obtainFreshBeanFactory（获取Bean工厂）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#prepareBeanFactory%EF%BC%88Bean%E5%B7%A5%E5%8E%82%E7%9A%84%E5%87%86%E5%A4%87%EF%BC%89"><span class="toc-number">8.1.3.</span> <span class="toc-text">prepareBeanFactory（Bean工厂的准备）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#postProcessBeanFactory%EF%BC%88%E5%A4%84%E7%90%86%E5%90%8E%E7%9A%84Bean%E5%B7%A5%E5%8E%82%EF%BC%89"><span class="toc-number">8.1.4.</span> <span class="toc-text">postProcessBeanFactory（处理后的Bean工厂）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#invokeBeanFactoryPostProcessors%EF%BC%88%E6%89%A7%E8%A1%8CBeanFactory%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8%EF%BC%89"><span class="toc-number">8.1.5.</span> <span class="toc-text">invokeBeanFactoryPostProcessors（执行BeanFactory后置处理器）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#registerBeanPostProcessors%EF%BC%88%E6%B3%A8%E5%86%8Cbean%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8%EF%BC%89"><span class="toc-number">8.1.6.</span> <span class="toc-text">registerBeanPostProcessors（注册bean后置处理器）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">8.2.</span> <span class="toc-text">Spring Bean的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E5%9C%BA%E6%99%AF"><span class="toc-number">8.3.</span> <span class="toc-text">Spring事务失效场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-MVC%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">8.4.</span> <span class="toc-text">Spring MVC的执行流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringBoot%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D"><span class="toc-number">8.5.</span> <span class="toc-text">SpringBoot的自动装配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96"><span class="toc-number">8.6.</span> <span class="toc-text">循环依赖</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/02/18/mysql%E8%BF%9B%E9%98%B6%E9%83%A8%E5%88%86/" title="Mysql进阶部分">Mysql进阶部分</a><time datetime="2023-02-18T08:00:00.000Z" title="发表于 2023-02-18 16:00:00">2023-02-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/02/17/redis%E5%9F%BA%E7%A1%80%E4%B8%8E%E8%BF%9B%E9%98%B6/" title="redis基础与进阶">redis基础与进阶</a><time datetime="2023-02-17T02:16:00.000Z" title="发表于 2023-02-17 10:16:00">2023-02-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/02/15/nginx%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/" title="nginx基础详解">nginx基础详解</a><time datetime="2023-02-15T02:34:00.000Z" title="发表于 2023-02-15 10:34:00">2023-02-15</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/02/04/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="23种设计模式详解笔记">23种设计模式详解笔记</a><time datetime="2023-02-04T08:59:00.000Z" title="发表于 2023-02-04 16:59:00">2023-02-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/01/26/java%E5%AE%9E%E7%8E%B0%E4%BA%8C%E7%BB%B4%E7%A0%81/" title="java实现二维码">java实现二维码</a><time datetime="2023-01-26T12:34:00.000Z" title="发表于 2023-01-26 20:34:00">2023-01-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 孤江自流</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>