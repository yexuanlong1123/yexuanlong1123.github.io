<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>java面试篇笔记 | HelloWorld</title><meta name="author" content="CodeBoy"><meta name="copyright" content="CodeBoy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="排序算法冒泡排序算法概述：冒泡排序是比较排序，以升序为主，即给定一个无序的数组，每轮排序所有相邻的元素都会进行一个比较，若前一个数与后一个数大则进行数交换位置的操作，最后将最大的那个数排到数组最后一个位置，这就是冒泡排序，以下是冒泡排序的实现代码 12345678910111213141516171819202122232425262728293031323334353637383940impor">
<meta property="og:type" content="article">
<meta property="og:title" content="java面试篇笔记">
<meta property="og:url" content="http://example.com/2023/01/17/java%E9%9D%A2%E8%AF%95%E7%AF%87%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="HelloWorld">
<meta property="og:description" content="排序算法冒泡排序算法概述：冒泡排序是比较排序，以升序为主，即给定一个无序的数组，每轮排序所有相邻的元素都会进行一个比较，若前一个数与后一个数大则进行数交换位置的操作，最后将最大的那个数排到数组最后一个位置，这就是冒泡排序，以下是冒泡排序的实现代码 12345678910111213141516171819202122232425262728293031323334353637383940impor">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/mv.jpg">
<meta property="article:published_time" content="2023-01-17T11:20:00.000Z">
<meta property="article:modified_time" content="2023-01-28T08:11:45.264Z">
<meta property="article:author" content="CodeBoy">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/mv.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/01/17/java%E9%9D%A2%E8%AF%95%E7%AF%87%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="/LonelyBoy" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'java面试篇笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-01-28 16:11:45'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="HelloWorld" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/mv.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="HelloWorld"><span class="site-name">HelloWorld</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">java面试篇笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-01-17T11:20:00.000Z" title="发表于 2023-01-17 19:20:00">2023-01-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-28T08:11:45.264Z" title="更新于 2023-01-28 16:11:45">2023-01-28</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="java面试篇笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="冒泡排序算法"><a href="#冒泡排序算法" class="headerlink" title="冒泡排序算法"></a>冒泡排序算法</h2><p>概述：冒泡排序是比较排序，<strong>以升序为主</strong>，即给定一个无序的数组，每轮排序所有相邻的元素都会进行一个比较，若前一个数与后一个数大则进行数交换位置的操作，最后将最大的那个数排到数组最后一个位置，这就是冒泡排序，以下是冒泡排序的实现代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  冒泡排序算法的实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BubbleSort</span> &#123;</span><br><span class="line">    <span class="comment">// 记录循环的次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">24</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        bubbleSort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="comment">// 因为是每次两个数进行比较，所以总的排序次数是arr.length - 1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">           <span class="comment">// 注意arr.length - 1 - i这里的-i是将冒泡的最后有序部分剔除掉，避免重复无效的排序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="comment">// 说明两个相邻的数，左边的数比右边的大就进行交换操作</span></span><br><span class="line">                    swap(arr,j,j+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                count ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;总的循环次数为：&quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数交换</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 无序数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i 相邻两个数的左边下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j 相邻两个数的右边下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230117195938657.png" alt="image-20230117195938657"></p>
<p>在以上的冒泡排序算法中还存在一个问题，那就是若本来就有序的数组还是会重复无效的进行比较排序，这样就显得多此一举，故我们可以定义一个标志位进行一个判断，若一个数组已经是处于一个有序状态，则就可以提前结束循环，从而避免无效的排序循环。具体实现如下代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  冒泡排序算法的实现--优化version1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BubbleSort</span> &#123;</span><br><span class="line">    <span class="comment">// 记录循环的次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        bubbleSort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="comment">// 标志位</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 因为是每次两个数进行比较，所以总的排序次数是arr.length - 1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 改变标志位，说明该轮循环有进行交换操作</span></span><br><span class="line">                	  flag = <span class="literal">true</span>;</span><br><span class="line">                   <span class="comment">// 说明两个相邻的数，左边的数比右边的大就进行交换操作</span></span><br><span class="line">                    swap(arr,j,j+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                count ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!flag) &#123;</span><br><span class="line">                <span class="comment">// 在某一轮未进行比较操作，则可以说明该数组已经处于有序状态了</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;总的循环次数为：&quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数交换</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 无序数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i 相邻两个数的左边下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j 相邻两个数的右边下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>冒泡排序总结</strong></p>
<p>主要核心思想是：依次比较数组中相邻的两个元素，若前面的元素比后面的元素大，则需要进行交换，最后会将最大的数放到数组的最后位置。重复此操作最后数组就会变成有序的。时间复杂度是O(n^2)，空间复杂度是O(n)，并且是稳定排序。</p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>概述：在选择排序中数组分为有序部分和无序部分，每轮的排序都会将无序部分中最小的值排到有序部分上，例如，数组[8,2,1,4,5]，会先假定第一个值8为最小值，然后跟8后面的部分（无序部分）进行比较，若发现有比8还小的值（无序部分中最小的值），则将最小的值和8的位置进行交换，第二轮会假定2为最小值，以此类推，最终都会变得有序，以下是具体代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  选择排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">8</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        selectionSort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selectionSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 先假定数组的第一个为最小的值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="comment">// 在遍历寻找minIndex后边的值，是否存在比当前的值还小，若存在，则需要进行交换</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> minIndex + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[minIndex] &gt; arr[j]) &#123;</span><br><span class="line">                    minIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(minIndex != i) &#123;</span><br><span class="line">                <span class="comment">//说明在minIndex后边存在比当前的值还小，进行交换</span></span><br><span class="line">                swap(arr,minIndex,i);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Arrays.toString(arr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 数据元素交换，将i所在位置和j所在位置进行交换</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230117220509754.png" alt="image-20230117220509754"></p>
<p><strong>选择排序的总结</strong></p>
<p>选择排序的时间复杂度是O(n^2)，空间复杂度O(n)，是属于不稳定排序算法。</p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>概述：插入排序也分为有序部分和无序部分，有序部分会不断扩大，最终都将变成有序的数组，具体代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsertSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">9</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">        insertSort(arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 插入排序的实现方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="comment">// 首先从无序部分开始遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i]; <span class="comment">// 先暂时保存无序部分的第一个值，为后续的插入做准备</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - <span class="number">1</span>; <span class="comment">//有序部分的最后一个元素的索引</span></span><br><span class="line">            <span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; j--) &#123; <span class="comment">// temp依次比较有序部分的值，找到自己的合适位置</span></span><br><span class="line">                <span class="keyword">if</span>(temp &lt; arr[j]) &#123;</span><br><span class="line">                    <span class="comment">// 说明temp的值与当前的值小，当前的值需要往后移一位</span></span><br><span class="line">                    arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 说明temp值已经找到了合适的位置，结束循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前面的循环出来后，j + 1所在的索引就是temp值所在的位置</span></span><br><span class="line">            arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            System.out.println(Arrays.toString(arr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>插入排序的总结</strong></p>
<p>插入排序分为有序区域和无序区域，每轮排序都会从无序区域的第一个元素插入到有序区域的合适位置上（在有序部分碰到比temp值小的就可以确定temp的值所插入的位置），需要保证有序区域的有序性，重复以上步骤最终可以得到整体有序的数组。时间复杂度为O(n^2)，是稳定排序。<strong>执行的效率：插入排序 &gt; 选择排序 &gt; 冒泡排序</strong></p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>概述：快速排序是需要选择一个基准点pivot，然后进行每轮的排序，基准点的左边的值都比基准点本身的值小，右边的值都比基准点本身的值大，每次都会进行一个分区比较，每个区中都有一个基准点，最终分区的元素为0时，说明数组已经是基于有序了。这里体现的是分而治之的思想。以下代码是快速排序的实现过程（两种方式）</p>
<ul>
<li>单边循环快排</li>
</ul>
<p>在单边循环中一般选择数组最右边的元素作为基准点，这里实现的代码有两个指针<strong>i和j</strong>，<strong>i</strong>代表的是维护比基准点值小的左边界和每次交换的目标索引，<strong>j</strong>代表的是寻找比基准点还小的值与<strong>i</strong>所在的位置进行交换，最后<strong>i</strong>会和基准点进行交换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  快速排序--单边</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">5</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        quickSort(arr,<span class="number">0</span>,arr.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> left,<span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right) &#123;</span><br><span class="line">            <span class="comment">// 没有元素可以再进行分区，结束递归分区</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1. 进行一个分区并返回分区后基准点所在的索引位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivotIndex</span> <span class="operator">=</span> portion(arr, left, right);</span><br><span class="line">        <span class="comment">// 2. 根据基准点所在的位置对基准点左边在进行分区</span></span><br><span class="line">        quickSort(arr, left, pivotIndex - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 3. 根据基准点所在的位置对基准点右边进行分区</span></span><br><span class="line">        quickSort(arr, pivotIndex + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 待排序的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left 数组左边的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right 数组右边的所有</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 经过分区后i指针所在的位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">portion</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="comment">// 最右边的元素作为基准点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[right];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="comment">// j指针寻找比pivot小的值所在的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> left; j &lt; right; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &lt; pivot) &#123;</span><br><span class="line">                <span class="comment">// 说明找到了，就与i进行交换</span></span><br><span class="line">                swap(arr,i,j);</span><br><span class="line">                i ++; <span class="comment">// i需要右移一位</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后将i与基准点所在位置进行交换</span></span><br><span class="line">        swap(arr,i,right);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数交换</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 无序数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i 相邻两个数的左边下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j 相邻两个数的右边下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230118150315998.png" alt="image-20230118150315998"></p>
<ul>
<li>双边循环快排</li>
</ul>
<p>概述：双边循环也称为双指针循环，一般数组的最左边元素是作为基准点，在双指针中假设是i和j，i的职责是从左往右寻找比级基准点大的元素，j的职责是从右往左寻找比基准点小的元素，若ij分别找到各自的元素则进行交换，最后i和j相交时则结束寻找，此时的i就是分区的位置，最后i和基准点需要进行一次交换。</p>
<p><strong>细节问题</strong>：在i和j指针寻找的顺序，必须先寻找小的值，然后再寻找大的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  快速排序--双边循环</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">5</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">        quickSort(arr,<span class="number">0</span>,arr.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> left,<span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right) &#123;</span><br><span class="line">            <span class="comment">// 没有元素可以再进行分区，结束递归分区</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1. 进行一个分区并返回分区后基准点所在的索引位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivotIndex</span> <span class="operator">=</span> portion(arr, left, right);</span><br><span class="line">        <span class="comment">// 2. 根据基准点所在的位置对基准点左边在进行分区</span></span><br><span class="line">        quickSort(arr, left, pivotIndex - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 3. 根据基准点所在的位置对基准点右边进行分区</span></span><br><span class="line">        quickSort(arr, pivotIndex + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">portion</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> left,<span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="comment">// 选择最左边的作为基准点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[left];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; <span class="comment">// 负责找比基准点大的元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> right;<span class="comment">// 负责找比基准点小的元素</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">           <span class="comment">// 先找小的值</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt; pivot) &#123;</span><br><span class="line">                j --;</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="comment">// 再找大的值</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt;= pivot ) &#123;</span><br><span class="line">                i ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// i 和 j 进行交换</span></span><br><span class="line">            swap(arr,i,j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后i和基准点进行交换</span></span><br><span class="line">        swap(arr,i,left);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数交换</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 无序数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i 相邻两个数的左边下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j 相邻两个数的右边下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>快速排序的总结</strong></p>
<p>平均时间复杂度O(nlog2n)，最坏的时间复杂度O(n^2)，对于数据量比较大时使用该算法会有比较明显的优势，是不稳定排序</p>
<h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><h2 id="ArrayList的扩容机制"><a href="#ArrayList的扩容机制" class="headerlink" title="ArrayList的扩容机制"></a>ArrayList的扩容机制</h2><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230118160852310.png" alt="image-20230118160852310"></p>
<h2 id="LinkedList和ArrayList的比对"><a href="#LinkedList和ArrayList的比对" class="headerlink" title="LinkedList和ArrayList的比对"></a>LinkedList和ArrayList的比对</h2><p><strong>LinkedList</strong></p>
<ul>
<li>LinkedList底层是双向链表实现，无需连续内存空间，随机访问慢，头尾插入和删除操作的效率高（因为链表的插入和删除操作不用移动元素），但在插入和删除中间的元素时性能较低（若只考虑插入和删除的操作，则效率高，若考虑定位查找到目标数据或目标位置然后再进行增删操作，则总体的效率低），占用内存大。</li>
</ul>
<p><strong>ArrayList</strong></p>
<ul>
<li>ArrayList底层是基于数组实现的，需要连续的内存空间来存储数据，可以通过计算来确定数组的下标，从而确定需要访问的目标数据，故随机访问速度快。在一定长度的数组头部和中间数据进行增删操作效率比LinkedList低，但在尾部进行插入和删除的效率比LinkedList高。可以利用CPU缓存和局部性原理（CPU每次读取数据进行计算时都会读取目标数据的相邻元素一起读到缓存中）。占用内存小</li>
</ul>
<h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><p>HashMap的底层数据结构JDK1.7和JDK1.8版本有什么区别？</p>
<ul>
<li><strong>在JDK1.7版本中HashMap是采用数组+链表，在JDK1.8是数组 +（链表 | 红黑树）</strong></li>
</ul>
<p>如何解决HashMap底层的链表过长问题？</p>
<ul>
<li><strong>通过给HashMap的数组扩容，但在某个特殊的情况下并不能有效的解决。</strong></li>
<li><strong>通过树化链表可以有效解决，前提条件是在HashMap的数组长度达到（&gt;&#x3D;64）才能触发树化效果并且在某个数组下的节点大到8个节点</strong></li>
</ul>
<p>为何需要使用红黑树？为什么不是一上来就树化？</p>
<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230119150749106.png" alt="image-20230119150749106"></p>
<p>HashMap的索引计算？</p>
<ul>
<li><strong>通过调用hash的方法来计算对象的HashCode，然后再模于数组的长度 - 1，&gt;&gt; 公式：hash值 mod 数组长度 - 1</strong></li>
</ul>
<p>为何需要进行二次的hashCode的计算？</p>
<ul>
<li><strong>二次hashCode的计算是为了综合高位数据，使得哈希分布更为均匀。</strong></li>
</ul>
<p>数组容量为何是2的n次幂？</p>
<ul>
<li><strong>因为2的n次幂可以通过位与运算得到取模运算同样的结果，并且位与运算效率更高，扩容时若 hash &amp; 旧容量长度 &#x3D;&#x3D; 0，则元素的位置不变，否则新位置&#x3D;旧位置+旧容量的长度。</strong></li>
</ul>
<p>HashMap_put()的流程？</p>
<ul>
<li><strong>HashMap是懒惰创建数组的，首次使用才创建数组计算索引（桶下标)</strong></li>
<li><strong>如果桶下标还没人占用，创建Node占位返回</strong></li>
<li><strong>如果桶下标已经有人占用</strong><ul>
<li><strong>已经是TreeNode走红黑树的添加或更新逻辑</strong></li>
<li><strong>是普通Node，走链表的添加或更新逻辑，如果链表长度超过树化阈值，走树化逻辑</strong></li>
</ul>
</li>
<li><strong>返回前检查容量是否超过阈值，一旦超过进行扩容不同</strong></li>
</ul>
<p>HashMap_put()在JDK1.7和JDK1.8的不同？</p>
<ol>
<li><strong>链表插入节点时，1.7是头插法，1.8是尾插法。</strong></li>
<li><strong>1.7是大于阈值（数组长度 * 负载因子(0.75)）且没有空位才进行扩容，1.8是大于阈值就进行扩容。</strong></li>
<li><strong>1.8比1.7的效率更高。</strong></li>
</ol>
<p>加载（负载）因子为何是0.75？</p>
<ul>
<li><strong>在空间占用与查询时间之间取得较好的权衡</strong></li>
<li><strong>大于这个值，空间节省了，但链表就会比较长影响性能</strong></li>
<li><strong>小于这个值，冲突减少了，但扩容就会更频繁，空间占用多</strong></li>
</ul>
<p>多线程下HashMap会出现什么问题（在JDK1.7版本下发生）？</p>
<ol>
<li><p><strong>并发丢失数据。</strong></p>
</li>
<li><p><strong>由于头插法导致并发下扩容死链问题。</strong></p>
</li>
</ol>
<p>HashMap中的key是否可以为null，作为key的对象有和要求？</p>
<ol>
<li><strong>HashMap中的key是可以为null的，但在其它的map集合中是不可以为null的，例如HashTable。</strong></li>
<li><strong>作为key的对象，必须实现hashCode和equals的方法，并且key对象是不可修改的。</strong></li>
</ol>
<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230119203801278.png" alt="image-20230119203801278"></p>
<h1 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h1><p>以下是单例模式的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> a_based_item1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  饿汉式单例--在该类初始化的时候就创建实例对象，线程是安全的。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 预防反射破坏单例</span></span><br><span class="line">        <span class="keyword">if</span>(INSTANCE != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;单例不可重复创建&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Singleton单例模式初始化。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">otherMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;otherMethod其它方法执行。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>单例被破坏的三最种情况</strong></p>
<ol>
<li>反射破坏单例，这是可以预防的，如上代码。</li>
<li>反序列化破坏单例（可解决）</li>
<li>unsafe破坏单例（不可解决）</li>
</ol>
<p>以下是懒汉式单例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  懒汉式单例--类在加载时不实例化对象，只有等到第一次用的时候才去实例化。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;懒汉式单例初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton2</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 创建实例</span></span><br><span class="line">            INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton2</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在多线程序会破坏单例的证明如下测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  多线程下破坏懒汉式单例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonTest2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建10个线程</span></span><br><span class="line">        creatThreadByNum(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">creatThreadByNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="type">Singleton2</span> <span class="variable">instance</span> <span class="operator">=</span> Singleton2.getInstance();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;&gt;&gt;&quot;</span> + instance);</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.setName(<span class="string">&quot;线程&quot;</span> + (i + <span class="number">1</span>));</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230120144155537.png" alt="image-20230120144155537"></p>
<p><strong>以下代码是解决多线程下破坏懒汉式单例的方案DCL（Double Check Lock）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  懒汉式单例--DCL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;懒汉式单例初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 需要加volatile，可以解决共享变量的可见性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">Singleton2</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 加锁，防止多线程同时满足条件，同时进行创建实例的代码块</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton2.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton2</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230120144624401.png" alt="image-20230120144624401"></p>
<h1 id="并发篇"><a href="#并发篇" class="headerlink" title="并发篇"></a>并发篇</h1><h2 id="Java线程的六种状态"><a href="#Java线程的六种状态" class="headerlink" title="Java线程的六种状态"></a>Java线程的六种状态</h2><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230120150100666.png" alt="image-20230120150100666"></p>
<p><strong>下图是操作系统中的线程状态</strong></p>
<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230121140706806.png" alt="image-20230121140706806"></p>
<h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p><strong>java.util.concurrent.ThreadPoolExecutor</strong></p>
<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230121142617613.png" alt="image-20230121142617613"></p>
<h2 id="Wait-VS-Sleep"><a href="#Wait-VS-Sleep" class="headerlink" title="Wait VS Sleep"></a>Wait VS Sleep</h2><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230121150713734.png" alt="image-20230121150713734"></p>
<h2 id="Lock-VS-Synchronized"><a href="#Lock-VS-Synchronized" class="headerlink" title="Lock VS Synchronized"></a>Lock VS Synchronized</h2><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230121152148928.png" alt="image-20230121152148928"></p>
<p><strong>公平锁与非公平锁的区别？</strong></p>
<ul>
<li>公平锁是在阻塞队列中的线程分别以先进先出的形式依次执行线程</li>
<li>非公平锁不是以先进先出的形式出现，有可能出现其他线程插队的情况。</li>
</ul>
<h2 id="Volatile关键字"><a href="#Volatile关键字" class="headerlink" title="Volatile关键字"></a>Volatile关键字</h2><p><strong>线程安全包括三个方面：可见性、有序性、原子性</strong></p>
<ul>
<li>可见性：是一个线程对某个变量进行修改，其它线程是能看到最新的结果</li>
<li>有序性：一个线程中的代码是按照编码顺序执行的</li>
<li>原子性：一个线程中的代码是以一个整体运行的，在运行期间不可以有其它线程代码插队</li>
</ul>
<p><strong>Volatile关键字可以保证可见性和有序性，不能保证原子性</strong></p>
<h2 id="乐观锁VS悲观锁"><a href="#乐观锁VS悲观锁" class="headerlink" title="乐观锁VS悲观锁"></a>乐观锁VS悲观锁</h2><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230124144738446.png" alt="image-20230124144738446"></p>
<h2 id="HashTable-VS-ConcrrentHashMap"><a href="#HashTable-VS-ConcrrentHashMap" class="headerlink" title="HashTable VS ConcrrentHashMap"></a>HashTable VS ConcrrentHashMap</h2><ol>
<li>HashTable和ConcrrentHashMap都是线程安全的（相同点）。</li>
<li>HashTable由于底层是用同一把锁，则每次只能有一个线程操作，则并发度较低。</li>
<li>ConcrrentHashMap在JDK1.8版本之前采用segment+数组+链表，每个segment对应一把锁，多个线程访问时都会获取不同的锁，则不会冲突。</li>
<li>在JDK1.8之后ConcrrentHashMap采用头节点作为锁，若多个线程访问不同的头节点，则不会冲突。</li>
</ol>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><ol>
<li>ThreadLocal是可以实现【资源对象】的线程隔离，让每个线程都用自己的【资源对象】，从而避免线程安全的问题。</li>
<li>ThreadLocal可以实现同个线程间资源共享。</li>
</ol>
<p>以下代码是证明以上ThreadLocal的特点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> Integer age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  ThreadLocal证明测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalTest</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  ThreadLocal是底层是基于map实现的，是key-value结构</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;User&gt; tl = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        testOne();</span><br><span class="line">        testTwo(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  测试一：【同个线程间】在从ThreadLocal获取资源对象是否相同？</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testOne</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            tl.set(<span class="keyword">new</span> <span class="title class_">User</span>());</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：&quot;</span> + tl.get());</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：&quot;</span> + tl.get());</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：&quot;</span> + tl.get());</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  测试二：【不同线程间】从ThreadLocal获取资源对象是否相同？</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testTwo</span><span class="params">(<span class="type">int</span> threadNum)</span> &#123;</span><br><span class="line">        <span class="comment">// 根据threadNum创建线程数量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadNum; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                tl.set(<span class="keyword">new</span> <span class="title class_">User</span>());</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：&quot;</span> + tl.get());</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230126135721217.png" alt="image-20230126135721217"></p>
<p><strong>ThreadLocal的原理</strong></p>
<p>ThreadLocal类中存在成员变量ThreadLocalMap，ThreadLocalMap本质上还是key-value结构，用于存储资源对象</p>
<ul>
<li>当调用set方法是需要存储两个值的，ThreadLocal本身是作为key，资源对象是作为value存储的。</li>
<li>当调用get方法是根据ThreadLocal本身去寻找value值。</li>
<li>调用remove方法，是以ThreadLocal本身作为key去移除相关的资源值。</li>
</ul>
<p><strong>为什么ThreadLocalMap的key（即ThreadLocal）是弱引用？</strong></p>
<ol>
<li>因为ThreadLocal可能会长时间存在线程中，若key不需要再使用，则会在内存不足时将该key释掉。</li>
<li>第一步只是让key释放掉，但其value未被释放，还需要进一步的根据key是否为null来释放值的内存，释放的时机有如下<ol>
<li>获取key时发现为null</li>
<li>set key时，会使用启发式扫描，清除临近的null key，启发次数与元素个数，是否发现 null key有关</li>
<li>remove时(推荐)，因为一般使用ThreadLocal时都把它作为静态变量，因此GC（jvm的垃圾回收机制）无法回收</li>
</ol>
</li>
</ol>
<h1 id="JVM虚拟机"><a href="#JVM虚拟机" class="headerlink" title="JVM虚拟机"></a>JVM虚拟机</h1><ul>
<li>程序私有：程序计数器（记录CPU已经执行到哪行代码）、虚拟机栈</li>
<li>程序共有：堆、方法区</li>
</ul>
<p><em><strong>下图是JVM虚拟机执行java程序代码的整体概况</strong></em></p>
<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230126142916151.png" alt="image-20230126142916151"></p>
<p>不会出现内存溢出的区域：程序计数器</p>
<p><strong>出现OutOfMemoryError（OOM）的情况</strong></p>
<ul>
<li>堆内存耗尽：对象越来越多且一直在使用，无法被垃圾回收</li>
<li>方法区内存耗尽：加载的类越来越多，很多框架在启动时会动态的加载所需要的类</li>
<li>虚拟机栈积累：每个线程最多占用1M的内存，线程个数越来越多，而又长时间不销毁</li>
</ul>
<p><strong>出现OutOverflowError的情况</strong></p>
<ul>
<li>虚拟机栈内部：方法调用次数过多</li>
</ul>
<h2 id="JVM中的内存参数"><a href="#JVM中的内存参数" class="headerlink" title="JVM中的内存参数"></a>JVM中的内存参数</h2><p>对于JVM内存参数有：-Xmx10240m、-Xms10240m、-Xmn5120m、-XX:SurvivoRatio&#x3D;3、其最小内存值和Survivo区总大小分别是？</p>
<ul>
<li>-Xmx10240m是代表最大内存10G，-Xms10240m是代表最小内存10G</li>
<li>-Xmn5120m代表新生代的内存是5G，那么老年代是占用5G</li>
<li>-XX:SurvivoRatio&#x3D;3代表在新生代内存的比例</li>
</ul>
<h2 id="JVM中的垃圾回收算法"><a href="#JVM中的垃圾回收算法" class="headerlink" title="JVM中的垃圾回收算法"></a>JVM中的垃圾回收算法</h2><p><strong>标记清理、标记整理、标记复制这三种垃圾回收算法</strong></p>
<p>下图是标记清理，清理未标记的类对象，该垃圾回收算法是有缺点的，在白色区域是代表已清理的类对象所遗留下的内存空间，有些内存空间被可用的类对象所隔离开来，就产生了内存碎片。</p>
<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230126201031183.png" alt="image-20230126201031183"></p>
<p><strong>标记整理</strong>是为了解决标记清理算法缺点，每次清理完成后都会对可用的类对象进行一个整理，这样就避免了产生内存碎片，但多了一步整理的操作，故效率就会降低。</p>
<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230126201517144.png" alt="image-20230126201517144"></p>
<p><strong>标记复制</strong>是需要两个存储空间A和B，假如A需要进行对象清理操作，就可以把在A区域标记的对象复制到B的空闲区域中，然后将A区域的所有空间都清理掉即可，缺点是需要额外的空间。</p>
<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230126201758602.png" alt="image-20230126201758602"></p>
<h2 id="GC和分代回收算法"><a href="#GC和分代回收算法" class="headerlink" title="GC和分代回收算法"></a>GC和分代回收算法</h2><p>GC存在的目标是无用对象自动释放、减少内存碎片、加快分配速度。以下是GC的要点</p>
<ol>
<li>回收区域是堆内存，不包括虚拟机栈，在方法调用结束会自动释放方法</li>
<li>占用内存判断无用对象，使用<strong>可达性分析算法</strong>，<strong>三色标记法</strong>标记存活对象，回收未标记对象</li>
<li>GC具体的实现称为<strong>垃圾回收器</strong></li>
<li>GC大都采用了分代回收思想，理论依据是大部分对象朝生夕灭，用完立刻就可以回收，另有少部分对象会长时间存活，每次很难回收，根据这两类对象的特性将回收区域分为新生代和老年代，不同区域应用不同的回收策略</li>
<li>根据GC的规模可以分成 Minor GC，Mixed GC,Full Gc</li>
</ol>
<h2 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h2><p><strong>伊甸园(eden)：</strong>最初的对象分配在此区域，与幸存区合成称为新生代。</p>
<p><strong>幸存区(survivor)：</strong>当伊甸园的内存不足时，触发垃圾回收后的幸存对象分配到此区域，分为from和to区域，采用标记复制法</p>
<p><strong>老年代(old)：</strong>但幸存区对象熬过几次的垃圾回收（最多15次）后就会晋升为老年代</p>
<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230127135449616.png" alt="image-20230127135449616"></p>
<p><strong>GC的规模</strong></p>
<p>​	Minor GC发生在新生代的垃圾回收，暂停时间短</p>
<p>​	Mixed GC新生代＋老年代部分区域的垃圾回收，G1收集器特有</p>
<p>​	Full GC新生代＋老年代完整垃圾回收，暂停时间长，应尽力避免</p>
<p><strong>三色标记</strong></p>
<ol>
<li>黑色：已标记</li>
<li>灰色：标记中</li>
<li>白色：还未标记</li>
</ol>
<h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><p>介绍三种垃圾回收器的特点？</p>
<p><strong>Parallel GC(并行垃圾回收器)</strong></p>
<ol>
<li>eden内存不足发生Minor GC，标记复制STW</li>
<li>old内存不足发生Full GC，标记整理STW</li>
<li>注重吞吐量</li>
</ol>
<p><strong>ConcurrentMarkSweep GC(并发垃圾回收器)</strong></p>
<ol>
<li>old并发标记，重新标记时需要STW，并发清除</li>
<li>Failback Full GC（当总内存不足时会触发回退机制）</li>
<li>注重响应时间</li>
</ol>
<p><strong>G1 GC</strong></p>
<ol>
<li>响应时间与吞吐量兼顾</li>
<li>划分成多个区域，每个区域都可以充当eden,survivor, old,humongous</li>
<li>新生代回收：eden内存不足，标记复制STW(Stop The Word 是GC事件发生过程中，会产生应用程序的停顿)</li>
<li>并发标记：old并发标记，重新标记时需要STW</li>
<li>混合收集：并发标记完成，开始混合收集，参与复制的有eden、survivor、old，其中old会根据暂停时间目标，选择部分回收价值高的区域，复制时STW</li>
<li>Failback ull GC(回退)</li>
</ol>
<h2 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h2><p>概述：大部分的内存溢出是出现在误用了错误的线程池而出现的OutOfMemoryError保错，那么以下是误用线程池的例子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  内存溢出测试</span></span><br><span class="line"><span class="comment"> *  -Xmx64m</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OutOfMemoryTest</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个线程池，初始化线程数2</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        generousCreateThread();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  测试线程数创建过多而导致的内存溢出问题</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">generousCreateThread</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 死循环</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            threadPool.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">30</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">                count ++;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230127145448373.png" alt="image-20230127145448373"></p>
<p><strong>线程创建过多：</strong>造成以上错误的原因是使用了 Executors.newFixedThreadPool()创建线程池，而这种方式创建最大的线程数是Integer.MAX_VALUE的最大值，但线程数超过了最大值必然会出现内存溢出的错误，那么如何解决这种错误呢？根据alibaba的开发手册，在开发中尽量不使用Executors.newFixedThreadPool()创建线程池，一般使用ThreadPoolExecutor创建，自己定义线程池的配置参数。在此文章的并发篇有说到ThreadPoolExecutor创建线程池的配置参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  使用ThreadPoolExecutor创建线程池，看是否会出现内存溢出错误？</span></span><br><span class="line"><span class="comment"> *  -Xmx64m</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OutOfMemoryTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化容量为5的堵塞队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ArrayBlockingQueue&lt;Runnable&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">2</span>,<span class="number">4</span>,<span class="number">0</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">            queue);</span><br><span class="line">    <span class="comment">// 记录线程的名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; records = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        generousCreateThread();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  测试线程数创建过多而导致的内存溢出问题</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">generousCreateThread</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 死循环</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                threadPool.submit(() -&gt; &#123;</span><br><span class="line">                    records.add(Thread.currentThread().getName());</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String name: records) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程名称：&quot;</span> + name);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;提交线程任务的次数：&quot;</span> +  records.size() );</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230127151428616.png" alt="image-20230127151428616"></p>
<p><strong>每次从数据库查询的数据量过多也会导致内存溢出问题，所以说在查询数据库时需要加上limit条件，避免数据查询过多</strong></p>
<p><strong>加载的类太多也会导致内存溢出，溢出的是元空间的区域</strong></p>
<h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><p><strong>加载阶段</strong></p>
<ol>
<li>将类的字节码载入方法区，并创建类.class对象</li>
<li>如果此类否父类还未加载，则先加载父类</li>
<li>加载是懒惰执行方式（真正用到此类才进行初始化）</li>
</ol>
<p><strong>链接阶段</strong></p>
<ol>
<li>验证：验证加载的Class对象是否规范、合法性和安全检查</li>
<li>准备：为static变量分配空间和设置默认值</li>
<li>解析：将常量池的符号引用解析为直接引用</li>
</ol>
<p><strong>初始化</strong></p>
<ol>
<li>执行静态代码块和非final的变量赋值</li>
<li>初始化为懒惰执行</li>
</ol>
<h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><p>双亲委派：类加载是优先委派上级类加载器加载，存在以下两种情况</p>
<ul>
<li>若在上级加载器中能找到目标类，则由上级类加载器加载，加载的类对下级类加载器可见。</li>
<li>若上级加载器未找到目标类，则下级加载器才有资格执行加载。</li>
</ul>
<h2 id="对象的引用类型有几种"><a href="#对象的引用类型有几种" class="headerlink" title="对象的引用类型有几种"></a>对象的引用类型有几种</h2><p><strong>强引用</strong></p>
<ol>
<li><p>普通变量赋值即为强引用，例如：A a &#x3D; new A();</p>
</li>
<li><p>通过GC root 引用链的强引用用不到该对象，则会被垃圾回收，若该对象还再被使用，则不能被回收</p>
</li>
</ol>
<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230128142606197.png" alt="image-20230128142606197"></p>
<p><strong>软引用</strong></p>
<ol>
<li>例如：SoftReference s &#x3D; new SoftReference (new A());</li>
<li>如果仅有软引用该对象时，首次垃圾回收不会回收该对象，当内存不足时垃圾回收会将该对象回收</li>
<li>在垃圾回收时需要配合引用队列来释放</li>
<li>典型例子是反射数据</li>
</ol>
<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230128142908493.png" alt="image-20230128142908493"></p>
<p><strong>弱引用</strong></p>
<ol>
<li>例如：WeakReference w &#x3D; new WeakReference (new A());</li>
<li>只要发生垃圾回收，就会将弱引用的对象回收</li>
<li>在垃圾回收时需要配合引用队列来释放</li>
<li>典型例子是ThreadLocalMap中的Entry对象</li>
</ol>
<p><strong>虚引用</strong></p>
<ol>
<li><p>例如：PhantomReference p &#x3D;  new PhantomReference (new A());</p>
</li>
<li><p>必须配合引用队列一起使用，当虚引用引用的对象被回收时，会将虚引用对象入队，由Reference Handler线程释放其关联的外部资源</p>
</li>
</ol>
<h2 id="ThreadLocalMap的弱引用"><a href="#ThreadLocalMap的弱引用" class="headerlink" title="ThreadLocalMap的弱引用"></a>ThreadLocalMap的弱引用</h2><p>在文章的并发篇有写到ThreadLocal的特点，在日常开发中也经常用到ThreadLocal来存储用户的信息并且保证了每个线程中都有自己所属的用户信息，保证了线程安全，但ThreadLocal的ThreadLocalMap中的Entry是弱引用，一旦发生垃圾回收就会将其的key给回收掉，而值value并未被回收，这样就造成了内存泄露，以前是主动调用ThreadLocal类提供的remove方法删除掉value数据来解决，那么以下例子是从另一种方法解决的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  ThreadLocalMap，使用引用队列解决内存泄露问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalMapTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">MyWeakReference</span> <span class="variable">wr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyWeakReference</span>();</span><br><span class="line">        <span class="comment">// 存键值new String是引用</span></span><br><span class="line">        wr.put(<span class="number">0</span>,<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>),<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="comment">// 第二个的数据是强引用</span></span><br><span class="line">        wr.put(<span class="number">1</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        wr.put(<span class="number">2</span>,<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;c&quot;</span>),<span class="string">&quot;hi~~&quot;</span>);</span><br><span class="line">        wr.put(<span class="number">3</span>,<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;d&quot;</span>),<span class="string">&quot;hehehe&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;还未进行垃圾回收的结果：&quot;</span> + wr);</span><br><span class="line">        <span class="comment">// 启用垃圾回收机制</span></span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;垃圾回收后的结果：&quot;</span> + wr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用clean方法将值处理掉</span></span><br><span class="line">        wr.clean();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;清除key为null数据后的结果：&quot;</span> + wr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyWeakReference</span> &#123;</span><br><span class="line">        <span class="comment">// 创建引用队列，当若引用被回收是，会放到引用队列中</span></span><br><span class="line">        <span class="keyword">static</span> ReferenceQueue&lt;Object&gt; queue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 创建一个Entry继承弱引用</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;String&gt; &#123;</span><br><span class="line">            String value;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="title function_">Entry</span><span class="params">(String key,String value)</span> &#123;</span><br><span class="line">               <span class="built_in">super</span>(key,queue);</span><br><span class="line">               <span class="built_in">this</span>.value = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 定义一个数组长度为4</span></span><br><span class="line">        Entry[] table = <span class="keyword">new</span> <span class="title class_">Entry</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  该方法的作用是在垃圾回收时，将回收的key对应的value清除掉</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clean</span><span class="params">()</span> &#123;</span><br><span class="line">            Object temp;</span><br><span class="line">            <span class="keyword">while</span> ((temp = queue.poll()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 说明有弱引用的对象被回收，则从该队列中取出对象置为null即可</span></span><br><span class="line">               <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; table.length; i++) &#123;</span><br><span class="line">                   <span class="keyword">if</span>(table[i] == temp) &#123;</span><br><span class="line">                       <span class="comment">// 说明两个是同个对象，且key已经被回收了</span></span><br><span class="line">                       table[i] = <span class="literal">null</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 编写存入数据的方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> index,String key,String value)</span> &#123;</span><br><span class="line">            table[index] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key,value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Entry entry : table) &#123;</span><br><span class="line">                <span class="keyword">if</span> (entry != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">k</span> <span class="operator">=</span> entry.get();</span><br><span class="line">                    <span class="keyword">if</span> (k != <span class="literal">null</span> &amp;&amp; k.equals(key)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> entry.value;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            str.append(<span class="string">&quot;[  &quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (Entry e: table) &#123;</span><br><span class="line">                <span class="keyword">if</span>(e != <span class="literal">null</span>) &#123;</span><br><span class="line">                    str.append(<span class="string">&quot;key:&quot;</span>).append(e.get()).append(<span class="string">&quot; value:&quot;</span>).append(e.value).append(<span class="string">&quot; | &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            str.deleteCharAt(str.lastIndexOf(<span class="string">&quot;|&quot;</span>));</span><br><span class="line">            str.append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> str.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230128160434391.png" alt="image-20230128160434391"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">CodeBoy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/01/17/java%E9%9D%A2%E8%AF%95%E7%AF%87%E7%AC%94%E8%AE%B0/">http://example.com/2023/01/17/java%E9%9D%A2%E8%AF%95%E7%AF%87%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">HelloWorld</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></div><div class="post_share"><div class="social-share" data-image="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/mv.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/01/26/java%E5%AE%9E%E7%8E%B0%E4%BA%8C%E7%BB%B4%E7%A0%81/" title="java实现二维码"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">java实现二维码</div></div></a></div><div class="next-post pull-right"><a href="/2023/01/01/%E5%A4%A7%E5%9E%8B%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/" title="gulimall-deveploy"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">gulimall-deveploy</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/mv.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">CodeBoy</div><div class="author-info__description">日常学习笔记</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">排序算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">1.1.</span> <span class="toc-text">冒泡排序算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">1.2.</span> <span class="toc-text">选择排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">1.3.</span> <span class="toc-text">插入排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">1.4.</span> <span class="toc-text">快速排序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#List"><span class="toc-number">2.</span> <span class="toc-text">List</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ArrayList%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="toc-number">2.1.</span> <span class="toc-text">ArrayList的扩容机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LinkedList%E5%92%8CArrayList%E7%9A%84%E6%AF%94%E5%AF%B9"><span class="toc-number">2.2.</span> <span class="toc-text">LinkedList和ArrayList的比对</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HashMap"><span class="toc-number">3.</span> <span class="toc-text">HashMap</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.</span> <span class="toc-text">单例设计模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%AF%87"><span class="toc-number">5.</span> <span class="toc-text">并发篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%AD%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="toc-number">5.1.</span> <span class="toc-text">Java线程的六种状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">5.2.</span> <span class="toc-text">线程池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Wait-VS-Sleep"><span class="toc-number">5.3.</span> <span class="toc-text">Wait VS Sleep</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lock-VS-Synchronized"><span class="toc-number">5.4.</span> <span class="toc-text">Lock VS Synchronized</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Volatile%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">5.5.</span> <span class="toc-text">Volatile关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81VS%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">5.6.</span> <span class="toc-text">乐观锁VS悲观锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashTable-VS-ConcrrentHashMap"><span class="toc-number">5.7.</span> <span class="toc-text">HashTable VS ConcrrentHashMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLocal"><span class="toc-number">5.8.</span> <span class="toc-text">ThreadLocal</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JVM%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="toc-number">6.</span> <span class="toc-text">JVM虚拟机</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E5%8F%82%E6%95%B0"><span class="toc-number">6.1.</span> <span class="toc-text">JVM中的内存参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E4%B8%AD%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-number">6.2.</span> <span class="toc-text">JVM中的垃圾回收算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GC%E5%92%8C%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="toc-number">6.3.</span> <span class="toc-text">GC和分代回收算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6"><span class="toc-number">6.4.</span> <span class="toc-text">分代回收</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">6.5.</span> <span class="toc-text">垃圾回收器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="toc-number">6.6.</span> <span class="toc-text">内存溢出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">6.7.</span> <span class="toc-text">类加载的过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="toc-number">6.8.</span> <span class="toc-text">双亲委派机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%87%A0%E7%A7%8D"><span class="toc-number">6.9.</span> <span class="toc-text">对象的引用类型有几种</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLocalMap%E7%9A%84%E5%BC%B1%E5%BC%95%E7%94%A8"><span class="toc-number">6.10.</span> <span class="toc-text">ThreadLocalMap的弱引用</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/01/26/java%E5%AE%9E%E7%8E%B0%E4%BA%8C%E7%BB%B4%E7%A0%81/" title="java实现二维码">java实现二维码</a><time datetime="2023-01-26T12:34:00.000Z" title="发表于 2023-01-26 20:34:00">2023-01-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/01/17/java%E9%9D%A2%E8%AF%95%E7%AF%87%E7%AC%94%E8%AE%B0/" title="java面试篇笔记">java面试篇笔记</a><time datetime="2023-01-17T11:20:00.000Z" title="发表于 2023-01-17 19:20:00">2023-01-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/01/01/%E5%A4%A7%E5%9E%8B%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/" title="gulimall-deveploy">gulimall-deveploy</a><time datetime="2023-01-01T07:05:00.000Z" title="发表于 2023-01-01 15:05:00">2023-01-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/12/16/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/" title="java反射机制">java反射机制</a><time datetime="2022-12-15T16:00:00.000Z" title="发表于 2022-12-16 00:00:00">2022-12-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/12/02/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" title="微服务">微服务</a><time datetime="2022-12-02T04:31:48.000Z" title="发表于 2022-12-02 12:31:48">2022-12-02</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By CodeBoy</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>