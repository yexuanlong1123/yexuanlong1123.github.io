<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HelloWorld</title>
  
  <subtitle>本人也是正在学习，技术不是很成熟，难免有理解错的地方，还望大佬们指正，谢谢！！！</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-01-24T06:58:54.295Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>CodeBoy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java面试篇笔记</title>
    <link href="http://example.com/2023/01/17/java%E9%9D%A2%E8%AF%95%E7%AF%87%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2023/01/17/java%E9%9D%A2%E8%AF%95%E7%AF%87%E7%AC%94%E8%AE%B0/</id>
    <published>2023-01-17T11:20:00.000Z</published>
    <updated>2023-01-24T06:58:54.295Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="冒泡排序算法"><a href="#冒泡排序算法" class="headerlink" title="冒泡排序算法"></a>冒泡排序算法</h2><p>概述：冒泡排序是比较排序，<strong>以升序为主</strong>，即给定一个无序的数组，每轮排序所有相邻的元素都会进行一个比较，若前一个数与后一个数大则进行数交换位置的操作，最后将最大的那个数排到数组最后一个位置，这就是冒泡排序，以下是冒泡排序的实现代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  冒泡排序算法的实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BubbleSort</span> &#123;</span><br><span class="line">    <span class="comment">// 记录循环的次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">24</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        bubbleSort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="comment">// 因为是每次两个数进行比较，所以总的排序次数是arr.length - 1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">           <span class="comment">// 注意arr.length - 1 - i这里的-i是将冒泡的最后有序部分剔除掉，避免重复无效的排序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="comment">// 说明两个相邻的数，左边的数比右边的大就进行交换操作</span></span><br><span class="line">                    swap(arr,j,j+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                count ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;总的循环次数为：&quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数交换</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 无序数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i 相邻两个数的左边下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j 相邻两个数的右边下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230117195938657.png" alt="image-20230117195938657"></p><p>在以上的冒泡排序算法中还存在一个问题，那就是若本来就有序的数组还是会重复无效的进行比较排序，这样就显得多此一举，故我们可以定义一个标志位进行一个判断，若一个数组已经是处于一个有序状态，则就可以提前结束循环，从而避免无效的排序循环。具体实现如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  冒泡排序算法的实现--优化version1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BubbleSort</span> &#123;</span><br><span class="line">    <span class="comment">// 记录循环的次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        bubbleSort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="comment">// 标志位</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 因为是每次两个数进行比较，所以总的排序次数是arr.length - 1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 改变标志位，说明该轮循环有进行交换操作</span></span><br><span class="line">                  flag = <span class="literal">true</span>;</span><br><span class="line">                   <span class="comment">// 说明两个相邻的数，左边的数比右边的大就进行交换操作</span></span><br><span class="line">                    swap(arr,j,j+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                count ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!flag) &#123;</span><br><span class="line">                <span class="comment">// 在某一轮未进行比较操作，则可以说明该数组已经处于有序状态了</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;总的循环次数为：&quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数交换</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 无序数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i 相邻两个数的左边下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j 相邻两个数的右边下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>冒泡排序总结</strong></p><p>主要核心思想是：依次比较数组中相邻的两个元素，若前面的元素比后面的元素大，则需要进行交换，最后会将最大的数放到数组的最后位置。重复此操作最后数组就会变成有序的。时间复杂度是O(n^2)，空间复杂度是O(n)，并且是稳定排序。</p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>概述：在选择排序中数组分为有序部分和无序部分，每轮的排序都会将无序部分中最小的值排到有序部分上，例如，数组[8,2,1,4,5]，会先假定第一个值8为最小值，然后跟8后面的部分（无序部分）进行比较，若发现有比8还小的值（无序部分中最小的值），则将最小的值和8的位置进行交换，第二轮会假定2为最小值，以此类推，最终都会变得有序，以下是具体代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  选择排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">8</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        selectionSort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selectionSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 先假定数组的第一个为最小的值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="comment">// 在遍历寻找minIndex后边的值，是否存在比当前的值还小，若存在，则需要进行交换</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> minIndex + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[minIndex] &gt; arr[j]) &#123;</span><br><span class="line">                    minIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(minIndex != i) &#123;</span><br><span class="line">                <span class="comment">//说明在minIndex后边存在比当前的值还小，进行交换</span></span><br><span class="line">                swap(arr,minIndex,i);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Arrays.toString(arr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 数据元素交换，将i所在位置和j所在位置进行交换</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230117220509754.png" alt="image-20230117220509754"></p><p><strong>选择排序的总结</strong></p><p>选择排序的时间复杂度是O(n^2)，空间复杂度O(n)，是属于不稳定排序算法。</p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>概述：插入排序也分为有序部分和无序部分，有序部分会不断扩大，最终都将变成有序的数组，具体代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsertSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">9</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">        insertSort(arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 插入排序的实现方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="comment">// 首先从无序部分开始遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i]; <span class="comment">// 先暂时保存无序部分的第一个值，为后续的插入做准备</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - <span class="number">1</span>; <span class="comment">//有序部分的最后一个元素的索引</span></span><br><span class="line">            <span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; j--) &#123; <span class="comment">// temp依次比较有序部分的值，找到自己的合适位置</span></span><br><span class="line">                <span class="keyword">if</span>(temp &lt; arr[j]) &#123;</span><br><span class="line">                    <span class="comment">// 说明temp的值与当前的值小，当前的值需要往后移一位</span></span><br><span class="line">                    arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 说明temp值已经找到了合适的位置，结束循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前面的循环出来后，j + 1所在的索引就是temp值所在的位置</span></span><br><span class="line">            arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            System.out.println(Arrays.toString(arr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>插入排序的总结</strong></p><p>插入排序分为有序区域和无序区域，每轮排序都会从无序区域的第一个元素插入到有序区域的合适位置上（在有序部分碰到比temp值小的就可以确定temp的值所插入的位置），需要保证有序区域的有序性，重复以上步骤最终可以得到整体有序的数组。时间复杂度为O(n^2)，是稳定排序。<strong>执行的效率：插入排序 &gt; 选择排序 &gt; 冒泡排序</strong></p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>概述：快速排序是需要选择一个基准点pivot，然后进行每轮的排序，基准点的左边的值都比基准点本身的值小，右边的值都比基准点本身的值大，每次都会进行一个分区比较，每个区中都有一个基准点，最终分区的元素为0时，说明数组已经是基于有序了。这里体现的是分而治之的思想。以下代码是快速排序的实现过程（两种方式）</p><ul><li>单边循环快排</li></ul><p>在单边循环中一般选择数组最右边的元素作为基准点，这里实现的代码有两个指针<strong>i和j</strong>，<strong>i</strong>代表的是维护比基准点值小的左边界和每次交换的目标索引，<strong>j</strong>代表的是寻找比基准点还小的值与<strong>i</strong>所在的位置进行交换，最后<strong>i</strong>会和基准点进行交换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  快速排序--单边</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">5</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        quickSort(arr,<span class="number">0</span>,arr.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> left,<span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right) &#123;</span><br><span class="line">            <span class="comment">// 没有元素可以再进行分区，结束递归分区</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1. 进行一个分区并返回分区后基准点所在的索引位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivotIndex</span> <span class="operator">=</span> portion(arr, left, right);</span><br><span class="line">        <span class="comment">// 2. 根据基准点所在的位置对基准点左边在进行分区</span></span><br><span class="line">        quickSort(arr, left, pivotIndex - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 3. 根据基准点所在的位置对基准点右边进行分区</span></span><br><span class="line">        quickSort(arr, pivotIndex + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 待排序的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left 数组左边的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right 数组右边的所有</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 经过分区后i指针所在的位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">portion</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="comment">// 最右边的元素作为基准点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[right];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="comment">// j指针寻找比pivot小的值所在的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> left; j &lt; right; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &lt; pivot) &#123;</span><br><span class="line">                <span class="comment">// 说明找到了，就与i进行交换</span></span><br><span class="line">                swap(arr,i,j);</span><br><span class="line">                i ++; <span class="comment">// i需要右移一位</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后将i与基准点所在位置进行交换</span></span><br><span class="line">        swap(arr,i,right);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数交换</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 无序数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i 相邻两个数的左边下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j 相邻两个数的右边下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../../../../soft/typero/ImgesManage/image-20230118150315998.png" alt="image-20230118150315998"></p><ul><li>双边循环快排</li></ul><p>概述：双边循环也称为双指针循环，一般数组的最左边元素是作为基准点，在双指针中假设是i和j，i的职责是从左往右寻找比级基准点大的元素，j的职责是从右往左寻找比基准点小的元素，若ij分别找到各自的元素则进行交换，最后i和j相交时则结束寻找，此时的i就是分区的位置，最后i和基准点需要进行一次交换。</p><p><strong>细节问题</strong>：在i和j指针寻找的顺序，必须先寻找小的值，然后再寻找大的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  快速排序--双边循环</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">5</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">        quickSort(arr,<span class="number">0</span>,arr.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> left,<span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right) &#123;</span><br><span class="line">            <span class="comment">// 没有元素可以再进行分区，结束递归分区</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1. 进行一个分区并返回分区后基准点所在的索引位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivotIndex</span> <span class="operator">=</span> portion(arr, left, right);</span><br><span class="line">        <span class="comment">// 2. 根据基准点所在的位置对基准点左边在进行分区</span></span><br><span class="line">        quickSort(arr, left, pivotIndex - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 3. 根据基准点所在的位置对基准点右边进行分区</span></span><br><span class="line">        quickSort(arr, pivotIndex + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">portion</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> left,<span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="comment">// 选择最左边的作为基准点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[left];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; <span class="comment">// 负责找比基准点大的元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> right;<span class="comment">// 负责找比基准点小的元素</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">           <span class="comment">// 先找小的值</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt; pivot) &#123;</span><br><span class="line">                j --;</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="comment">// 再找大的值</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt;= pivot ) &#123;</span><br><span class="line">                i ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// i 和 j 进行交换</span></span><br><span class="line">            swap(arr,i,j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后i和基准点进行交换</span></span><br><span class="line">        swap(arr,i,left);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数交换</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 无序数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i 相邻两个数的左边下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j 相邻两个数的右边下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>快速排序的总结</strong></p><p>平均时间复杂度O(nlog2n)，最坏的时间复杂度O(n^2)，对于数据量比较大时使用该算法会有比较明显的优势，是不稳定排序</p><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><h2 id="ArrayList的扩容机制"><a href="#ArrayList的扩容机制" class="headerlink" title="ArrayList的扩容机制"></a>ArrayList的扩容机制</h2><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230118160852310.png" alt="image-20230118160852310"></p><h2 id="LinkedList和ArrayList的比对"><a href="#LinkedList和ArrayList的比对" class="headerlink" title="LinkedList和ArrayList的比对"></a>LinkedList和ArrayList的比对</h2><p><strong>LinkedList</strong></p><ul><li>LinkedList底层是双向链表实现，无需连续内存空间，随机访问慢，头尾插入和删除操作的效率高（因为链表的插入和删除操作不用移动元素），但在插入和删除中间的元素时性能较低（若只考虑插入和删除的操作，则效率高，若考虑定位查找到目标数据或目标位置然后再进行增删操作，则总体的效率低），占用内存大。</li></ul><p><strong>ArrayList</strong></p><ul><li>ArrayList底层是基于数组实现的，需要连续的内存空间来存储数据，可以通过计算来确定数组的下标，从而确定需要访问的目标数据，故随机访问速度快。在一定长度的数组头部和中间数据进行增删操作效率比LinkedList低，但在尾部进行插入和删除的效率比LinkedList高。可以利用CPU缓存和局部性原理（CPU每次读取数据进行计算时都会读取目标数据的相邻元素一起读到缓存中）。占用内存小</li></ul><h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><p>HashMap的底层数据结构JDK1.7和JDK1.8版本有什么区别？</p><ul><li><strong>在JDK1.7版本中HashMap是采用数组+链表，在JDK1.8是数组 +（链表 | 红黑树）</strong></li></ul><p>如何解决HashMap底层的链表过长问题？</p><ul><li><strong>通过给HashMap的数组扩容，但在某个特殊的情况下并不能有效的解决。</strong></li><li><strong>通过树化链表可以有效解决，前提条件是在HashMap的数组长度达到（&gt;&#x3D;64）才能触发树化效果并且在某个数组下的节点大到8个节点</strong></li></ul><p>为何需要使用红黑树？为什么不是一上来就树化？</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230119150749106.png" alt="image-20230119150749106"></p><p>HashMap的索引计算？</p><ul><li><strong>通过调用hash的方法来计算对象的HashCode，然后再模于数组的长度 - 1，&gt;&gt; 公式：hash值 mod 数组长度 - 1</strong></li></ul><p>为何需要进行二次的hashCode的计算？</p><ul><li><strong>二次hashCode的计算是为了综合高位数据，使得哈希分布更为均匀。</strong></li></ul><p>数组容量为何是2的n次幂？</p><ul><li><strong>因为2的n次幂可以通过位与运算得到取模运算同样的结果，并且位与运算效率更高，扩容时若 hash &amp; 旧容量长度 &#x3D;&#x3D; 0，则元素的位置不变，否则新位置&#x3D;旧位置+旧容量的长度。</strong></li></ul><p>HashMap_put()的流程？</p><ul><li><strong>HashMap是懒惰创建数组的，首次使用才创建数组计算索引（桶下标)</strong></li><li><strong>如果桶下标还没人占用，创建Node占位返回</strong></li><li><strong>如果桶下标已经有人占用</strong><ul><li><strong>已经是TreeNode走红黑树的添加或更新逻辑</strong></li><li><strong>是普通Node，走链表的添加或更新逻辑，如果链表长度超过树化阈值，走树化逻辑</strong></li></ul></li><li><strong>返回前检查容量是否超过阈值，一旦超过进行扩容不同</strong></li></ul><p>HashMap_put()在JDK1.7和JDK1.8的不同？</p><ol><li><strong>链表插入节点时，1.7是头插法，1.8是尾插法。</strong></li><li><strong>1.7是大于阈值（数组长度 * 负载因子(0.75)）且没有空位才进行扩容，1.8是大于阈值就进行扩容。</strong></li><li><strong>1.8比1.7的效率更高。</strong></li></ol><p>加载（负载）因子为何是0.75？</p><ul><li><strong>在空间占用与查询时间之间取得较好的权衡</strong></li><li><strong>大于这个值，空间节省了，但链表就会比较长影响性能</strong></li><li><strong>小于这个值，冲突减少了，但扩容就会更频繁，空间占用多</strong></li></ul><p>多线程下HashMap会出现什么问题（在JDK1.7版本下发生）？</p><ol><li><p><strong>并发丢失数据。</strong></p></li><li><p><strong>由于头插法导致并发下扩容死链问题。</strong></p></li></ol><p>HashMap中的key是否可以为null，作为key的对象有和要求？</p><ol><li><strong>HashMap中的key是可以为null的，但在其它的map集合中是不可以为null的，例如HashTable。</strong></li><li><strong>作为key的对象，必须实现hashCode和equals的方法，并且key对象是不可修改的。</strong></li></ol><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230119203801278.png" alt="image-20230119203801278"></p><h1 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h1><p>以下是单例模式的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> a_based_item1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  饿汉式单例--在该类初始化的时候就创建实例对象，线程是安全的。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 预防反射破坏单例</span></span><br><span class="line">        <span class="keyword">if</span>(INSTANCE != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;单例不可重复创建&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Singleton单例模式初始化。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">otherMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;otherMethod其它方法执行。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>单例被破坏的三最种情况</strong></p><ol><li>反射破坏单例，这是可以预防的，如上代码。</li><li>反序列化破坏单例（可解决）</li><li>unsafe破坏单例（不可解决）</li></ol><p>以下是懒汉式单例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  懒汉式单例--类在加载时不实例化对象，只有等到第一次用的时候才去实例化。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;懒汉式单例初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton2</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 创建实例</span></span><br><span class="line">            INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton2</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在多线程序会破坏单例的证明如下测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  多线程下破坏懒汉式单例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonTest2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建10个线程</span></span><br><span class="line">        creatThreadByNum(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">creatThreadByNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="type">Singleton2</span> <span class="variable">instance</span> <span class="operator">=</span> Singleton2.getInstance();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;&gt;&gt;&quot;</span> + instance);</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.setName(<span class="string">&quot;线程&quot;</span> + (i + <span class="number">1</span>));</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230120144155537.png" alt="image-20230120144155537"></p><p><strong>以下代码是解决多线程下破坏懒汉式单例的方案DCL（Double Check Lock）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  懒汉式单例--DCL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;懒汉式单例初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 需要加volatile，可以解决共享变量的可见性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">Singleton2</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 加锁，防止多线程同时满足条件，同时进行创建实例的代码块</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton2.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton2</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230120144624401.png" alt="image-20230120144624401"></p><h1 id="并发篇"><a href="#并发篇" class="headerlink" title="并发篇"></a>并发篇</h1><h2 id="Java线程的六种状态"><a href="#Java线程的六种状态" class="headerlink" title="Java线程的六种状态"></a>Java线程的六种状态</h2><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230120150100666.png" alt="image-20230120150100666"></p><p><strong>下图是操作系统中的线程状态</strong></p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230121140706806.png" alt="image-20230121140706806"></p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p><strong>java.util.concurrent.ThreadPoolExecutor</strong></p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230121142617613.png" alt="image-20230121142617613"></p><h2 id="Wait-VS-Sleep"><a href="#Wait-VS-Sleep" class="headerlink" title="Wait VS Sleep"></a>Wait VS Sleep</h2><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230121150713734.png" alt="image-20230121150713734"></p><h2 id="Lock-VS-Synchronized"><a href="#Lock-VS-Synchronized" class="headerlink" title="Lock VS Synchronized"></a>Lock VS Synchronized</h2><p><img src="/../../../../soft/typero/ImgesManage/image-20230121152148928.png" alt="image-20230121152148928"></p><p><strong>公平锁与非公平锁的区别？</strong></p><ul><li>公平锁是在阻塞队列中的线程分别以先进先出的形式依次执行线程</li><li>非公平锁不是以先进先出的形式出现，有可能出现其他线程插队的情况。</li></ul><h2 id="Volatile关键字"><a href="#Volatile关键字" class="headerlink" title="Volatile关键字"></a>Volatile关键字</h2><p><strong>线程安全包括三个方面：可见性、有序性、原子性</strong></p><ul><li>可见性：是一个线程对某个变量进行修改，其它线程是能看到最新的结果</li><li>有序性：一个线程中的代码是按照编码顺序执行的</li><li>原子性：一个线程中的代码是以一个整体运行的，在运行期间不可以有其它线程代码插队</li></ul><p><strong>Volatile关键字可以保证可见性和有序性，不能保证原子性</strong></p><h2 id="乐观锁VS悲观锁"><a href="#乐观锁VS悲观锁" class="headerlink" title="乐观锁VS悲观锁"></a>乐观锁VS悲观锁</h2><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230124144738446.png" alt="image-20230124144738446"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;排序算法&quot;&gt;&lt;a href=&quot;#排序算法&quot; class=&quot;headerlink&quot; title=&quot;排序算法&quot;&gt;&lt;/a&gt;排序算法&lt;/h1&gt;&lt;h2 id=&quot;冒泡排序算法&quot;&gt;&lt;a href=&quot;#冒泡排序算法&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序算</summary>
      
    
    
    
    
    <category term="面试" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>gulimall-deveploy</title>
    <link href="http://example.com/2023/01/01/%E5%A4%A7%E5%9E%8B%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"/>
    <id>http://example.com/2023/01/01/%E5%A4%A7%E5%9E%8B%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/</id>
    <published>2023-01-01T07:05:00.000Z</published>
    <updated>2023-01-24T09:13:27.379Z</updated>
    
    <content type="html"><![CDATA[<h1 id="商品服务业务开发"><a href="#商品服务业务开发" class="headerlink" title="商品服务业务开发"></a>商品服务业务开发</h1><h2 id="三级分类查询"><a href="#三级分类查询" class="headerlink" title="三级分类查询"></a>三级分类查询</h2><ol><li>需求：更具数据id查询出所有的商品分类名称并以树型结构返回，原因是每个分类都有自己的子分类，所以需要递归算法进行划分，具体代码如下，根据数据库的字段parent_cid和cat_id进行筛选。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 所有的分类标签</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;CategoryEntity&gt; <span class="title function_">listWithTree</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//1. 查找出所有的分类</span></span><br><span class="line">    List&lt;CategoryEntity&gt; categorys = <span class="built_in">this</span>.getBaseMapper().selectList(<span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//2. 根据ParentCid进行筛选分类</span></span><br><span class="line">    <span class="comment">//2.1 先筛选出父类分类</span></span><br><span class="line">    List&lt;CategoryEntity&gt; parents = categorys.stream().</span><br><span class="line">            filter(category -&gt; category.getParentCid() == <span class="number">0</span>).</span><br><span class="line">            collect(Collectors.toList());</span><br><span class="line">    <span class="comment">//2.2 筛选各父类对应子分类</span></span><br><span class="line">    List&lt;CategoryEntity&gt; level1Menu = parents.stream()</span><br><span class="line">            .map(parent -&gt; &#123;</span><br><span class="line">                <span class="comment">//通过递归的方式查询出每个父类的孩子</span></span><br><span class="line">                parent.setChildren(findChildren(parent,categorys));</span><br><span class="line">                <span class="keyword">return</span> parent;</span><br><span class="line">            &#125;).sorted((m1,m2) -&gt; &#123;</span><br><span class="line">                <span class="comment">//排序，三目运算符是为避免空指针异常</span></span><br><span class="line">                <span class="keyword">return</span> (m1.getSort()==<span class="literal">null</span>?<span class="number">0</span>:m1.getSort()) - (m2.getSort()==<span class="literal">null</span>?<span class="number">0</span>:m2.getSort());</span><br><span class="line">            &#125;)</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    <span class="keyword">return</span> level1Menu;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> List&lt;CategoryEntity&gt; <span class="title function_">findChildren</span><span class="params">(CategoryEntity root,List&lt;CategoryEntity&gt; all)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> all.stream().filter(child -&gt; Objects.equals(root.getCatId(), child.getParentCid()))</span><br><span class="line">            .map(child -&gt; &#123;</span><br><span class="line">                <span class="comment">//给该孩子找自己的孩子分类</span></span><br><span class="line">                child.setChildren(findChildren(child,all));</span><br><span class="line">                <span class="keyword">return</span> child;</span><br><span class="line">            &#125;).sorted((m1,m2) -&gt; &#123;</span><br><span class="line">                <span class="comment">//排序，三目运算符是为避免空指针异常</span></span><br><span class="line">                <span class="keyword">return</span> (m1.getSort()==<span class="literal">null</span>?<span class="number">0</span>:m1.getSort()) - (m2.getSort()==<span class="literal">null</span>?<span class="number">0</span>:m2.getSort());</span><br><span class="line">            &#125;)</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>前后端接口的对接，将后端查询的数据返回给前端。</li></ol><h2 id="品牌管理"><a href="#品牌管理" class="headerlink" title="品牌管理"></a>品牌管理</h2><p>文件上传至oss服务业务</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230106162733180.png" alt="image-20230106162733180"></p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230106162807740.png" alt="image-20230106162807740"></p><p>将图片上传到aliyun的oss中，步骤如下</p><ol><li>导入alicloud的坐标</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- oss上传接口 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alicloud-oss<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>在aliyun中创建一个子用户，用于文件上传</p></li><li><p>配置上传的参数</p></li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="comment"># 配置oss的上传服务</span></span><br><span class="line">    <span class="attr">alicloud:</span></span><br><span class="line">      <span class="attr">access-key:</span> <span class="string">LTAI5tNB6qQmFB8MpUfdf4K7</span> <span class="comment"># 创建子用户时这里都会有显示</span></span><br><span class="line">      <span class="attr">secret-key:</span> <span class="string">UDYX1WJttRuBLKf4qYRWHLxAMNS6xa</span></span><br><span class="line">      <span class="attr">oss:</span></span><br><span class="line">        <span class="attr">endpoint:</span> <span class="string">oss-cn-hangzhou.aliyuncs.com</span> <span class="comment"># 选择一个oss的Bucket名称即可</span></span><br></pre></td></tr></table></figure><ol start="4"><li>编写第三方的模块服务，用户上传图片时会请求该服务模块获取上传到aliyun的资格，获取成功后可以直接上传到aliyun，不用在经过服务器，以上是获取资格的aliyun官方代码对其进行修改即可</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Endpoint以华东1（杭州）为例，其它Region请按实际情况填写。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">endpoint</span> <span class="operator">=</span> <span class="string">&quot;https://oss-cn-hangzhou.aliyuncs.com&quot;</span>;</span><br><span class="line"><span class="comment">// 阿里云账号AccessKey拥有所有API的访问权限，风险很高。强烈建议您创建并使用RAM用户进行API访问或日常运维，请登录RAM控制台创建RAM用户。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">accessKeyId</span> <span class="operator">=</span> <span class="string">&quot;yourAccessKeyId&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">accessKeySecret</span> <span class="operator">=</span> <span class="string">&quot;yourAccessKeySecret&quot;</span>;</span><br><span class="line"><span class="comment">// 填写Bucket名称，例如examplebucket。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">bucketName</span> <span class="operator">=</span> <span class="string">&quot;examplebucket&quot;</span>;</span><br><span class="line"><span class="comment">// 填写Object完整路径，完整路径中不能包含Bucket名称，例如exampledir/exampleobject.txt。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">objectName</span> <span class="operator">=</span> <span class="string">&quot;exampledir/exampleobject.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建OSSClient实例。</span></span><br><span class="line"><span class="type">OSS</span> <span class="variable">ossClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OSSClientBuilder</span>().build(endpoint, accessKeyId, accessKeySecret);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 填写Byte数组。</span></span><br><span class="line">    <span class="type">byte</span>[] content = <span class="string">&quot;Hello OSS, 你好世界&quot;</span>.getBytes();</span><br><span class="line">    <span class="comment">// 创建PutObjectRequest对象。</span></span><br><span class="line">    <span class="type">PutObjectRequest</span> <span class="variable">putObjectRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PutObjectRequest</span>(bucketName, objectName, <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(content));</span><br><span class="line">    <span class="comment">// 设置该属性可以返回response。如果不设置，则返回的response为空。</span></span><br><span class="line">    putObjectRequest.setProcess(<span class="string">&quot;true&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建PutObject请求。</span></span><br><span class="line">    <span class="type">PutObjectResult</span> <span class="variable">result</span> <span class="operator">=</span> ossClient.putObject(putObjectRequest);</span><br><span class="line">    <span class="comment">// 如果上传成功，则返回200。</span></span><br><span class="line">    System.out.println(result.getResponse().getStatusCode());</span><br><span class="line">&#125; <span class="keyword">catch</span> (OSSException oe) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Caught an OSSException, which means your request made it to OSS, &quot;</span></span><br><span class="line">            + <span class="string">&quot;but was rejected with an error response for some reason.&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;Error Message:&quot;</span> + oe.getErrorMessage());</span><br><span class="line">    System.out.println(<span class="string">&quot;Error Code:&quot;</span> + oe.getErrorCode());</span><br><span class="line">    System.out.println(<span class="string">&quot;Request ID:&quot;</span> + oe.getRequestId());</span><br><span class="line">    System.out.println(<span class="string">&quot;Host ID:&quot;</span> + oe.getHostId());</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClientException ce) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Caught an ClientException, which means the client encountered &quot;</span></span><br><span class="line">            + <span class="string">&quot;a serious internal problem while trying to communicate with OSS, &quot;</span></span><br><span class="line">            + <span class="string">&quot;such as not being able to access the network.&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;Error Message:&quot;</span> + ce.getMessage());</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ossClient != <span class="literal">null</span>) &#123;</span><br><span class="line">        ossClient.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SKU-amp-SPU的属性分组"><a href="#SKU-amp-SPU的属性分组" class="headerlink" title="SKU&amp;SPU的属性分组"></a>SKU&amp;SPU的属性分组</h2><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230108115618524.png" alt="image-20230108115618524"></p><h2 id="商品管理–SKU检索"><a href="#商品管理–SKU检索" class="headerlink" title="商品管理–SKU检索"></a>商品管理–SKU检索</h2><h2 id="仓储管理"><a href="#仓储管理" class="headerlink" title="仓储管理"></a>仓储管理</h2><p><strong>合并采购单业务流程</strong></p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230114162049536.png" alt="image-20230114162049536"></p><p><strong>采购单领取业务开发</strong></p><p>采购单通常有5种状态分别是：创建、已分配、已领取、已完成、有异常。而领取采购单只能是从创建、已分配这两种状态中是可以领取的，其它状态是不可被领取的。所以在业务中需要将其它状态的采购单给过滤掉。</p><h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><h2 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h2><p>官方英文：[Elasticsearch Guide <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html">8.6] | Elastic</a></p><p>官方中文：<a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/foreword_id.html">序言 | Elasticsearch: 权威指南 | Elastic</a></p><p>ElasticSearch的基本概念：</p><ol><li>Index（索引）：用于存储表，相当于Mysql中的Database</li><li>Type（类型）：相当于Mysql中的Table，用于存储数据</li><li>Document（文档）：某个Type下的一个数据，是以Json格式存贮的，相当于Mysql中的Table下的数据</li></ol><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230117125025796.png" alt="image-20230117125025796"></p><p>ElasticSearch的强大搜索功能是基于倒排索引机制的。</p><p><strong>使用docker下载ElasticSearch的镜像命令</strong></p><ol><li>docker pull elasticsearch:版本号  &gt;&gt;  用于存储和检索数据</li><li>docker pull kibana:版本号 &gt;&gt; 可视化界面</li></ol><p><strong>创建一个docker运行镜像</strong></p><ol><li>自行创建两个挂载文件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p 文件目录/文件名称</span><br><span class="line">mkdir -p /root/mydata/elasticsearch/data </span><br><span class="line">mkdir -p /root/mydata/elasticsearch/config</span><br></pre></td></tr></table></figure><ol start="2"><li>做好一个小配置</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo echo &quot;http.host: 0.0.0.0&quot; &gt;&gt; /mydata/elasticsearch/config/elasticsearch.yml</span><br></pre></td></tr></table></figure><ol start="3"><li>提升挂载文件的权限</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod -R 777 /root/mydata/elasticsearch</span><br></pre></td></tr></table></figure><ol start="4"><li>使用docker的运行命令</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run --name elasticsearch -p 9200:9200 -p 9300:9300 \</span><br><span class="line">-e discovery.type=&quot;single-node&quot; \</span><br><span class="line">-e ES_JAVA_OPTS=&quot;-Xms64m -Xmx128m&quot; \</span><br><span class="line">-v /root/mydata/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml \</span><br><span class="line">-v /root/mydata/elasticsearch/data:/usr/share/elasticsearch/data \</span><br><span class="line">-v /root/mydata/elasticsearch/plugins:/usr/share/elasticsearch/plugins \</span><br><span class="line">-d elasticsearch:7.4.2</span><br></pre></td></tr></table></figure><p><strong>运行可视化界面Kibana</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name kibana -e ELASTICSEARCH_HOSTS=http://192.168.177.130:9200 -p 5601:5601 -d kibana:7.4.2</span><br></pre></td></tr></table></figure><h3 id="初步检索"><a href="#初步检索" class="headerlink" title="初步检索"></a>初步检索</h3><p><strong>查看_cat</strong></p><p>利用postman发送http请求即可对其检索</p><ol><li><p><a href="http://192.168.177.130:9200/_cat/nodes%EF%BC%9A%E6%9F%A5%E7%9C%8B%E6%89%80%E6%9C%89%E8%8A%82%E7%82%B9GET">http://192.168.177.130:9200/_cat/nodes：查看所有节点GET</a></p></li><li><p><a href="http://192.168.177.130:9200/_cat/health%EF%BC%9A%E6%9F%A5%E7%9C%8Bes%E5%81%A5%E5%BA%B7%E7%8A%B6%E5%86%B5GET">http://192.168.177.130:9200/_cat/health：查看es健康状况GET</a></p></li><li><p><a href="http://192.168.177.130:9200/_cat/master%EF%BC%9A%E6%9F%A5%E7%9C%8B%E4%B8%BB%E8%8A%82%E7%82%B9GET">http://192.168.177.130:9200/_cat/master：查看主节点GET</a></p></li><li><p><a href="http://192.168.177.130:9200/_cat/indices%EF%BC%9A%E6%9F%A5%E7%9C%8B%E6%89%80%E6%9C%89%E7%B4%A2%E5%BC%95GET">http://192.168.177.130:9200/_cat/indices：查看所有索引GET</a></p></li></ol><p><strong>新增操作</strong></p><p>REST_API的格式：<a href="http://192.168.177.130:9200/index%E5%90%8D%E7%A7%B0/type%E5%90%8D%E7%A7%B0/ID">http://192.168.177.130:9200/index名称/type名称/ID</a></p><ul><li>Post请求：指定ID，若存在该数据则修改操作，否则是新增操作，不指定ID，则都是新增操作</li><li>Put请求：必须指定ID，否则会保错，一般是用于修改操作</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;商品服务业务开发&quot;&gt;&lt;a href=&quot;#商品服务业务开发&quot; class=&quot;headerlink&quot; title=&quot;商品服务业务开发&quot;&gt;&lt;/a&gt;商品服务业务开发&lt;/h1&gt;&lt;h2 id=&quot;三级分类查询&quot;&gt;&lt;a href=&quot;#三级分类查询&quot; class=&quot;headerli</summary>
      
    
    
    
    
    <category term="springcloud" scheme="http://example.com/tags/springcloud/"/>
    
  </entry>
  
  <entry>
    <title>java反射机制</title>
    <link href="http://example.com/2022/12/16/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
    <id>http://example.com/2022/12/16/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</id>
    <published>2022-12-15T16:00:00.000Z</published>
    <updated>2022-12-17T08:54:32.540Z</updated>
    
    <content type="html"><![CDATA[<p>概述：反射是jvm中非常重要的机制，在spring系列所有的框架中底层都有涉及到反射机制，若java没有反射的话，那么也就没有如今的spring系列的框架，而且反射可以实现在不修改源码情况下来控制程序，符合了设计模式中的ocp原则（开闭原则），同时也是实现动态代理的前提。</p><p><strong>传统方式创建对象VS反射机制创建对象</strong> </p><p>在java中传统的创建对象是new 类()，而反射中是从堆中取出Class对象并通过Class来反射到具体的类中，对具体的类成员方法、成员属性、成员变量等类中的所有成员进行创建、调用等操作。单单看文字很难理解，以下是反射的原理图（来自B站韩孙平的反射讲解）。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221216211655077.png" alt="image-20221216211655077"></p><p>对上图的理解：java程序有三个阶段，第一是编译阶段，在这一阶段是通过jvm虚拟机进行java代码进行编译，形成了class的字节码文件，在jvm中在通过ClassLoader（类加载器）将class的字节码文件读取到第二阶段（加载阶段）并在堆中创建Class对象，在运行阶段是可以通过new 类() 方式从堆中将Class对象创建出来，便可以对此类的成员进行操作，而反射的方式创建对象并不是如此，反射是通过具体的对象去获取具体类的结构，然后再去进行操作。</p><p><strong>代码演示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反射演示过程--&gt;传统方式创建对象VS反射机制创建对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mysticBoy</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * 反射常用的API有：</span></span><br><span class="line"><span class="comment"> *      java.lang.Class:代表一个类,Class对象表示某个类加载后在堆T</span></span><br><span class="line"><span class="comment"> *      java.lang.reflect.Method:代表类的方法,Method对象表示某个类的方法</span></span><br><span class="line"><span class="comment"> *      java.lang.reflect.Field:代表类的成员变量, Field对象表示某个类的成员变量</span></span><br><span class="line"><span class="comment"> *      java.lang.reflect.Constructor:代表类的构造方法, Constructor对象表示构造器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectionTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, InstantiationException &#123;</span><br><span class="line">        <span class="comment">//方式一：传统的方式调用Dog类中的成员方法</span></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        dog.hi();</span><br><span class="line">        <span class="comment">//需求：现在我需要根据配置文件去操作Dog中的成员，该如何做？</span></span><br><span class="line">        <span class="comment">//1. 用传统的方法是否可行?</span></span><br><span class="line">        <span class="comment">//(1) 首先需要从配置文件中获取到信息，可以使用Properties类获取</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="comment">//(2) 通过字符输入流读取文件并加载出信息</span></span><br><span class="line">        properties.load(Files.newInputStream(Paths.get(<span class="string">&quot;c_reflection\\profile\\reflection.properties&quot;</span>)));</span><br><span class="line">        <span class="comment">//(3) 获取出类具体和具体的方法</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">allPath</span> <span class="operator">=</span> (String) properties.get(<span class="string">&quot;allPath&quot;</span>); <span class="comment">//c_reflection.Dog 类的引用路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> (String) properties.get(<span class="string">&quot;methodName&quot;</span>);</span><br><span class="line">        <span class="comment">//(4) 现需要调用方hi方法，那么需要先创建对象，那要如何创建呢？</span></span><br><span class="line">        <span class="comment">//new allPath()这样创建是不行的，因为allPath是一个字符串，无法创建对象，故传统的方式是不能满足此需求的</span></span><br><span class="line">        System.out.println(<span class="string">&quot;==========反射机制===========&quot;</span>);</span><br><span class="line">        <span class="comment">//方式二：通过反射创建对象</span></span><br><span class="line">        <span class="comment">//1. 从配置文件读取的类</span></span><br><span class="line">        Class&lt;?&gt; cls = Class.forName(allPath);</span><br><span class="line">        <span class="comment">//2. 实例化类</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> cls.newInstance();</span><br><span class="line">        <span class="comment">//3. 从Class类对象中获取出方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> cls.getMethod(methodName);</span><br><span class="line">        <span class="comment">//4. 调用方法 反射的形式：对象.实体类</span></span><br><span class="line">        method.invoke(instance);</span><br><span class="line">       <span class="comment">//  获取成员变量</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> cls.getField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        <span class="comment">// 通过字段获取变量</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">i</span> <span class="operator">=</span> field.get(instance);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        <span class="comment">// 获取构造器</span></span><br><span class="line">        Constructor&lt;?&gt; cts = cls.getConstructor();</span><br><span class="line">        System.out.println(cts);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;哈士奇&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;System.out.println(<span class="string">&quot;hello &quot;</span> + name);&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span> &#123;System.out.println(<span class="string">&quot;汪汪汪&quot;</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>反射的优缺点</strong></p><ul><li><p>优点：可以动态的创建和使用对象(也是框架底层核心)，使用灵活，没有反射机制，框架技术就失去底层支撑。</p></li><li><p>缺点：使用反射基本是解释执行，对执行速度有影响.</p></li></ul><p><strong>Class类的特点</strong></p><ul><li>Class也是类，因此也继承Object类</li><li>Class类对象不是new出来的，而是系统创建的</li><li>对于某个类的Class类对象，在内存中只有一份，因为类只加载一次</li><li>每个类的实例都会记得自己是由哪个Class 实例所生成</li><li>通过Class可以完整地得到一个类的完整结构,通过一系列API</li><li>Class对象是存放在堆的</li></ul><p><strong>静态加载VS动态加载</strong></p><p>反射机制是java实现动态语言的关键，也就是通过反射实现类动态加载</p><ol><li>静态加载：编译时加载相关的类，如果没有则报错，依赖性太强</li><li>动态加载：运行时加载需要的类，如果运行时不用该类，即使不存在该类，则不报错，降低了依赖性</li></ol><p><strong>类加载时机</strong></p><ol><li>当创建对象时（静态加载）</li><li>当子类被加载时，父类也加载</li><li>调用类中的静态成员时</li><li>通过反射（动态加载）</li></ol><p><strong>类加载过程图</strong></p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221217161305473.png" alt="image-20221217161305473"></p><p><strong>类加载三阶段的具体流程</strong></p><p>在加载过程和连接过程是由jvm机控制的，而初始化是可以由程序员进行控制，注意这里的初始化是类中的初始静态代码块，而不是创建一个对象。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221217161441058.png" alt="image-20221217161441058"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;概述：反射是jvm中非常重要的机制，在spring系列所有的框架中底层都有涉及到反射机制，若java没有反射的话，那么也就没有如今的spring系列的框架，而且反射可以实现在不修改源码情况下来控制程序，符合了设计模式中的ocp原则（开闭原则），同时也是实现动态代理的前提。&lt;</summary>
      
    
    
    
    
    <category term="java基础" scheme="http://example.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>微服务</title>
    <link href="http://example.com/2022/12/02/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    <id>http://example.com/2022/12/02/%E5%BE%AE%E6%9C%8D%E5%8A%A1/</id>
    <published>2022-12-02T04:31:48.000Z</published>
    <updated>2023-01-01T09:57:09.341Z</updated>
    
    <content type="html"><![CDATA[<h1 id="认识微服务"><a href="#认识微服务" class="headerlink" title="认识微服务"></a>认识微服务</h1><ul><li><p>单体架构：将业务的所有功能集中在一个项目中开发，打成一个包部署。</p><ul><li>优点：架构简单、部署成本低</li><li>缺点：耦合度高、当有一个模块出现BUG，可能会导致整个系统崩溃。</li></ul></li><li><p>分布式架构：根据业务功能对系统进行拆分，每个业务模块作为独立项目开发，称为一个服务。</p><ul><li>优点：降低耦合度、有利于服务的升级和扩展。</li><li>缺点：研发成本高</li></ul></li><li><p>微服务是一种经过良好架构设计的分布式架构方案，微服务架构特征</p><ul><li>单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责，避免重复业务开友</li><li>面向服务：微服务对外暴露业务接口</li><li>自治：团队独立、技术独立、数据独立、部署独立</li><li>隔离性强：服务调用做好隔离、容错、降级、避免出现级联问题</li></ul></li></ul><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221204133958073.png" alt="image-20221204133958073"></p><h2 id="微服务结构"><a href="#微服务结构" class="headerlink" title="微服务结构"></a>微服务结构</h2><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221204134435078.png" alt="image-20221204134435078"></p><h2 id="微服务技术对比"><a href="#微服务技术对比" class="headerlink" title="微服务技术对比"></a>微服务技术对比</h2><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221204135049357.png" alt="image-20221204135049357"></p><h1 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h1><ul><li>SpringCloud集成了各种微服务功能组件，并基于SpringBoot实现了这些组件的自动装配，从而提供了良好的开箱即用体验:</li></ul><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221204135842628.png" alt="image-20221204135842628"></p><h1 id="服务拆分"><a href="#服务拆分" class="headerlink" title="服务拆分"></a>服务拆分</h1><ol><li>不同微服务，不要重复开发相同业务</li><li>微服务数据独立，不要访问其它微服务的数据库</li><li>微服务可以将自己的业务暴露为接口，供其它微服务调用</li></ol><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221204140506901.png" alt="image-20221204140506901"></p><h2 id="微服务远程调用"><a href="#微服务远程调用" class="headerlink" title="微服务远程调用"></a>微服务远程调用</h2><ul><li>概述：在微服务体系架构中，每个业务服务都是一个独立的服务模块，每个模块都有属于自己的数据库，所以要联表查询数据</li></ul><p>是不能像单体项目一样可以直接进行多表查询，而是要通过每个服务模块暴露出部分接口供给其它服务模块调用。</p><ul><li><p>远程调用的实质：就是给目标服务模块发送一个HTTP的请求，让目标服务进行一个响应并返回数据即可。</p></li><li><p>远程调用的API是RestTemplate，该API应交给Spring的IOC容器管理。</p></li><li><p>服务调用关系（两者身份是相对的）</p><ul><li>服务提供者：暴露接口给其它服务调用。</li><li>服务消费者：调用来自其它服务模块的提供的接口。</li></ul></li></ul><h1 id="Eureka注册中心"><a href="#Eureka注册中心" class="headerlink" title="Eureka注册中心"></a>Eureka注册中心</h1><p>服务调用出现的问题</p><ul><li>服务消费者该如何获取服务提供者的地址信息？</li><li>如果有多个服务提供者，消费者该如何选择？</li><li>消费者如何得知服务提供者的健康状态？</li></ul><p>Eureka介绍：主要作用是记录每个服务提供者的地址信息</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221204153807427.png" alt="image-20221204153807427"></p><p>Eureka架构</p><ol><li><p>EurekaService：服务端，注册中心——专门记录服务信息和服务接口的健康监测。</p></li><li><p>EurekaClient：客户端</p><ul><li>服务提供者：注册服务提供者的信息，并每隔30秒会进行一个监测，保证接口是否可以正常供应</li><li>服务消费者：根据服务名称从EurekaServer拉取服务列表，基于服务列表做负载均衡，选中一个微服务后发起远程调用</li></ul></li></ol><h2 id="搭建EurekaServer"><a href="#搭建EurekaServer" class="headerlink" title="搭建EurekaServer"></a>搭建EurekaServer</h2><p>搭建EurekaServer服务步骤如下</p><ol><li>创建项目，引入spring-cloud-starter-netflix-eureka-server的依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>编写启动类，添加@EnableEurekaServer注解</li><li>添加application.yml文件，编写下面的配置</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8888</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eurekaServer</span></span><br><span class="line"><span class="comment"># 注册信息</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:8888/eureka</span></span><br></pre></td></tr></table></figure><h2 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h2><ol><li>在目标项目中引入坐标spring-cloud-starter-netflix-eureka-client</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--  引入eureka的客户端--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>在application.yml的配置参数如下</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置服务的名称</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">userService</span></span><br><span class="line"><span class="comment"># 注册信息</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:8888/eureka</span></span><br></pre></td></tr></table></figure><h2 id="使用Eureka实现负载均衡"><a href="#使用Eureka实现负载均衡" class="headerlink" title="使用Eureka实现负载均衡"></a>使用Eureka实现负载均衡</h2><ol><li>在RestTemplate加载Bean的方法上加注解@LoadBalanced即可实现。</li><li>在RestTemplate远程调用时可以使用已在eureka服务器中注册的服务名称进行调用，RestTemplate会在eureka服务发现指定的端口并进行远程连接。</li></ol><h1 id="Ribbon负载均衡原理"><a href="#Ribbon负载均衡原理" class="headerlink" title="Ribbon负载均衡原理"></a>Ribbon负载均衡原理</h1><p>​在order-service服务发出了一个请求，若在order-service中加载Bean的RestTemplate方法上有@LoadBalanced时，其发出的请求会被LoadBalancerInterceptor类（负载均衡拦截器）拦截下来，然后到enreka-server（服务中心）根据别名（userservice）查找已注册的服务列表，若存在该服务名称则就返回相关的服务列表到Ribbon中，该返回的列表是真实的ip地址号，在Ribbon中进一步的进行负载均衡的算法。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221210152342658.png" alt="image-20221210152342658"></p><ul><li>Ribbon内部结构图</li></ul><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221210153437529.png" alt="image-20221210153437529"></p><h2 id="负载均衡的策略"><a href="#负载均衡的策略" class="headerlink" title="负载均衡的策略"></a>负载均衡的策略</h2><ul><li>下图是Ribbon负载均衡策略继承关系</li></ul><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221210153849904.png" alt="image-20221210153849904"></p><ul><li>每个类的含义</li></ul><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221210154712521.png" alt="image-20221210154712521"></p><ul><li>调整负载均衡的规则，默认是轮询的方式作为负载均衡<ul><li>将需要目标策略加载成Bean即可（作用范围：全局）</li><li>在application.yml配置文件中配置如下参数即可（作用范围：局部，在哪个微服务中配置就作用在其微服务）</li></ul></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 微服务名称</span></span><br><span class="line"><span class="attr">userService:</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.RandomRule</span> <span class="comment">#负载均衡规则</span></span><br></pre></td></tr></table></figure><ul><li>Ribbon默认是采用懒加载，即第一次访问时才会去创建LoadBalanceClient，请求时间会很长。而饥饿加载则会在项目启动时创建，降低第一次访问的耗时，通过下面配置开启饥饿加载。</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="attr">eager-load:</span></span><br><span class="line">    <span class="attr">clients:</span> <span class="string">userService</span>  <span class="comment">#指定对哪个服务进行饥饿加载</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment">#开启饥饿加载</span></span><br></pre></td></tr></table></figure><h1 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h1><p>概述：Nacos是阿里巴巴的产品，现在是SpringCloud中的一个组件。相比Eureka功能更加丰富，在国内受欢迎程度较高。安装自行百度</p><p>在Windows系统下启动Nacos命令：startup.cmd -m standalone</p><p>整合Nacos步骤如下</p><ol><li>在父工程引入所有的阿里巴巴的版本控制</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>在目标服务包下引入nacos的客户端</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- nacos客户端依赖包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>在目标服务包下修改配置</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#配置nacos服务器的地址</span></span><br></pre></td></tr></table></figure><ol start="4"><li>以上配置完成后，不用加任何的代码即可实现微服务间的请求负载均衡。</li></ol><h2 id="nacos的设置"><a href="#nacos的设置" class="headerlink" title="nacos的设置"></a>nacos的设置</h2><p>分级存储模型：分级模型就是将同种实例服务分布在不同地区的服务器中，避免一个服务器挂掉了使该实例服务不能提供服务的情况发生，所以一个服务实例通常会部署在不同的服务器上，每个地区的服务实例会进行一个集群，当本地的服务实例不能用时，会搜索其它地区的服务实例。</p><ol><li>集群配置</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"> <span class="attr">naocs:</span></span><br><span class="line"><span class="attr">discovery:</span></span><br><span class="line">   <span class="attr">cluster-name:</span> <span class="string">HZ</span> <span class="comment">#配置集群名称，以地名命名</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>NaocsRule负载均衡策略</p><ol><li>优先选择同集群服务实例列表</li><li>本地集群找不到提供者，才去其它集群寻找，并且会报警告</li><li>确定了可用实例列表后，再采用随机负载均衡挑选实例</li></ol></li><li><p>Naocs的实例权重设置</p><ol><li>Nacos控制台可以设置实例的权重值0~1之间</li><li>同集群内的多个实例，权重越高被访问的频率越高</li><li>权重设置为0则完全不会被访问</li></ol></li><li><p>Naocs的环境隔离</p><ol><li>namespace用来做环境隔离</li><li>每个namespace都有唯一id</li><li>不同namespace下的服务不可见（不同环境中的服务访问的话会报错，No instances available for userService）</li></ol></li></ol><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>nacos与eureka的整体原理差不多，服务提供者都要在注册中心进行一个注册，每隔一段时间注册中心都会进行一次服务的健康检测来检测一下服务提供者提供的服务是否可用，但nacos比eureka功能更完善，<strong>nacos和eureka的细节区别：</strong>nacos中存在临时实例和非临时实例，临时实例是存在服务列表缓存中，而服务消费者先从服务列表查找是否有自己需要的服务（读取缓存，速度更快）。服务消费者会定时从注册中心拉取服务，从而更新服务列表缓存，临时服务需要主动将自己的健康情况推送到注册中心中，若注册中心一定时间未检测到临时实例服务的健康情况，注册中心会将其服务去除掉，但非临时实例是相反的，注册中心会主动的询问非临时实例是否处于健康状态，就算是非健康状态注册中心也不会将其剔除，那以上的说法会产生一个新的问题，那就是当注册中心有一个临时实例挂掉了，但服务列表缓存未及时的更新，那么针对该问题，当有一个临时实例或非临时实例挂掉了，注册中心会主动将更新好的服务列表发送给服务消费者。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221211133647023.png" alt="image-20221211133647023"></p><h2 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h2><p>当nacos注册中心若存在很多的微服务，若需要进行系统升级，那每个微服务的配置都给重新配置，这样就会变得非常的麻烦，nacos提供了配置管理服务将所有的微服务同一配置管理，只要在配置管理修改配置参数，各个微服务再进行读取配置管理中的配置参数即可完成修改。那么如何实现呢？</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221211141202582.png" alt="image-20221211141202582"></p><p><strong>配置管理的实现步骤如下</strong></p><ol><li>第一步需要在nocas注册中心新建一个配置管理文件，步骤如下（最后点击发布即可）</li></ol><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221211143706538.png" alt="image-20221211143706538"></p><p>文件类型选择yaml类型</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221211144015549.png" alt="image-20221211144015549"></p><ol start="2"><li>如何让微服务读取到nacos中的配置文件呢？首先在目标服务实例中引入nacos的配置管理坐标</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入nacos的配置管理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其次在resource目录下新建一个bootsrap.yml文件，注意，该文件名称一定是这样命名的，因为bootsrap.yml配置文件加载的优先级比application.yml高，然后再文件中加上以下参数即可，当配置完成后可以用@Value注解读取配置文件中的信息。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">userService</span> <span class="comment">#服务名称</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span> <span class="comment"># 配置环境，这里的环境一定要与你在nacos注册中心文件命名的那个环境一样</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment"># 配置nacos的注册中心地址</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment"># 文件的后缀名</span></span><br></pre></td></tr></table></figure><p>从nacos中获取配置文件的信息整体流程如下</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221211150233950.png" alt="image-20221211150233950"></p><h3 id="nacos的配置自动更新（热更新）"><a href="#nacos的配置自动更新（热更新）" class="headerlink" title="nacos的配置自动更新（热更新）"></a>nacos的配置自动更新（热更新）</h3><p>概述：自动更新是不需要重启服务器就可以完成配置文件信息的更新</p><ul><li>方式一：使用注解@RefreshScope配合@value使用即可完成。@RefreshScope放在类上</li><li>方式二：使用注解@ConfigurationProperties完成自动更新。</li></ul><h3 id="nacos的文件加载优先级"><a href="#nacos的文件加载优先级" class="headerlink" title="nacos的文件加载优先级"></a>nacos的文件加载优先级</h3><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221211153109271.png" alt="image-20221211153109271"></p><h1 id="HTTP客户端Feign"><a href="#HTTP客户端Feign" class="headerlink" title="HTTP客户端Feign"></a>HTTP客户端Feign</h1><p>RestTemplate远程调用的问题：</p><ol><li><p>代码可读性差，编程体验不统一</p><ol start="2"><li>参数复杂URL难以维护</li></ol></li></ol><p>Feign的介绍：Feign是一个声明式的http客户端，其内部已经整合了ribbon，不用自己配置即可做到负载均衡，官方地址: <a href="https://github.com/OpenFeign/feign%E5%85%B6%E4%BD%9C%E7%94%A8%E5%B0%B1%E6%98%AF%E5%B8%AE%E5%8A%A9%E6%88%91%E4%BB%AC%E4%BC%98%E9%9B%85%E7%9A%84%E5%AE%9E%E7%8E%B0http%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8F%91%E9%80%81%EF%BC%8C%E8%A7%A3%E5%86%B3%E4%B8%8A%E9%9D%A2%E6%8F%90%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E3%80%82">https://github.com/OpenFeign/feign其作用就是帮助我们优雅的实现http请求的发送，解决上面提到的问题。</a></p><p><strong>Feigh的使用步骤如下</strong></p><ol><li>引入依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入fright依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>在启动类上开启feigh客户端驱动@EnableFeignClients</p></li><li><p>定义一个包专门来请求别的微服务模块，并编写接口如下图（注意@FeignClient()参数中不要加&#x2F;）</p></li></ol><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221215140003411.png" alt="image-20221215140003411"></p><ol start="4"><li>在业务层注入客户端的接口，如上的UserClient的bean即可直接调用接口中的方法完成微服务间的调用。</li></ol><p><strong>Fign的自定义配置</strong></p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221215141415617.png" alt="image-20221215141415617"></p><p><strong>Feign的日志配置</strong></p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221215141232182.png" alt="image-20221215141232182"></p><h2 id="Feign的性能优化"><a href="#Feign的性能优化" class="headerlink" title="Feign的性能优化"></a>Feign的性能优化</h2><p>Feign优化分为两个方面，第一Feign的日志级别不要开的太高，最好在BASIC级别即可，在日志这方面只有优化这个，第二在请求连接方面的优化。因为Feign默认的请求调用是不支持连接池的使用，每次都要创建请求和销毁请求，比较消耗性能，可以自己配置Feign的连接池，将请求连接交给连接池管理这样就不用每次请求都要进行创建和销毁，从而提高了性能，步骤如下</p><ol><li>引入依赖（使用HttpClient连接池）</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入fright的httpClient连接池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>修改配置文件，配置参数如下</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">httpclient:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment">#开启连接池的使用</span></span><br><span class="line">    <span class="attr">max-connections-per-route:</span> <span class="number">50</span> <span class="comment">#单个服务接口的最大连接数</span></span><br><span class="line">    <span class="attr">max-connections:</span> <span class="number">200</span> <span class="comment">#最大连接数</span></span><br><span class="line">    <span class="attr">time-to-live:</span> <span class="number">90</span> <span class="comment">#连接存活的时间，若超过90S未使用会自动取消连接</span></span><br></pre></td></tr></table></figure><h2 id="Feign的最佳实践"><a href="#Feign的最佳实践" class="headerlink" title="Feign的最佳实践"></a>Feign的最佳实践</h2><p>概述：Feign的远程调用中，服务消费者接口定义和服务提供者的接口定义必须一致，例如，参数个数等等，这样的用法修改起来比较麻烦，所有提供了以下两种思路</p><ol><li>继承：给消费者的FeignClient和提供者的controller定义统一的父接口作为标准。（耦合度高）</li></ol><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221215145243158.png" alt="image-20221215145243158"></p><ol start="2"><li>抽取：将Feign提供的调用接口抽取成一个微服务模块，然后让这个模块对外提供服务接口，供给服务消费者调用。</li></ol><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221215145213059.png" alt="image-20221215145213059"></p><p><strong>实现Feign的抽取步骤如下</strong></p><ol><li>创建一个新的微服务模块（maven模块）</li><li>将服务提供者和服务消费者所需要的实体类、配置和调用接口放在feign-api的服务模块中</li><li>在服务消费者的模块引入依赖，注意在这一步中需要在@EnableFeignClients中添加一个参数，否则会在Springboot启动时报Bean找不到的错误，该参数是可以让组件扫描到feign-api模块中，从而成功的加载Bean对象，如下</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients(clients = &#123;在feign-api模块中的接口.class&#125;)</span> <span class="comment">//将feign-api的接口加载到此服务模块中</span></span><br></pre></td></tr></table></figure><h1 id="Gateway网关"><a href="#Gateway网关" class="headerlink" title="Gateway网关"></a>Gateway网关</h1><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221215160258517.png" alt="image-20221215160258517"></p><p>在SpringCloud中网关的实现包括两种:</p><ul><li>gateway</li><li>zuul</li></ul><p>Zuul是基于Servlet的实现，属于阻塞式编程。而SpringCloudGateway则是基于Spring5中提供的WebFlux，属于响应式编程的实现，具备更好的性能。</p><h2 id="开发网关的步骤"><a href="#开发网关的步骤" class="headerlink" title="开发网关的步骤"></a>开发网关的步骤</h2><p>先创建一个新的maven模块，引入nacos和注册发现的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注册发现依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 路由 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改配置参数，基本的配置如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10011</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment"># nacos地址</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://userService</span> <span class="comment"># 以lb是LoadBalance 负载均衡</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/user/**</span> <span class="comment"># 只要请求路径中有user，则将该请求引导userService服务中</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">order-service</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://orderService</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/order/**</span></span><br></pre></td></tr></table></figure><p>当上面的步骤做完之后即可直接访问网关的路径，网关会给你的请求进行一个引导访问你需要的资源。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221224150013734.png" alt="image-20221224150013734"></p><h2 id="路由过滤器GatewayFilter的配置"><a href="#路由过滤器GatewayFilter的配置" class="headerlink" title="路由过滤器GatewayFilter的配置"></a>路由过滤器GatewayFilter的配置</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10011</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment"># nacos地址</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://userService</span> <span class="comment"># 以lb是LoadBalance 负载均衡</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/user/**</span> <span class="comment"># 只要请求路径中有user，则将该请求引导userService服务中</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">filters:</span></span><br><span class="line">        <span class="comment"># 局部过滤器</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">order-service</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://orderService</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/order/**</span></span><br><span class="line">      <span class="attr">default-filters:</span> <span class="comment"># 默认路由过滤器，会对所有的请求生效，若需要局部，可以在指定的路由下配置</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">AddRequestHeader=name,zhangsan</span></span><br></pre></td></tr></table></figure><h2 id="网关的全局过滤器"><a href="#网关的全局过滤器" class="headerlink" title="网关的全局过滤器"></a>网关的全局过滤器</h2><p>全局过滤器的作用是什么?</p><ol><li>对所有路由都生效的过滤器，并且可以自定义处理逻辑</li></ol><p>实现全局过滤器的步骤?</p><ol><li>实现GlobalFilter接口</li><li>添加@Order注解或实现Ordered接口</li><li>编写处理逻辑</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 请求访问权限过滤器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Order(-1)</span> <span class="comment">//过滤的优先级</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthorizationFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理用户的请求</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exchange：可以获取到用户的请求头或者是响应头进行处理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> chain：用来放行请求的</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> m</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">        <span class="comment">//1. 获取ServerHttpRequest对象</span></span><br><span class="line">        <span class="type">ServerHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> exchange.getRequest();</span><br><span class="line">        <span class="comment">//2. 获取请求头</span></span><br><span class="line">        MultiValueMap&lt;String, String&gt; queryParams = request.getQueryParams();</span><br><span class="line">        <span class="comment">//3. 从请求头中通过键取出值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">authorization</span> <span class="operator">=</span> queryParams.getFirst(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">        <span class="comment">//4. 判断该请求头是否是admin权限的用户</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;admin&quot;</span>.equals(authorization)) &#123;</span><br><span class="line">            <span class="comment">//是，放行</span></span><br><span class="line">            <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置一下状态码</span></span><br><span class="line">        exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">        <span class="comment">//否，拦截</span></span><br><span class="line">        <span class="keyword">return</span> exchange.getResponse().setComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>路由过滤器、defaultFilter、全局过滤器的执行顺序?</p><ul><li><p>order值越小，优先级越高</p></li><li><p>当order值一样时，顺序是defaultFilter最先，然后是局部的路由过滤器，最后是全局过滤器</p></li></ul><h2 id="跨域请求问题"><a href="#跨域请求问题" class="headerlink" title="跨域请求问题"></a>跨域请求问题</h2><p>引起原因：客户端和服务器的域名不同或者是端口号不同导致的，跨域问题是游览器不允许页面对不同的域进行一个ajax的请求，但在服务端中就不存在该问题了。如下图所示是属于跨域请求</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221229162011088.png" alt="image-20221229162011088"></p><p>解决方案：CORS</p><p>只需要在网关下配置如下参数即可解决</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">globalcors:</span> <span class="comment">#全局的跨域处理</span></span><br><span class="line">        <span class="attr">add-to-simple-url-handler-mapping:</span> <span class="literal">true</span> <span class="comment">#解决options请求被拦截问题corsConfigurations:</span></span><br><span class="line">          <span class="string">&#x27;[/**]&#x27;</span><span class="string">:</span></span><br><span class="line">            <span class="attr">allowedOrigins:</span>  <span class="comment">#允许哪些网站的跨域请求</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;http://logalhost:8090&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;http://www.leyou.com&quot;</span></span><br><span class="line">            <span class="attr">allowedMethods:</span> <span class="comment">#允许的跨域ajax的请求方式</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;GET&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;POST&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;DELETE&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;PUT&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;OPTIONS&quot;</span></span><br><span class="line">            <span class="attr">allowedHeaders:</span> <span class="string">&quot;*&quot;</span> <span class="comment">#允许在请求中携带的头信息</span></span><br><span class="line">            <span class="attr">allowCredentials:</span> <span class="literal">true</span> <span class="comment">#是否允许携带</span></span><br><span class="line">            <span class="attr">cookiemaxAge:</span> <span class="number">360000</span> <span class="comment">#这次跨域检测的有效期s</span></span><br></pre></td></tr></table></figure><h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><p><strong>项目部署问题：</strong>大型项目组件较多，运行环境也较为复杂，依赖关系复杂，容易出现兼容性问题。开发、测试、生产环境有差异</p><p><strong>Docker如何解决依赖兼容的问题？</strong></p><ul><li>Docker会将应用的Libs（函数库)、Deps（依赖)、配置与应用一起打包</li><li>将每个应用放到一个隔离容器去运行，避免互相干扰</li></ul><p>Docker是一个快速交付应用、运行应用技术。可以将程序及其依赖、运行环境一起打包为一个镜像，可以迁移到任意Linux操作系统，运行时利用沙箱机制形成隔离容器，各个应用互不干扰。启动、移除都可以通过一行命令完成，方便快捷</p><h2 id="Docker的架构"><a href="#Docker的架构" class="headerlink" title="Docker的架构"></a>Docker的架构</h2><p>Docker是采用C&#x2F;S的结构的程序，由两部分组成</p><ul><li>服务端(server)：Docker守护进程，负责处理Docker指令，管理镜像、容器等，DockerHup是Docker的服务器</li><li>客户端(client)：通过命令或RestAPI向Docker服务端发送指令。可以在本地或远程向服务端发送指令。</li></ul><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221229163742167.png" alt="image-20221229163742167"></p><h2 id="Docker的安装（Linux版本）"><a href="#Docker的安装（Linux版本）" class="headerlink" title="Docker的安装（Linux版本）"></a>Docker的安装（Linux版本）</h2><p>首先需要CentOS7的虚拟机</p><ol><li>安装yum的工具包，在控制台中输入以下命令即可</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils \</span><br><span class="line">          device-mapper-persistent-data \</span><br><span class="line">          lvm2 --skip-broken</span><br></pre></td></tr></table></figure><ol start="2"><li>更新本地镜像源</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager </span><br><span class="line">--add-repo \</span><br><span class="line">https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line">sed -i &#x27;s/down1oad.docker.com/mirrors.aliyun.com\/docker-ce/g&#x27; /etc/yum.repos.d/docker-ce.repo</span><br><span class="line"></span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure><ol start="3"><li>然后输入命令</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y docker-ce</span><br></pre></td></tr></table></figure><ol start="4"><li>安装完成后启动前需要关闭掉linux的防火墙，否则Docker会启动失败，关闭防火墙的命令如下</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭当前防火墙，但下一次开机会自启防火墙</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">永久关闭</span></span><br><span class="line">systemctl disable firewalld</span><br></pre></td></tr></table></figure><ol start="5"><li>启动Docker服务</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><ol start="6"><li>查看是否启动成功</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">若有版本号出现说明启动成功</span></span><br><span class="line">docker -v </span><br></pre></td></tr></table></figure><ol start="7"><li>因为Docker的服务器在国外，故下载速度很慢，可以配置到国内的服务器上（需要自己到阿里云官网去开通镜像服务）</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">先创建一个目录</span></span><br><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一个json文件</span></span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27; </span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://n0dwemtq.mirror.aliyunce.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启</span></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><h2 id="Docker的基本操作"><a href="#Docker的基本操作" class="headerlink" title="Docker的基本操作"></a>Docker的基本操作</h2><p><strong>镜像相关的命令如图所示</strong></p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221230095046053.png" alt="image-20221230095046053"></p><p>Docker的命令可以在控制台上进行查询通过如下命令即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker --help</span><br><span class="line">docker [具体的命令] --help</span><br></pre></td></tr></table></figure><p><strong>容器的相关命令</strong></p><p>docker exec：进入容器执行命令</p><p>docker logs：查看容器运行日志</p><p>docker ps：查看所有运行的容器及状态</p><p>docker rm：删除指定的容器</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221230101316509.png" alt="image-20221230101316509"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令解读</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker run：创建一个容器并运行</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--name containerName：起一个容器名称</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-p 80:80：端口映射，左是用户机的端口，右是服务器端口</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-d nginx：镜像名称</span></span><br><span class="line">docker run --name containerName -p 80:80 -d nginx</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令解读</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker <span class="built_in">exec</span> :进入容器内部，执行一个命令</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">it:给当前进入的容器创建一个标准输入、输出终端，允许我们与容器交互</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">mn :要进入的容器的名称</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">bash:进入容器后执行的命令，bash是一个linux终端交互命令</span></span><br><span class="line">docker exec -it mn bash</span><br></pre></td></tr></table></figure><p><strong>数据卷的相关命令</strong></p><p>数据卷的存在解决了：不便于修改，数据不可复用，升级维护困难</p><p>数据卷就是和容器内部的文件的映射，当数据卷修改时容器内部的文件也会修改。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker volume [comment]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">comment有如下选择</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">create：创建一个volume</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">inspect：显示一个或多个volume的信息</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ls</span>：列出所有的volume</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">prune：删除未使用的volume</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">rm</span>：删除一个或多个指定的volume</span></span><br></pre></td></tr></table></figure><p><strong>挂载数据卷</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在创建并运行容器时加上-v volumeName: /targetContainerPath即可,当volumeName不存在，会自动创建</span></span><br><span class="line">docker run --name containerName -p 80:80 -v volumeName: /targetContainerPath -d nginx</span><br></pre></td></tr></table></figure><h2 id="自定义镜像"><a href="#自定义镜像" class="headerlink" title="自定义镜像"></a>自定义镜像</h2><p><strong>镜像结构是分层的结构，每一层都有自己的配置</strong></p><p>Baselmage层：包含基本的系统函数库、环境变量、文件系统</p><p>Entrypoint：入口，是镜像中应用启动的命令</p><p>其它在Baselmage基础上添加依赖、安装程序、完成整个应用的安装和配置</p><p><strong>自定义镜像的步骤如下</strong></p><ol><li><p>首先定义一个自定义文件，该文件是描述镜像构建的过程</p></li><li><p>该文件的第一行必须是FROM，是从哪一层开始构建的</p></li><li><p>基础镜像可以是ubuntu也可以是别构建好的镜像java:8-alpine</p></li><li><p>准备好项目运行的压缩包并放到同一目录中</p></li><li><p>最后运行如下命令即可构建一个镜像</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t imageName:version .</span><br></pre></td></tr></table></figure><p><strong>自定义文件的构建</strong></p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221230170937335.png" alt="image-20221230170937335"></p><p>自动补全命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -L \</span><br><span class="line">https://raw.githubusercontent.com/docker/compose/1.29.1/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose</span><br></pre></td></tr></table></figure><p>修改域名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;199.232.68.133 raw.githubusercontent.com&quot; &gt;&gt; /etc/hosts</span><br></pre></td></tr></table></figure><h2 id="镜像仓库"><a href="#镜像仓库" class="headerlink" title="镜像仓库"></a>镜像仓库</h2><ul><li><p>公有仓库：DockerHub–&gt;<a href="https://hub.docker.com/">Docker</a></p></li><li><p>私有仓库：需要自己搭建</p></li></ul><p><strong>搭建私有仓库的步骤如下</strong></p><ol><li>首先创建一个文件取名：docker-compose.yml</li><li>在配置一下daemen.json的文件，顺序执行以下命令即可，目的是为了让你创建的仓库被信任</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打开要修改的文件</span></span><br><span class="line">vi /etc/docker/daemon.json</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加内容：端口号是自己电脑或虚拟机的ip</span></span><br><span class="line">&quot;insecure-registries&quot;:[&quot;http://192.168.177.131:8088&quot;] </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重加载</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启docker</span></span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><ol start="3"><li>在docker-compose.yml中的内容如下</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">version: &#x27;3.0&#x27;</span><br><span class="line">services:</span><br><span class="line">  registry:</span><br><span class="line">    image: registry</span><br><span class="line">    volumes:</span><br><span class="line">      - ./registry-data:/var/lib/registry</span><br><span class="line">  ui:</span><br><span class="line">    image: joxit/docker-registry-ui:static</span><br><span class="line">    ports:</span><br><span class="line">      - 8088:80 # 左边的端口号是为了让外界访问此仓库的，可以修改</span><br><span class="line">    environment: </span><br><span class="line">      - REGISTRY_TITLE=RegistryOfMysties # 可以顺便起个仓库名称</span><br><span class="line">      - REGISTRY_URL=http://registry:5000</span><br><span class="line">    depends_on:</span><br><span class="line">      - registry</span><br></pre></td></tr></table></figure><ol start="4"><li>但上面的配置做完之后，再执行以下命令启动</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看启动日志</span></span><br><span class="line">docker-compose logs -f</span><br></pre></td></tr></table></figure><ol start="5"><li>然后在游览器访问</li></ol><p><strong>私有仓库镜像的相关操作</strong></p><p>推送镜像到私有镜像服务必须先tag，步骤如下：</p><ol><li>重新命名镜像名称，名称前缀是私有仓库的ip，例如：192.168.177.131:8088&#x2F;</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag nginx:latest 192.168.177.131:8088/nginx:1.0</span><br></pre></td></tr></table></figure><ol start="2"><li>推送本地镜像到私有仓库</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push 192.168.177.131:8088/nginx:1.0</span><br></pre></td></tr></table></figure><ol start="3"><li>从私有仓库中拉取镜像</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull 192.168.177.131:8088/nginx:1.0</span><br></pre></td></tr></table></figure><h1 id="MQ（MessageQueue）"><a href="#MQ（MessageQueue）" class="headerlink" title="MQ（MessageQueue）"></a>MQ（MessageQueue）</h1><p><strong>同步调用：</strong>就是每增加一个新的业务时，都需要新增一个远程调用到其它的微服务实例上，所以该调用方式存在的问题，耦合度高，性能下降，资源浪费，级联失败。</p><p>异步调用会解决同步调用的问题，单异步也有缺点：依赖于Broker的可靠性、安全性、吞吐能力，架构复杂了，业务没有明显的流程线，不好追踪管理</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221231141749235.png" alt="image-20221231141749235"></p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221231142431990.png" alt="image-20221231142431990"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;认识微服务&quot;&gt;&lt;a href=&quot;#认识微服务&quot; class=&quot;headerlink&quot; title=&quot;认识微服务&quot;&gt;&lt;/a&gt;认识微服务&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;单体架构：将业务的所有功能集中在一个项目中开发，打成一个包部署。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：</summary>
      
    
    
    
    
    <category term="springcloud" scheme="http://example.com/tags/springcloud/"/>
    
  </entry>
  
  <entry>
    <title>java模拟进程运行</title>
    <link href="http://example.com/2022/11/23/java%E6%A8%A1%E6%8B%9F%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C/"/>
    <id>http://example.com/2022/11/23/java%E6%A8%A1%E6%8B%9F%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C/</id>
    <published>2022-11-23T12:09:00.000Z</published>
    <updated>2022-12-09T07:45:46.342Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java模拟进程程序流程图和概述"><a href="#java模拟进程程序流程图和概述" class="headerlink" title="java模拟进程程序流程图和概述"></a>java模拟进程程序流程图和概述</h1><ul><li><p>进程的概述</p><p>​进程是正在执行的程序是动态资源，而程序是静态资源，进程运行需要占用CPU的使用权，进程中有多个线程，进程中的资源可以被多个线程共享。更多详情请看java基础中的并发编程</p></li><li><p>进程并发执行</p><p>​进程并发执行可以从两个角度进行说明：</p><p>​宏观角度： 进程的并发性是指一组进程的执行在时间上是重叠的。所谓执行在时间上是重叠的，是指一个进程执行的第一条指令是在另一个进程执行的最后一条指令完成之前开始的。例如，现有进程A和进程B分别执行（a1，a2，a3）和（b1，b2，b3）这六个资源，在单处理机上这六个资源是交叉顺序执行的，假设进程A执行完a1后，CPU的使用权被进程B占用，进程B就开始执行b1，依次推理，可能的执行顺序是：a1 ，b1，a2，b2，b3，a4 等多种情况，并且程序运行是非常快的，所以给人一种错觉，进程是并发执行的。</p><p>​微观角度： 在单处理机上，处理机只能处理一个进程，反过来看，并发的实质是对一个处理机对多个进程之间的多路复用。（若个人理解有错，望纠正Thanks♪(･ω･)ﾉ）</p></li><li><p>进程执行的三种基本状态</p><p>​在进程中有执行、就绪、堵塞这三种基本状态。如下图所示</p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221123212927162.png" alt="image-20221123212927162" style="zoom:50%;" /><p>​在本次模拟只模拟进程的从就绪状态到执行状态。</p></li><li><p>java模拟进程执行流程图</p><p>​思路简要说明：采用优先队列当做就绪队列，假设进程是以优先级高的先执行，优先级相等的采用FIFO法顺序执行，关于进程优先级可以百度了解（dogs）</p></li></ul><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/4BDVW7FQK76GRC~63BEPRXO.png" alt="4BDVW7FQK76GRC~63BEPRXO" style="zoom: 80%;" /><ul><li>java代码实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  模拟多进程运行</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@author</span> mysticBoy</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@creatTime</span> 2022/11/21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PCB_Experiment</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;PCB&gt; pcbs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 创建进程的数量</span></span><br><span class="line">        pcbs.add(<span class="keyword">new</span> <span class="title class_">PCB</span>(<span class="string">&quot;进程1&quot;</span>,<span class="number">10</span>,<span class="number">45</span>,<span class="number">0</span>));</span><br><span class="line">        pcbs.add(<span class="keyword">new</span> <span class="title class_">PCB</span>(<span class="string">&quot;进程2&quot;</span>,<span class="number">5</span>,<span class="number">30</span>,<span class="number">0</span>));</span><br><span class="line">        pcbs.add(<span class="keyword">new</span> <span class="title class_">PCB</span>(<span class="string">&quot;进程3&quot;</span>,<span class="number">7</span>,<span class="number">40</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 创建进程的执行对象并将进程放入到进程执行中</span></span><br><span class="line">        <span class="type">PcbExecute</span> <span class="variable">execute</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PcbExecute</span>(pcbs);</span><br><span class="line">        <span class="comment">// 进程执行</span></span><br><span class="line">        execute.executing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 进程执行类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PcbExecute</span>&#123;</span><br><span class="line">    <span class="comment">//就绪队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;PCB&gt; queue;</span><br><span class="line">    <span class="comment">//初始化队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PcbExecute</span><span class="params">(List&lt;PCB&gt; pcbList)</span> &#123;</span><br><span class="line">        queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;( <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;PCB&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(PCB o1, PCB o2)</span> &#123;</span><br><span class="line">                <span class="comment">//队列以进程优先级数进行排序</span></span><br><span class="line">                <span class="keyword">return</span> o2.getPriority() - o1.getPriority();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 将进程列表中的加入到队列中</span></span><br><span class="line">        queue.addAll(pcbList);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 进程执行方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executing</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 获取队列的迭代器</span></span><br><span class="line">        Iterator&lt;PCB&gt; iterator = queue.iterator();</span><br><span class="line">        <span class="comment">// 通过迭代器遍历队列中的每个进程</span></span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="comment">// 1. 获取出优先级最高的进程</span></span><br><span class="line">            <span class="type">PCB</span> <span class="variable">currPcb</span>  <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">assert</span> currPcb != <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 2. 减少当前进程的优先级</span></span><br><span class="line">            currPcb.setPriority(currPcb.getPriority() - <span class="number">3</span>);</span><br><span class="line">            <span class="comment">// 4. 判断该进程是否执行完毕 即 totalTime 是否执行完</span></span><br><span class="line">            <span class="keyword">if</span>(currPcb.getTotalTime() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 4.1 减少当前进程的所需运行时间片数</span></span><br><span class="line">                currPcb.setTotalTime(currPcb.getTotalTime() - <span class="number">1</span>);</span><br><span class="line">                currPcb.setOccupyTime(currPcb.getOccupyTime() + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 4.2 修改进程的状态</span></span><br><span class="line">                currPcb.setState(<span class="number">3</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 说明当前进程结束</span></span><br><span class="line">                currPcb.setState(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 直接将该进程加回就绪队列中</span></span><br><span class="line">            queue.add(currPcb);</span><br><span class="line">            <span class="comment">// 打印进程的信息</span></span><br><span class="line">            queue.forEach(pcb -&gt; &#123;</span><br><span class="line">                <span class="keyword">switch</span> (pcb.getState()) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                        System.out.println(pcb.getPcbName() + <span class="string">&quot;-&gt;已结束...  &quot;</span> + <span class="string">&quot;  需要时间片：&quot;</span> + pcb.getTotalTime()</span><br><span class="line">                           + <span class="string">&quot;  占用CPU时间片：&quot;</span> + pcb.getOccupyTime() + <span class="string">&quot;  优先级：&quot;</span> + pcb.getPriority());</span><br><span class="line">                        <span class="comment">// 将结束的进程从就绪队列中移除</span></span><br><span class="line">                        queue.remove(pcb);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                        System.out.println(pcb.getPcbName()+<span class="string">&quot;-&gt;就绪中...  &quot;</span> +<span class="string">&quot;  需要时间片：&quot;</span> + pcb.getTotalTime()</span><br><span class="line">                          + <span class="string">&quot;  占用CPU时间片：&quot;</span> + pcb.getOccupyTime() + <span class="string">&quot;  优先级：&quot;</span> + pcb.getPriority());</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                        System.out.println(pcb.getPcbName()+<span class="string">&quot;-&gt;运行中...  &quot;</span> +<span class="string">&quot;  需要时间片：&quot;</span> + pcb.getTotalTime()</span><br><span class="line">                           + <span class="string">&quot;  占用CPU时间片：&quot;</span> + pcb.getOccupyTime() + <span class="string">&quot;  优先级：&quot;</span> + pcb.getPriority());</span><br><span class="line">                        pcb.setState(<span class="number">2</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">      System.out.println(<span class="string">&quot;============================================================&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 进程类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PCB</span>&#123;</span><br><span class="line">    <span class="comment">// 进程名称</span></span><br><span class="line">    <span class="keyword">private</span> String pcbName;</span><br><span class="line">    <span class="comment">// 进程状态：0——结束，1——等待，2——就绪，3——运行</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">state</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 进程执行所需的时间片数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> totalTime;</span><br><span class="line">    <span class="comment">// 优先级：优先级越高，就优先执行</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> priority;</span><br><span class="line">    <span class="comment">// 进程占用CPU总时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> occupyTime;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PCB</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PCB</span><span class="params">(String pcbName, <span class="type">float</span> totalTime, <span class="type">int</span> priority, <span class="type">float</span> occupyTime)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.pcbName = pcbName;</span><br><span class="line">        <span class="built_in">this</span>.totalTime = totalTime;</span><br><span class="line">        <span class="built_in">this</span>.priority = priority;</span><br><span class="line">        <span class="built_in">this</span>.occupyTime = occupyTime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPcbName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pcbName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPcbName</span><span class="params">(String pcbName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.pcbName = pcbName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">getTotalTime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> totalTime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTotalTime</span><span class="params">(<span class="type">float</span> totalTime)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.totalTime = totalTime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getPriority</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> priority;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPriority</span><span class="params">(<span class="type">int</span> priority)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.priority = priority;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">getOccupyTime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> occupyTime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOccupyTime</span><span class="params">(<span class="type">float</span> occupyTime)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.occupyTime = occupyTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行结果如下图（由于运行结果太多只截取一部分）</li></ul><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221123214808069.png" alt="image-20221123214808069"></p><ul><li>总结：在微观角度中进程是逐个交叉运行的方式。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;java模拟进程程序流程图和概述&quot;&gt;&lt;a href=&quot;#java模拟进程程序流程图和概述&quot; class=&quot;headerlink&quot; title=&quot;java模拟进程程序流程图和概述&quot;&gt;&lt;/a&gt;java模拟进程程序流程图和概述&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;进程的概述</summary>
      
    
    
    
    
    <category term="java，进程，多线程" scheme="http://example.com/tags/java%EF%BC%8C%E8%BF%9B%E7%A8%8B%EF%BC%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>java基础（节选）</title>
    <link href="http://example.com/2022/11/23/java%E5%9F%BA%E7%A1%80%EF%BC%88%E8%8A%82%E9%80%89%EF%BC%89/"/>
    <id>http://example.com/2022/11/23/java%E5%9F%BA%E7%A1%80%EF%BC%88%E8%8A%82%E9%80%89%EF%BC%89/</id>
    <published>2022-11-22T16:00:00.000Z</published>
    <updated>2023-01-24T06:14:01.552Z</updated>
    
    <content type="html"><![CDATA[<h1 id="异常的作用"><a href="#异常的作用" class="headerlink" title="异常的作用"></a>异常的作用</h1><ol><li>提高程序的健壮性和安全性。</li><li>可以处理代码问题，防止程序出现问题后的死亡。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 程序校验年龄是否正确</span></span><br><span class="line">                <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">                System.out.print(<span class="string">&quot;请输入年龄：&quot;</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">                <span class="keyword">if</span>(age &lt; <span class="number">0</span> || age &gt; <span class="number">200</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;输入正确：&quot;</span> + age);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;年龄输入错误~~&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221123145110280.png" alt="image-20221123145110280"></p><ol start="3"><li>以上代码就是异常的实用之处，可以让出现异常的代码继续执行。</li></ol><h1 id="多线程和并发编程"><a href="#多线程和并发编程" class="headerlink" title="多线程和并发编程"></a>多线程和并发编程</h1><h2 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程?"></a>什么是进程?</h2><p>​程序是静止的，运行中的程序就是进程。</p><p>​进程的三个特征:</p><ol><li><p>动态性： 进程是运行中的程序，要动态的占用内存，CPU和网络等资源。</p></li><li><p>独立性： 进程与进程之间是相互独立的，彼此有自己的独立内存区域。</p></li><li><p>并发性： 假如CPu是单核，同一个时刻其实内存中只有一个进程在被执行。CPU会分时轮询切换依次为每个进程服务，因为切换的速度非常快，给我们的感觉这些进程在同时执行，这就是并发性。</p><p>并行： 同一个时刻同时有多个在执行。</p></li></ol><h2 id="什么是线程？"><a href="#什么是线程？" class="headerlink" title="什么是线程？"></a>什么是线程？</h2><ol><li><p>线程是属于进程的。</p></li><li><p>一个进程可以包含多个线程，这就是多线程。线程是进程中的一个独立执行单元。</p></li><li><p>线程创建开销相对于进程来说比较小。线程也支持并发性。</p><p>线程的作用:</p><ol><li>可以提高程序的效率，线程也支持并发性，可以有更多机会得到CPU。多线程可以解决很多业务模型。</li><li>大型高并发技术的核心技术。</li><li>设计到多线程的开发可能都比较难理解。</li></ol></li></ol><h2 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h2><h3 id="继承Thread类创建（方式一）"><a href="#继承Thread类创建（方式一）" class="headerlink" title="继承Thread类创建（方式一）"></a>继承Thread类创建（方式一）</h3><ol><li><p>定义一个线程类继承并继承Thread类</p></li><li><p>重写run方法，在run方法中可以编写代码业务</p></li><li><p>创建该线程对象</p></li><li><p>调用对象中的start()方法，开启新的线程并执行业务</p><p>继承Thread的缺点：</p><p> 优点：编码简单</p><p> 缺点：线程类已经继承了Thread类无法继承其他类了，功能不能通过继承拓展（单继承）</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="comment">// 1. main是一个主进程，在main中可以运行多个线程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建线程对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">myThread</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="comment">//开启线程：start会给myThread注册进入CPU中，会与主进程竞争CPU的执行权</span></span><br><span class="line">        myThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;主进程：&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建一个线程类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="comment">//重写run方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;分支线程：&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现Runnable接口创建线程（方式二）"><a href="#实现Runnable接口创建线程（方式二）" class="headerlink" title="实现Runnable接口创建线程（方式二）"></a>实现Runnable接口创建线程（方式二）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//3. 创建MyRunnable对象</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">run</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">        <span class="comment">//4. 创建Thread方法执行线程业务</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(run,<span class="string">&quot;run1&quot;</span>);</span><br><span class="line">        <span class="comment">//开启线程任务</span></span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1. 定义一个类实现Runnable接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">//2. 重写run方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>缺点:代码复杂一点。</p></li><li><p>优点：<br>避免了单继承的局限性</p><p>同一个线程任务对象可以被包装成多个线程对象</p><p>适合多个多个线程去共享同一个资源</p><p>实现解耦操作，线程任务代码可以被多个线程共享，线程任务代码和线程独立。</p><p>线程池可以放入实现Runable或callable线程任务对象。</p><p>注意：    其实Thread类本身也是实现了Runnable接口的。</p></li></ol><h3 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h3><ol><li>线程安全的说明：如下图</li></ol><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221123155806551.png" alt="image-20221123155806551"></p><ol start="2"><li>上图解析：假设小明和小红的账户余额为100000，当小明和小红一起去银行取钱，那么小明和小红取钱的行为可以看成两个进程进行取钱的操作，由于进程的并发性和CPU执行权的随机分配，会导致程序执行判断小明账户是否有余额，这时为true并且账户余额未被取出，这时小红也来取钱，程序的执行权被小红占用，这时判断是否有余额，也是true，然后小明和小红在同一个账户取了两次的钱，这就发生了线程安全问题。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  线程安全问题的演示</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 账户类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> cardId;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> money;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="comment">//判断是谁来取钱</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">        <span class="comment">//判断是否还有余额</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.money &gt;= money) &#123;</span><br><span class="line">            <span class="comment">//还有余额</span></span><br><span class="line">            System.out.println(name + <span class="string">&quot;取出 &quot;</span> + money);</span><br><span class="line">            <span class="comment">//扣减余额</span></span><br><span class="line">            <span class="built_in">this</span>.money = <span class="built_in">this</span>.money - money;</span><br><span class="line">            System.out.println(<span class="string">&quot;余额剩余：&quot;</span> + <span class="built_in">this</span>.money);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//余额不足</span></span><br><span class="line">            System.out.println(<span class="string">&quot;余额不足...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(<span class="type">long</span> cardId, <span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cardId = cardId;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getCardId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cardId;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCardId</span><span class="params">(<span class="type">long</span> cardId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cardId = cardId;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//取钱的线程类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DrawingMoney</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Account account;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DrawingMoney</span><span class="params">(Account account,String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.account = account;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//取钱的业务</span></span><br><span class="line">        account.drawMoney(account.getMoney());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PCBSecurity</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//初始化一个账户</span></span><br><span class="line">        <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>(<span class="number">101</span>,<span class="number">10000</span>);</span><br><span class="line">        <span class="comment">//小明来取钱的线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">xiaoming</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DrawingMoney</span>(account,<span class="string">&quot;小明&quot;</span>);</span><br><span class="line">        xiaoming.start();</span><br><span class="line">        <span class="comment">//小红来取钱</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">xiaohong</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DrawingMoney</span>(account,<span class="string">&quot;小红&quot;</span>);</span><br><span class="line">        xiaohong.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​<strong>运行结果如下</strong></p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221123163012728.png"></p><h3 id="解决线程安全问题"><a href="#解决线程安全问题" class="headerlink" title="解决线程安全问题"></a>解决线程安全问题</h3><ol><li>同步代码块锁synchronized(this)：在共享资源加同步锁，以保证小明和小红能逐个从账户中取钱，代码如下，其中this对象必须保证唯一性，来保证锁的唯一</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">    <span class="comment">//判断是谁来取钱</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">    <span class="comment">//账户类就是共享资源，已账户类为加锁的标志，同一个账户只能有一个人进来取钱</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">       <span class="comment">//判断是否还有余额</span></span><br><span class="line">       <span class="keyword">if</span>(<span class="built_in">this</span>.money &gt;= money) &#123;</span><br><span class="line">           <span class="comment">//还有余额</span></span><br><span class="line">           System.out.println(name + <span class="string">&quot;取出 &quot;</span> + money);</span><br><span class="line">           <span class="comment">//扣减余额</span></span><br><span class="line">           <span class="built_in">this</span>.money = <span class="built_in">this</span>.money - money;</span><br><span class="line">           System.out.println(<span class="string">&quot;余额剩余：&quot;</span> + <span class="built_in">this</span>.money);</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//余额不足</span></span><br><span class="line">           System.out.println(<span class="string">&quot;余额不足...&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221123165517823.png" alt="image-20221123165517823"></p><ol start="2"><li><p>同步方法：在对操作共享资源的方法上加上synchronized即可加锁，在方法执行完毕后，自动释放锁。</p><p>原理： 同步方法的原理和同步代码块的底层原理其实是完全一样的，只是同步方法是把整个方法的代码都锁起来的。同步方法上锁的范围比同步代码块大，而且加锁的范围太大会大大降低执行的性能，故在加锁时可以优先考虑同步代码块，加锁范围越精确，对性能影响就越小<br>    同步方法其实底层也是有锁对象的:<br>        如果方法是实例方法：同步方法默认用this作为的锁对象。<br>        如果方法是静态方法：同步方法默认用类名.class作为的锁对象。</p></li><li><p>Lock锁方法：</p><p>​Lock锁的优点：上锁的灵活性更好。</p><p>注意：  使用该方法上锁一定需要把解锁放到finnally的代码块中。因为在finnally中无论是否出现异常都会执行，所以在finnally可以保证解锁的操作，防止死锁的出现</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> cardId;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> money;</span><br><span class="line">    <span class="comment">//创建一个lock锁对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="comment">//判断是谁来取钱</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">        <span class="comment">//上锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//判断是否还有余额</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.money &gt;= money) &#123;</span><br><span class="line">                <span class="comment">//还有余额</span></span><br><span class="line">                System.out.println(name + <span class="string">&quot;取出 &quot;</span> + money);</span><br><span class="line">                <span class="comment">//扣减余额</span></span><br><span class="line">                <span class="built_in">this</span>.money = <span class="built_in">this</span>.money - money;</span><br><span class="line">                System.out.println(<span class="string">&quot;余额剩余：&quot;</span> + <span class="built_in">this</span>.money);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//余额不足</span></span><br><span class="line">                System.out.println(<span class="string">&quot;余额不足...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//解锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(<span class="type">long</span> cardId, <span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cardId = cardId;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getCardId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cardId;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCardId</span><span class="params">(<span class="type">long</span> cardId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cardId = cardId;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221124160355767.png" alt="image-20221124160355767"></p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><ol><li>概述： 线程池是一个可以容纳多个线程的容器，其中的线程可以被反复的使用，从而减少了对线程对象的创建和销毁，提高了系统资源的利用率，防止创建过多的线程而导致系统的僵死。</li><li>核心思想： 线程复用。</li><li>以下代码是最基本的线程池用法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="comment">//创建一个线程池，其中的参数是创建几个线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建线任务对象</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="comment">//将任务加入线程池中，线程池会自动帮我们创建新的线程去执行任务</span></span><br><span class="line">        pool.submit(task);</span><br><span class="line">        pool.submit(task);</span><br><span class="line">        pool.submit(task); <span class="comment">//注意：此时的线程是复用前面创建的线程，因为在pool中只有2个线程</span></span><br><span class="line">         <span class="comment">// 关闭线程池</span></span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义一个线程任务类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//线程任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221124170402567.png" alt="image-20221124170402567"></p><ol start="4"><li>在上图的运行结果可以看出线程池中始终只有两个线程在执行，分别是thread-1和thread-2</li></ol><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><ol><li><p>概述： 死锁是程序执行中的一种情况，多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p></li><li><p>死锁产生的四个必要条件</p><p>（1）互斥使用，即当资源被一个线程使用(占有)时，别的线程不能使用。</p><p>（2）不可抢占，资源请求者不能强制从资源占有者手中夺取资源，资源只能由资源占有者主动释放。</p><p>（3）请求和保持，即当资源请求者在请求其他的资源的同时保持对原有资源的占有。</p><p>（4）循环等待，即存在一个等待循环队列，p1要p2的资源，p2要p1的资源。这样就形成了一个等待环路</p><p>当上述四个条件都成立的时候，便形成死锁。当然，死锁的情况下如果打破上述任何一个条件，便可让死锁消失</p></li><li><p>以下是死锁的代码演示</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 死锁问题：死锁问题常产生在嵌套加锁上</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeathLock</span> &#123;</span><br><span class="line">    <span class="comment">//定义两个资源</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">source1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">source2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//这里使用匿名内部类实现线程的执行</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123; <span class="comment">//第一个线程</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (source1)&#123;</span><br><span class="line">                    <span class="comment">//拿到资源1</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;线程1拿到资源1，请求资源2&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//因为产生死锁是概率问题，故为了100%产生死锁，让该线程休眠1s，让线程2可以执行</span></span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">synchronized</span> (source2) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;线程1拿到资源2，可以释放资源了&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123; <span class="comment">//第二个线程</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (source2)&#123;</span><br><span class="line">                    <span class="comment">//拿到资源1</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;线程2拿到资源2，请求资源1&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//因为产生死锁是概率问题，故为了100%产生死锁，让该线程休眠1s，让线程1可以执行</span></span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">synchronized</span> (source1) &#123; </span><br><span class="line">                        System.out.println(<span class="string">&quot;线程2拿到资源1，可以释放资源了&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>运行结果</li></ol><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221124174017855.png" alt="image-20221124174017855"></p><h2 id="并发环境下，多线程访问变量的不可见性"><a href="#并发环境下，多线程访问变量的不可见性" class="headerlink" title="并发环境下，多线程访问变量的不可见性"></a>并发环境下，多线程访问变量的不可见性</h2><ol><li>概述： 多个线程访问同一个变量，会出现器中一个线程修改变量的值后，其它线程看不到变量的最新值。以下代码可以说明该问题，在以下代码中MyThread子线程是先执行的，理论上应该先将flag &#x3D; true，而主线程会一直打印hello world…，然而结果并非如此。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; <span class="comment">//执行线程任何</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//这里是为了模拟业务代码的执行了一段时间后</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        flag = <span class="literal">true</span>; <span class="comment">//改变flag标志</span></span><br><span class="line">        System.out.println(<span class="string">&quot;flag已经变为true了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFlag</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFlag</span><span class="params">(<span class="type">boolean</span> flag)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.flag = flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnableVision</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个子线程对象并开启线程任务的执行</span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        t.start();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//休眠，保证子线程先执行</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//主线程执行的任务</span></span><br><span class="line">        <span class="keyword">while</span> (t.isFlag()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello world...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>代码运行结果如下：可以看出在主线程中读取的flag并不为true，但子线程已将flag置为true了，这就是多线程下对共同变量值的不可见性（概率问题）。</li></ol><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221124204337248.png" alt="image-20221124204337248"></p><h3 id="多线程中变量不可见性的原因"><a href="#多线程中变量不可见性的原因" class="headerlink" title="多线程中变量不可见性的原因"></a>多线程中变量不可见性的原因</h3><p>​JVM虚拟机对多线程内存作以下规定</p><ul><li>所有的共享变量都存储于主内存。这里所说的变量指的是实例变量和类变量。不包含局部变量，因为局部变量是线程私有的，因此不存在竞争问题。</li><li>每一个线程还存在自己的工作内存，线程的工作内存，保留了被线程使用的变量的工作副本。</li><li>线程对变量的所有的操作(读，取)都必须在工作内存中完成，而不能直接读写主内存中的变量。</li><li>不同线程之间也不能直接访问对方工作内存中的变量，线程间变量的值的传递需要通过主内存中转来完成。</li></ul><p><strong>下图是本地内存和主内存的关系</strong></p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221124210145669.png" alt="image-20221124210145669" style="zoom:67%;" /><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221124210500313.png" alt="image-20221124210500313" style="zoom:67%;" /><p>个人解读： 在第二张图中，首先变量flag在主内存中默认为false，随后键flag分配到子线程和主线程工作内存中，这时各线程的flag是为false值，其次子线程t执行后将flag改为true，将其返回主内存中，此时主内存flag也是true，但由于JVM的规定，主线程中的工作内存中的flag仍为false，所有在主线程执行时读取的速度非常快，还来不及将flag值更新，主线程就已经读取了旧值，就导致了多线程下变量的不可见性。</p><p>​总结：并发编程下，多线程修改变量，会出现线程间变量的不可见性。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li>加锁：因为加锁的操作会清空工作内存中的值，从主内存中读取最新的值，如下代码，给主线程加锁后会清空工作内存，从而使主线程从主内存中读取读取最小的flag值，就可以触发hello world的打印</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主线程执行的任务</span></span><br><span class="line"><span class="keyword">synchronized</span> (UnableVision.class) &#123; </span><br><span class="line">    <span class="keyword">while</span> (t.isFlag()) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221124213059050.png" alt="image-20221124213059050"></p><ol start="2"><li>用volatile修饰公共变量</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>​原理图如下</p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221124213834640.png" alt="image-20221124213834640" style="zoom:67%;" /><p>个人解读：volatile关键字并不是将个线程的工作内存清空，而是在某个线程中改变了共同变量值后，有volatile关键字修饰的变量就会通知其它线程该变量更新了，你那个变量是旧值，然后线程会将该变量视为失效的变量值，再从主内存中读取最新值，从而实现各个线程之间变量的可见性。</p><ol start="3"><li><p>volatile与synchronized的区别</p><p>volatile只能修饰实例变量和类变量，而synchronized可以修饰方法，以及代码块。</p><p>volatile保证数据的可见性，但是不保证原子性(多线程进行写操作，不保证线程安全);</p><p>而synchronized是一种排他(互斥)的机制，可以保证线程安全。</p></li></ol><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><ol><li>概述：原子性就是一批程序操作看成一个整体，要么执行，要么不执行。</li><li>以下代码是证明volatile不能保证原子性（线程安全问题），以下代码执行的结果理论上count应该为10000，但结果却是不到10000，这是属于线程任务未全执行完成导致的，故volatile并不能保证原子性。该运行结果是概率问题，多运行几次会出现不同的效果。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建线程对象</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VThread</span>();</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">           <span class="comment">//启动子线程100次</span></span><br><span class="line">           <span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">           count ++;</span><br><span class="line">           System.out.println(<span class="string">&quot;count=&quot;</span> + count);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221125195603121.png" alt="image-20221125195603121"></p><h3 id="保证原子性的方案"><a href="#保证原子性的方案" class="headerlink" title="保证原子性的方案"></a>保证原子性的方案</h3><ol><li><p>加锁</p><p>优点：实现简单</p><p>缺点：在高并发的环境下性能会变差</p><p>如下的代码是再循环加前加上一个同步代码块锁，即可保证原子性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        System.out.println(<span class="string">&quot;count=&quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221126103607905.png" alt="image-20221126103607905"></p><ol start="2"><li><p>使用原子类</p><p>Atomiclnteger是JDK1.5版本后提供的原子类，该类的API接口可以查看API文档。</p><p>优点：性能高效，线程安全</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个原子类，其中参数是默认值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// incrementAndGet()是自动加1 并返回值</span></span><br><span class="line">            System.out.println(<span class="string">&quot;count=&quot;</span> + count.incrementAndGet());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221126104410355.png" alt="image-20221126104410355"></p><ol start="3"><li><p>原子类底层原理</p><p>在原子类源码中并不是一加锁的形式保证原子性的，而是利用CSA法保证原子性，那什么是CSA呢？</p><p>CAS的全名是：Compare And Swap(比较再交换)；是现代CPU广泛支持的一种对内存中的共享数据进行操作的一种特殊指令。CAS可以将read-modify-chetk-write</p><p>转换为原子操作，这个原子操作直接由处理器保证。</p><p>CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。</p><p><strong>个人理解</strong>：下图中的前提。因为线程执行顺序是有随机性的，假定进程1先执行读取值，再线程2执行读取值操作，在这种情况下若没有采取措施是会破坏原子性的。</p></li></ol><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221126111827373.png" alt="image-20221126111827373"></p><ol start="4"><li><p>CSA和synchronized</p><p>共同点： 都可以保证共享数据的安全性(原子性)</p><p>区别：CAS是没有加锁的，性能较好。（乐观锁）</p><p>​synchronized是加锁操作，性能较差（悲观锁）</p></li></ol><h2 id="并发包"><a href="#并发包" class="headerlink" title="并发包"></a>并发包</h2><p>并发包是JDK本身自带的包，里面提供了很多的类供我我们使用，以下是比较常用的类。</p><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><ol><li><p>概述：Map集合中的经典集合:HashMap它是”线程不安全”的，性能好。</p><p>如果在要求线程安全的业务情况下就不能用这个集合做Map集合，否则业务会崩溃，为了保证线程安全，可以使用Hashtable。</p><p>Hashtable是线程安全的Map集合，但是性能较差！(已经被淘汰了，虽然安全，但是性能差)，HashTable的底层源码所有方法都有加锁。</p><p>ConcurrentHashMap集合，是性能较好，线程安全，最新的集合类。</p></li><li><p>下代码是证明HashMap的线程不安全</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * map集合的线程安全测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapTest</span> &#123;</span><br><span class="line">    <span class="comment">//测试HashMap的线程安全</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建两个线程t1 和 t2</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyThread</span>(), <span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyThread</span>(), <span class="string">&quot;线程2&quot;</span>);</span><br><span class="line">        <span class="comment">// 开启线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">// 保证t1和t2执行完成后再打印</span></span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        <span class="comment">// map长度的理论上应为100000</span></span><br><span class="line">        System.out.println(<span class="string">&quot;map的长度&quot;</span> + map.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50000</span>; i++) &#123;</span><br><span class="line">            MapTest.map.put(Thread.currentThread().getName() + i,Thread.currentThread().getName() + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221126124300277.png" alt="image-20221126124300277"></p><ol start="3"><li><p>Hashtable和ConcurrentHashMap集合的效率比较</p><p>测试Hashtable的执行时间为多少</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String,String&gt; map = <span class="keyword">new</span> <span class="title class_">Hashtable</span>&lt;&gt;();</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221126125645268.png" alt="image-20221126125645268"></p><p>​测试ConcurrentHashMap测试时间多少</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String,String&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221126125801439.png" alt="image-20221126125801439"></p><p>如上图结果所示ConcurrentHashMap性能较好，那为何ConcurrentHashMap性能比Hashtable好呢？</p><ol start="4"><li><strong>Hashtable和ConcurrentHashMap集合的底层原理概述</strong></li></ol><p>HashTable的结构图如下，可看出在所有的链表都加锁了，故加锁的范围大，效率自然就低了。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221126130147813.png" alt="image-20221126130147813"></p><p>ConcurrentHashMap结构图如下，可见其只在一条链上加锁，故锁的范围较小，效率自然就高了。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221126130537171.png" alt="image-20221126130537171"></p><h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><p>​某个线程任务必须等待其他线程执行完毕以后才能最终触发自己执行。</p><p>​需求： 公司召集5名员工开会，等5名员工都到了，会议开始。</p><p>​1. 在以下代码中，5名员工还未全部到达会议，就已经开始组织会议。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//循环创建线程，总创建5个线程代表5个员工</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i ++)&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">EmployeeThread</span>(<span class="string">&quot;员工&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 开始会议</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Meeting</span>()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建会议开始的线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Meeting</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;员工5开始组织会议。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建员工线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmployeeThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EmployeeThread</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;进入会议&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221126135812833.png" alt="image-20221126135812833"></p><ol start="2"><li>利用并发包提供的CyclicBarrier类可以保证先让员工进入会议，在开始组织会议</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 例如:公司召集5名员工开会，等5名员工都到了，会议开始。</span></span><br><span class="line"><span class="comment"> * 我们创建5个员工线程，1个开会任务，几乎同时启动</span></span><br><span class="line"><span class="comment"> * 使用cyclicBarrier保证5名员工线程全部执行后，再执行开会线程。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 构造器:</span></span><br><span class="line"><span class="comment"> *  public cyclicBarrier(int parties,Runnable barrierAction)</span></span><br><span class="line"><span class="comment"> *       用于在线程到达屏障5时，优先执行barrierAction，方便处理更复杂的业务场景</span></span><br><span class="line"><span class="comment"> * 方法:</span></span><br><span class="line"><span class="comment"> *  public int await ()</span></span><br><span class="line"><span class="comment"> *      每个线程调用await方法告诉cyclicBarrier我已经到达了屏障，然后当前线程被阻塞</span></span><br><span class="line"><span class="comment"> *  小结:</span></span><br><span class="line"><span class="comment"> *      可以实现多线程中，某个任务在等待其他线程执行完毕以后触发。循坏屏障可以实现达到一组屏障就触发一个任务执行!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建循环屏障对象，让5个员工全部进入会议在进行开会</span></span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">5</span>,<span class="keyword">new</span> <span class="title class_">Meeting</span>());</span><br><span class="line">        <span class="comment">//循环创建线程，创建5个线程代表5个员工</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i ++)&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">EmployeeThread</span>(<span class="string">&quot;员工&quot;</span> + i,cyclicBarrier).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建会议开始的线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Meeting</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;员工5开始组织会议。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建员工线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmployeeThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="comment">//接收CyclicBarrier的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CyclicBarrier cyclicBarrier;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EmployeeThread</span><span class="params">(String name,CyclicBarrier cyclicBarrier)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//Thread.sleep(1000);</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;进入会议&quot;</span>);</span><br><span class="line">            cyclicBarrier.await(); <span class="comment">//源码中有个计数器，当计数器为5时，就将该线程回收</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221126140145795.png" alt="image-20221126140145795"></p><ol start="3"><li>业务应用场景：可以使用以上的思路去实现多线程加载文件后再打包文件，多线程加载速度快，性能较好。</li></ol><h3 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h3><ol><li><p>作用：用于两个或多个线程之间的信息通信。</p></li><li><p>例子1： 在古代男女结婚大多都是通过媒婆介绍的，那么男女在没结婚之前信息或物品交换都是通过媒婆转达的，更多故事请看以下代码。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  现有两个人，一男一女，是通过媒婆介绍并结婚的美好故事</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExchangerTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//创建一位媒婆</span></span><br><span class="line">        Exchanger&lt;String&gt; matchmaker = <span class="keyword">new</span> <span class="title class_">Exchanger</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//男女线程，现在男孩和女孩要交换定情信物，那只能通过媒婆转达</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Boy</span>(matchmaker),<span class="string">&quot;男孩&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Girl</span>(matchmaker),<span class="string">&quot;女孩&quot;</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>); <span class="comment">//保证男女孩的定情信物的交换成功</span></span><br><span class="line">        System.out.println(<span class="string">&quot;男孩和女孩都很满意对方的定情信物，于是结婚了哈哈哈&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  男孩子，要求不高</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Boy</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="comment">//男孩要去接待媒婆的到来</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Exchanger&lt;String&gt; matchmaker;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Boy</span><span class="params">(Exchanger&lt;String&gt; matchmaker)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.matchmaker = matchmaker;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">stuff</span> <span class="operator">=</span> <span class="string">&quot;同心锁&quot;</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;男孩开始制作--&gt;&quot;</span> + stuff);</span><br><span class="line">            <span class="comment">//男孩制作完后将其交给媒婆传达并从媒婆那得到女孩的信物</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">girlOfStuff</span> <span class="operator">=</span> matchmaker.exchange(stuff); <span class="comment">// 媒婆需要等待男孩的信物做完才可转交</span></span><br><span class="line">            System.out.println(<span class="string">&quot;男孩收到了女孩的&quot;</span> + girlOfStuff);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  女孩子，要求不高</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="comment">//女孩要去接待媒婆的到来</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Exchanger&lt;String&gt; matchmaker;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Girl</span><span class="params">(Exchanger&lt;String&gt; matchmaker)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.matchmaker = matchmaker;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">stuff</span> <span class="operator">=</span> <span class="string">&quot;钥匙&quot;</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;女孩开始制作--&gt;&quot;</span> + stuff);</span><br><span class="line">            <span class="comment">//女孩制作完后将其交给媒婆传达并从媒婆那得到男孩的信物</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">boyOfStuff</span> <span class="operator">=</span> matchmaker.exchange(stuff);</span><br><span class="line">            System.out.println(<span class="string">&quot;女孩收到了男孩的&quot;</span> + boyOfStuff);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221126145632008.png" alt="image-20221126145632008"></p><ol start="3"><li>例子2：正所谓结婚是双向奔赴的结果，那上面的例子可能只是在理想的环境下发生的罢了，现实中哪有如此容易啊，那么请看以下故事的结局是如何。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  现有两个人，一男一女悲惨故事</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExchangerTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//创建一个媒婆对象</span></span><br><span class="line">        Exchanger&lt;String&gt; matchmaker = <span class="keyword">new</span> <span class="title class_">Exchanger</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//男女线程，现在男孩和女孩要交换定情信物，那只能通过媒婆转达</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Boy</span>(matchmaker),<span class="string">&quot;男孩&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Girl</span>(matchmaker),<span class="string">&quot;女孩&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  男孩子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Boy</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="comment">//男孩要去接待媒婆的到来</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Exchanger&lt;String&gt; matchmaker;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Boy</span><span class="params">(Exchanger&lt;String&gt; matchmaker)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.matchmaker = matchmaker;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">stuff</span> <span class="operator">=</span> <span class="string">&quot;同心锁&quot;</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;男孩开始制作--&gt;&quot;</span> + stuff);</span><br><span class="line">            <span class="comment">//男孩制作完后将其交给媒婆传达并从媒婆那得到女孩的信物，男孩是一位急性子，只能等5s，若女孩还没有给定情信物的话就去自杀了</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">girlOfStuff</span> <span class="operator">=</span> matchmaker.exchange(stuff,<span class="number">5</span>, TimeUnit.SECONDS); <span class="comment">// 媒婆需要等待男孩的信物做完才可转交</span></span><br><span class="line">            System.out.println(<span class="string">&quot;男孩收到了女孩的&quot;</span> + girlOfStuff);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  女孩子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="comment">//女孩要去接待媒婆的到来</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Exchanger&lt;String&gt; matchmaker;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Girl</span><span class="params">(Exchanger&lt;String&gt; matchmaker)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.matchmaker = matchmaker;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">stuff</span> <span class="operator">=</span> <span class="string">&quot;钥匙&quot;</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;女孩开始制作--&gt;&quot;</span> + stuff);</span><br><span class="line">            <span class="comment">//女孩对未见过面的男孩犹豫了6s才将信物送出去了</span></span><br><span class="line">            Thread.sleep(<span class="number">6000</span>);</span><br><span class="line">            <span class="comment">//女孩制作完后将其交给媒婆传达并从媒婆那得到男孩的信物</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">boyOfStuff</span> <span class="operator">=</span> matchmaker.exchange(stuff);</span><br><span class="line">            System.out.println(<span class="string">&quot;女孩收到了男孩的&quot;</span> + boyOfStuff);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221126151314144.png" alt="image-20221126151314144"></p><ol start="4"><li>应用业务场景：数据校验。在公司的流水账中数据的校验，可以定义两个线程对流水账中数据先各自校验，然后再把各自的校验结果进行交换，比对对方的校验结果和自己校验结果是否一致，这样可以大大的降低流水账中数据的出错率。</li></ol><h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><ol><li><p>概述： Lambda是JDK1.8之后提供的，作用是简化匿名内部类的写法。</p></li><li><p>使用Lambda表达式的条件是：一个类中只能有一个抽象方法的函数式接口。</p></li><li><p>以下代码是Lambda的基本用法</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//匿名内部类的写法</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;匿名内部类线程开启&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="comment">//lambda写法</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;lambda线程&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h1><ol><li>概述：stream流是JDK1.8之后提供，目的是为了简化集合数据操作的写法，同时也优化了执行的性能。</li><li>以下代码可以体现Stream流的便利</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 业务需求：找到姓张的并且名字长度为3的客户</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//客户列表</span></span><br><span class="line">        List&lt;String&gt; users = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        users.add(<span class="string">&quot;张三丰&quot;</span>);</span><br><span class="line">        users.add(<span class="string">&quot;张韩&quot;</span>);</span><br><span class="line">        users.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        users.add(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        users.add(<span class="string">&quot;刘鸥上&quot;</span>);</span><br><span class="line">        users.add(<span class="string">&quot;张麻子&quot;</span>);</span><br><span class="line">        <span class="comment">//遍历找到姓张的并且长度为3的</span></span><br><span class="line">        <span class="keyword">for</span> (String user: users) &#123;</span><br><span class="line">            <span class="keyword">if</span>(user.startsWith(<span class="string">&quot;张&quot;</span>) &amp;&amp; user.length() == <span class="number">3</span>)&#123;</span><br><span class="line">                System.out.println(user);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;----------stream流------------&quot;</span>);</span><br><span class="line">        <span class="comment">//stream流写法</span></span><br><span class="line">        users.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;张&quot;</span>)).filter(s -&gt; s.length() == <span class="number">3</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221126161207005.png" alt="image-20221126161207005"></p><h2 id="常用的API"><a href="#常用的API" class="headerlink" title="常用的API"></a>常用的API</h2><ol><li><p>forEach ：逐一处理(遍历)</p></li><li><p>long count ()： 统计个数</p></li><li><p>filter ：过滤元素<br>– stream<T> filter (Predicate&lt;? sup er T&gt; predicate)</p></li><li><p>limit：取前几个元素</p></li><li><p>skip：跳过前几个</p></li><li><p>map：数据加工方法</p></li><li><p>concat：合并流。 静态方法</p><p><strong>以上方法除了count 和forEach终结流 ，其余都是非终结流，终结流是调用方法后没有返回值，非终结流是有返回值。</strong></p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  常用API测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//客户列表</span></span><br><span class="line">        List&lt;String&gt; userList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        userList.add(<span class="string">&quot;张三丰&quot;</span>);</span><br><span class="line">        userList.add(<span class="string">&quot;张韩&quot;</span>);</span><br><span class="line">        userList.add(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        userList.add(<span class="string">&quot;张麻子&quot;</span>);</span><br><span class="line">        <span class="comment">//1. 过滤出姓张的客户并打印</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------1------------&quot;</span>);</span><br><span class="line">        userList.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;张&quot;</span>)).forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------2------------&quot;</span>);</span><br><span class="line">        <span class="comment">//2. 计算出客户的个数</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> userList.stream().count();</span><br><span class="line">        System.out.println(count);</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------3------------&quot;</span>);</span><br><span class="line">        <span class="comment">//3. 取前两个的客户名</span></span><br><span class="line">        userList.stream().limit(<span class="number">2</span>).forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------4------------&quot;</span>);</span><br><span class="line">        <span class="comment">//4. 取最后两个的客户</span></span><br><span class="line">        userList.stream().skip(userList.size() - <span class="number">2</span>).forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------5------------&quot;</span>);</span><br><span class="line">        <span class="comment">//5. 在每个客户名称上都加上m字母</span></span><br><span class="line">        userList.stream().map(s -&gt; s + <span class="string">&quot;m&quot;</span>).forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------6------------&quot;</span>);</span><br><span class="line">        <span class="comment">//6. 将下面的列表合成一个列表</span></span><br><span class="line">        List&lt;String&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        temp.add(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        temp.add(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        Stream&lt;String&gt; res = Stream.concat(userList.stream(), temp.stream());</span><br><span class="line">        res.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221126164020510.png" alt="image-20221126164020510" style="zoom:67%;" /><h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><ol><li>以下是常用的API测试</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 常用Api测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileApiTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建文件对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\test.jpg&quot;</span>); <span class="comment">//以绝对路径获取文件对象</span></span><br><span class="line">        <span class="comment">//1. 获取文件的相对路径</span></span><br><span class="line">        System.out.println(f1.getPath());</span><br><span class="line">        <span class="comment">//2. 获取文件的绝对路径</span></span><br><span class="line">        System.out.println(f1.getAbsolutePath());</span><br><span class="line">        <span class="comment">//3. 获取文件的名称，带后缀</span></span><br><span class="line">        System.out.println(f1.getName());</span><br><span class="line">        <span class="comment">//4. 获取文件的大小，以字节单位</span></span><br><span class="line">        System.out.println(f1.length());</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------&quot;</span>);</span><br><span class="line">        <span class="comment">//以相对路径获取文件对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;b_based_item2\\file\\temp\\hello.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//1. 获取文件的相对路径</span></span><br><span class="line">        System.out.println(f2.getPath());</span><br><span class="line">        <span class="comment">//2. 获取文件的绝对路径</span></span><br><span class="line">        System.out.println(f2.getAbsolutePath());</span><br><span class="line">        <span class="comment">//3. 获取文件的名称，带后缀</span></span><br><span class="line">        System.out.println(f2.getName());</span><br><span class="line">        <span class="comment">//4. 获取文件的大小，以字节为单位</span></span><br><span class="line">        System.out.println(f2.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>File的判断API</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建文件对象</span></span><br><span class="line"><span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\test.jpg&quot;</span>); <span class="comment">//以绝对路径获取文件对象</span></span><br><span class="line"><span class="comment">//1. 判断文件是否存在</span></span><br><span class="line">System.out.println(f1.exists());</span><br><span class="line"><span class="comment">//2. 判断是否是文件，若是，返回true 否则 返回false</span></span><br><span class="line">System.out.println(f1.isFile());</span><br><span class="line"><span class="comment">//3. 判断文件对象是否是文件夹</span></span><br><span class="line">System.out.println(f1.isDirectory());</span><br></pre></td></tr></table></figure><ol start="3"><li>File的删除和创建相关的API</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以相对路径获取文件对象</span></span><br><span class="line"><span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;b_based_item2\\file\\temp\\hello1.txt&quot;</span>);</span><br><span class="line"><span class="comment">// 删除文件，若删除成功返回true，否则返回false，以下操作同理</span></span><br><span class="line">f2.delete();</span><br><span class="line"><span class="comment">// 删除空文件夹，非空删除不了</span></span><br><span class="line"><span class="type">File</span> <span class="variable">f3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;b_based_item2\\file\\test&quot;</span>);</span><br><span class="line">f3.delete();</span><br><span class="line"><span class="comment">// 创建多级目录</span></span><br><span class="line"><span class="type">File</span> <span class="variable">f4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;b_based_item2\\file\\temp\\hello\\world&quot;</span>);</span><br><span class="line">f4.mkdirs();</span><br></pre></td></tr></table></figure><ol start="4"><li>File的文件夹的相关API操作</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文件列表的获取和遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FIleApiTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建文件对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\java\\installpackage&quot;</span>);</span><br><span class="line">        <span class="comment">//获取当前文件夹中所有的文件名称</span></span><br><span class="line">        String[] fileNames = file.list();</span><br><span class="line">       <span class="comment">//断言fileNames数组不为空，防止报错</span></span><br><span class="line">        <span class="keyword">assert</span> fileNames != <span class="literal">null</span>;</span><br><span class="line">        Arrays.stream(fileNames).forEach(System.out::println); <span class="comment">//打印</span></span><br><span class="line">        <span class="comment">//获取当前文件夹中的所有文件对象</span></span><br><span class="line">        File[] files = file.listFiles();</span><br><span class="line">        <span class="keyword">if</span>(files == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">            System.out.println(f.getAbsolutePath());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h2><ol><li><p>递归算法的三要素（缺一不可）</p><p>a. 递归的终结点。</p><p>b. 递归的公式。</p><p>c. 递归的方向，递归公式必须往终结点的方向靠近。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecursionTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(f(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="comment">//递归的终结点</span></span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">1</span> &amp;&amp; x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归的公式，该递归公式为f(x-1) + 1 故在x -1 会一直若x是正数就会往x == 1终结点靠近。</span></span><br><span class="line">        <span class="keyword">return</span> f(x - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>以下是递归算法的案例</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  猴子吃桃:</span></span><br><span class="line"><span class="comment"> *      猴子第一天摘了若干个桃子，当即吃了一半，觉得好不过瘾，然后又多吃了一个。</span></span><br><span class="line"><span class="comment"> *      第二天又吃了前一天剩下的一半，觉得好不过瘾，然后又多吃了一个。</span></span><br><span class="line"><span class="comment"> *      以后每天都是如此</span></span><br><span class="line"><span class="comment"> *      等到第十天再吃的时候发现只有1个桃子，请问猴子第一天总共摘了多少个桃子。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   公式推导：假设天数为n从1开始算起，f(n)为猴子吃桃子数</span></span><br><span class="line"><span class="comment"> *      f(n + 1) = f(n) - f(n)/2 - 1</span></span><br><span class="line"><span class="comment"> *      公式变换：2f(n + 1) = 2f(n) - f(n) - 2</span></span><br><span class="line"><span class="comment"> *           =&gt; f(n) = 2f(n + 1) + 2</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   递归的三要素</span></span><br><span class="line"><span class="comment"> *      递归的终结点：f(10) = 1</span></span><br><span class="line"><span class="comment"> *      递归的公式：f(n) = 2f(n + 1) + 2</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecursionTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(f(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//递归的终结点</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归的公式</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * f(n + <span class="number">1</span>) + <span class="number">2</span>; <span class="comment">//得出答案为：1534</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  要求：求出n的阶层</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  公式推导：f(n) = n * (n-1) * ... * 3 * 2 * 1</span></span><br><span class="line"><span class="comment"> *  找规律得：f(n) = f(n - 1) * n</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  递归的三要素</span></span><br><span class="line"><span class="comment"> *      递归的终结点：f(1) = 1</span></span><br><span class="line"><span class="comment"> *      递归的公式：f(n) = f(n - 1) * n</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecursionTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(f(<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f(n - <span class="number">1</span>) * n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递归搜索文件"><a href="#递归搜索文件" class="headerlink" title="递归搜索文件"></a>递归搜索文件</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文件搜索测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileSearchTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//在javaFileStore目录下寻找word.txt文件</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> fileSearch(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\javaFileStore&quot;</span>), <span class="string">&quot;word.txt&quot;</span>);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mkdir：目录</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileName：要查找的文件名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 若找到返回该文件的绝对路径，不存在返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">fileSearch</span><span class="params">(File mkdir,String fileName)</span>&#123;</span><br><span class="line">        <span class="comment">//1. 判断该目录是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(!mkdir.exists()) &#123;</span><br><span class="line">            <span class="comment">//说明不存在</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2. 获取该目录下的所有文件</span></span><br><span class="line">        File[] files = mkdir.listFiles();</span><br><span class="line">        <span class="comment">//3. 判断该目录下是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(files == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//说明files文件夹为空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历判断是否是文件</span></span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            <span class="keyword">if</span>(file.isFile()) &#123;</span><br><span class="line">                <span class="comment">//说明是文件</span></span><br><span class="line">                <span class="keyword">if</span>(file.getName().contains(fileName)) &#123;</span><br><span class="line">                    <span class="comment">//说明找到了</span></span><br><span class="line">                    <span class="keyword">return</span> file.getAbsolutePath();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//说明是目录，递归再寻找</span></span><br><span class="line">                <span class="keyword">return</span> fileSearch(file,fileName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221127132603389.png" alt="image-20221127132603389"></p><h2 id="I-x2F-O流"><a href="#I-x2F-O流" class="headerlink" title="I&#x2F;O流"></a>I&#x2F;O流</h2><ol><li>概述： File类只能操作文件对象本身并不能对其进行读写操作，读写文件应是I&#x2F;O操作，I&#x2F;O流可以理解成水流模型，IO是水管，数据是水流。</li></ol><h3 id="I-x2F-O流的分类"><a href="#I-x2F-O流的分类" class="headerlink" title="I&#x2F;O流的分类"></a>I&#x2F;O流的分类</h3><p>按照流的方向分类</p><ol><li><p>输出流：以内存为基准，把内存中的数据写出到磁盘文件或者网络介质中去的流称为输出流。输出流作用是写数据到文件，或者写数据发送给别人。</p></li><li><p>输入流：以内存为基准，把磁盘文件中的数据或者网络中的数据读入到内存中去的流称为输入流，输入流的作用:读取数据到内存。</p></li></ol><p>按照流的内容分类</p><ol><li>字节流： 流中的数据的最小单位是一个一个的字节(bit)，这个流就是字节流。(万”物”皆可字节流)</li><li>字符流： 流中的数据的最小单位是一个一个的字符，这个流就是字符流。(针对于文本内容)</li></ol><h3 id="I-x2F-O流代码实现"><a href="#I-x2F-O流代码实现" class="headerlink" title="I&#x2F;O流代码实现"></a>I&#x2F;O流代码实现</h3><ol><li><strong>字节输入流（结合图理解字节流的工作流程）</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字节流读取文件内容测试测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IOStreamTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//创建一根水管（字节输入流对象）</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;b_based_item2\\file\\temp\\hello.txt&quot;</span>); </span><br><span class="line">       <span class="comment">//定义一个桶</span></span><br><span class="line">        <span class="type">byte</span>[] buff = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">//桶中装水大小容量</span></span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="comment">//循环将桶中的水倒出（打印）</span></span><br><span class="line">        <span class="keyword">while</span> ((len = is.read(buff)) != -<span class="number">1</span>) &#123; <span class="comment">//当桶中没水了会返回一个-1</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(buff,<span class="number">0</span>,len)); <span class="comment">// new String() 将字节转换成字符，可以避免输出中文乱码（桶需要比文件还大）</span></span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">//关闭水管</span></span><br><span class="line">        is.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221127143510871.png" alt="image-20221127143510871"></p><ol start="2"><li><strong>字节输出流</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字节流输出流测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IOStreamTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//创建一根输出流水管（默认会将文件中的内容覆盖）</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;b_based_item2\\file\\temp\\hello.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//不会覆盖文件中的内容，在创建对象时，加个参数true</span></span><br><span class="line">        <span class="comment">//OutputStream os = new FileOutputStream(&quot;b_based_item2\\file\\temp\\hello.txt&quot;,true);</span></span><br><span class="line">        <span class="comment">//定义一个水桶并装水（内容）</span></span><br><span class="line">        <span class="type">byte</span>[] buff = <span class="string">&quot;我本可以忍受黑暗，如果我未曾见过光明&quot;</span>.getBytes();</span><br><span class="line">        <span class="comment">//将水桶中的水倒进水池中（将内容写入文件中）</span></span><br><span class="line">        os.write(buff);</span><br><span class="line">        <span class="comment">//刷新水管</span></span><br><span class="line">        os.flush();</span><br><span class="line">        <span class="comment">//关闭水管</span></span><br><span class="line">        os.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>复制文件案例</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 复制文件测试</span></span><br><span class="line"><span class="comment"> *  需求：从一个文件中读取数据复制到另一个文件目录中</span></span><br><span class="line"><span class="comment"> *  注意：以下的写法是JDK1.7后提供的新写法 try-catch-resource java自动会释放资源</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IOCopyTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="keyword">try</span> (</span><br><span class="line">               <span class="comment">//创建字节输入流</span></span><br><span class="line">               <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;b_based_item2\\file\\temp\\hello.txt&quot;</span>);</span><br><span class="line">                <span class="comment">//创建字节输出流对象</span></span><br><span class="line">                <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;b_based_item2\\file\\temp\\hello\\hello.txt&quot;</span>);</span><br><span class="line">             )&#123;</span><br><span class="line">           <span class="comment">//从输入流中读取数据</span></span><br><span class="line">           <span class="comment">//定义一个桶</span></span><br><span class="line">           <span class="type">byte</span>[] buff = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">           <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">           <span class="comment">//从水池中抽水并通过os将水倒进另一个水池中</span></span><br><span class="line">           <span class="keyword">while</span> ((len = is.read(buff)) != -<span class="number">1</span>) &#123;</span><br><span class="line">               os.write(buff,<span class="number">0</span>,len);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>字符输入流</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文件字符输入流。</span></span><br><span class="line"><span class="comment"> *      --作用:以内存为基准，把磁盘文件的数据以字符的形式读入到内存。</span></span><br><span class="line"><span class="comment"> *          简单来说，读取文本文件内容到内存中去。</span></span><br><span class="line"><span class="comment"> *      --构造器:</span></span><br><span class="line"><span class="comment"> *          public FileReader(File file):创建一个字符输入流与源文件对象接通</span></span><br><span class="line"><span class="comment"> *           public FileReader (string filePath):创建一个字符输入流与源文件路径接通</span></span><br><span class="line"><span class="comment"> *      --方法:</span></span><br><span class="line"><span class="comment"> *          public int read():读取一个字符的编号返回!读取完毕返回-1</span></span><br><span class="line"><span class="comment"> *          public int read (char[] buffer):读取一个字符数组，</span></span><br><span class="line"><span class="comment"> *              读取多少个字符就返回多少个数量，读取完毕返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IOReadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">            <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;b_based_item2\\file\\temp\\hello.txt&quot;</span>);</span><br><span class="line">        )&#123;</span><br><span class="line">            <span class="comment">//从文件中以字符为单位读取数据</span></span><br><span class="line">            <span class="type">char</span>[] buff = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((len = fr.read(buff)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(buff,<span class="number">0</span>,len));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>字符输出流</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字符输出流测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IOWriterTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">//以追加数据的形式创建输出流</span></span><br><span class="line">                <span class="type">Writer</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;b_based_item2\\file\\temp\\hello.txt&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">             )&#123;</span><br><span class="line">            <span class="comment">//定义需要写入的数据文字</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">info1</span> <span class="operator">=</span> <span class="string">&quot;code&quot;</span>;</span><br><span class="line">            <span class="comment">//写入数据</span></span><br><span class="line">            writer.write( info1 + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">info2</span> <span class="operator">=</span> <span class="string">&quot;实力与野心不符，这是一件很可悲的事情&quot;</span>;</span><br><span class="line">            writer.write(info2 + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="I-x2F-O缓冲流"><a href="#I-x2F-O缓冲流" class="headerlink" title="I&#x2F;O缓冲流"></a>I&#x2F;O缓冲流</h3><ol><li><strong>字节缓冲输入流</strong>：因为BufferedInputStream类是继承InputStream类的，故API接口几乎不变</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字节缓冲输入流:BufferedInputStream</span></span><br><span class="line"><span class="comment"> *     --作用:可以把低级的字节输入流包装成一个高级的缓冲字节输入流管道，</span></span><br><span class="line"><span class="comment"> *            从而提高字节输入流读数据的性能。</span></span><br><span class="line"><span class="comment"> *     --构造器:public BufferedInputStream (InputStream in)</span></span><br><span class="line"><span class="comment"> *     --原理:缓冲字节输入流管道自带了一个8KB的缓冲池，每次可以直接借用操作系统的功能最多提取8KB</span></span><br><span class="line"><span class="comment"> *            的数据到缓冲池中去，以后我们直接从缓冲池读取数据，所以性能较好!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IOBufferStreamTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">              <span class="comment">//创建对象</span></span><br><span class="line">              <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;b_based_item2\\file\\temp\\hello.txt&quot;</span>))</span><br><span class="line">           )&#123;</span><br><span class="line">            <span class="comment">//定义一个桶</span></span><br><span class="line">            <span class="type">byte</span>[] buff = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((len = is.read(buff)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(buff,<span class="number">0</span>,len));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>缓冲字节输出流</strong>：BufferedOutputStream继承OutputStream类，故API接口与上面的几乎不变</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  字节缓冲输出流:BufferedOutputStream</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IOBufferStreamTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">              <span class="comment">//创建对象</span></span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;b_based_item2\\file\\temp\\hello.txt&quot;</span>,<span class="literal">true</span>))</span><br><span class="line">           )&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">info</span> <span class="operator">=</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">            os.write(info.getBytes());</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>字节流和字节缓冲流的性能分析</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字节流和字符缓冲字节流性能测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IOPerformanceTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        copy1();</span><br><span class="line">        copy2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//由于一个一个字节复制文件太慢了直接pass</span></span><br><span class="line">    <span class="comment">//一个一个字节数组复制文件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copy1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">//创建字节输入流</span></span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;b_based_item2\\file\\temp\\temp.mp4&quot;</span>);</span><br><span class="line">                <span class="comment">//创建字节输出流对象</span></span><br><span class="line">                <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;b_based_item2\\file\\temp\\hello\\temp1.mp4&quot;</span>);</span><br><span class="line">        )&#123;</span><br><span class="line">            <span class="comment">//从输入流中读取数据</span></span><br><span class="line">            <span class="comment">//定义一个桶</span></span><br><span class="line">            <span class="type">byte</span>[] buff = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//从水池中抽水并通过os将水倒进另一个水池中</span></span><br><span class="line">            <span class="keyword">while</span> ((len = is.read(buff)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                os.write(buff,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;字节流一次一数组复制文件所耗时：&quot;</span> + (end - start) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//缓冲字节流一次一个数组复制</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copy2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">//创建字节输入流</span></span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;b_based_item2\\file\\temp\\temp.mp4&quot;</span>));</span><br><span class="line">                <span class="comment">//创建字节输出流对象</span></span><br><span class="line">                <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;b_based_item2\\file\\temp\\hello\\temp2.mp4&quot;</span>));</span><br><span class="line">        )&#123;</span><br><span class="line">            <span class="comment">//从输入流中读取数据</span></span><br><span class="line">            <span class="comment">//定义一个桶</span></span><br><span class="line">            <span class="type">byte</span>[] buff = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//从水池中抽水并通过os将水倒进另一个水池中</span></span><br><span class="line">            <span class="keyword">while</span> ((len = is.read(buff)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                os.write(buff,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;字节缓冲流一次一数组复制文件所耗时：&quot;</span> + (end - start)  + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221127164321276.png" alt="image-20221127164321276"></p><p>总结：如上图结果显示，字节缓冲流的性能比普通的字节流性能还要好。</p><ol start="4"><li><strong>字符输入缓冲流</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字符缓冲流测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IOBufferReadTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="keyword">try</span> (</span><br><span class="line">               <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;b_based_item2\\file\\temp\\hello.txt&quot;</span>));</span><br><span class="line">           )&#123;</span><br><span class="line">           <span class="comment">//从文件中读取数据</span></span><br><span class="line">           <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">           <span class="comment">//一次读取一行字符</span></span><br><span class="line">           <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">               System.out.println(line);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>字符缓冲输出流</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字符缓冲输出流测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IOBufferWriteTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//创建字符缓冲输出对象(新添加的内容加入到文件的末尾)</span></span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;b_based_item2\\file\\temp\\hello.txt&quot;</span>,<span class="literal">true</span>));</span><br><span class="line">        <span class="comment">//换一行</span></span><br><span class="line">        bw.newLine();</span><br><span class="line">        <span class="comment">//写入数据</span></span><br><span class="line">        bw.write(<span class="string">&quot;我本可以忍受黑暗&quot;</span>);</span><br><span class="line">        <span class="comment">//换一行</span></span><br><span class="line">        bw.newLine();</span><br><span class="line">        <span class="comment">//再写入数据</span></span><br><span class="line">        bw.write(<span class="string">&quot;假如我为曾见过光明&quot;</span>);</span><br><span class="line"></span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;异常的作用&quot;&gt;&lt;a href=&quot;#异常的作用&quot; class=&quot;headerlink&quot; title=&quot;异常的作用&quot;&gt;&lt;/a&gt;异常的作用&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;提高程序的健壮性和安全性。&lt;/li&gt;
&lt;li&gt;可以处理代码问题，防止程序出现问题后的死亡。&lt;/li&gt;
&lt;</summary>
      
    
    
    
    
    <category term="java基础" scheme="http://example.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>node.js安装说明及环境配置</title>
    <link href="http://example.com/2022/11/20/node-js%E5%AE%89%E8%A3%85%E8%AF%B4%E6%98%8E%E5%8F%8A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>http://example.com/2022/11/20/node-js%E5%AE%89%E8%A3%85%E8%AF%B4%E6%98%8E%E5%8F%8A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</id>
    <published>2022-11-20T04:31:48.000Z</published>
    <updated>2022-11-26T09:13:16.183Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装node-js步骤"><a href="#安装node-js步骤" class="headerlink" title="安装node.js步骤"></a>安装node.js步骤</h2><p>（一）官网下载安装包</p><ol><li>官网下载：<a href="https://nodejs.org/en/">Node.js (nodejs.org)</a></li></ol><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221120143619510.png" alt="image-20221120143619510" style="zoom:50%" /><ol start="2"><li>解压安装包进入你所安装的目录下，并创建两个目录分别为node_global和node_cache，<ol><li>node_globe：全局目录，下载的文件是保存于此</li><li>node_cache：缓存目录，保存一些node运行时的日志文件等等</li></ol></li><li>前两步完成后使用快捷键win+r输入cmd进入命令窗口，输入命令：<ol><li>node -v ：查看node是否安装成功</li><li>npm -v：查看npm命令是否安装成功，若安装成功如下图所示</li></ol></li></ol><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221120160703329.png" alt="image-20221120160703329"></p><p>（二）设置自定义全局目录和缓存目录</p><pre><code>    1.  以上步骤完成后，以管理员身份运行cmd，输入以下命令</code></pre><p>（三）配置环境变量</p><pre><code>      1. 将【用户变量】下的【Path】修改为【D:\Nodejs\node_global】，之后点击确定。</code></pre><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221120161915822.png" alt="image-20221120161915822"></p><ol start="2"><li>在【系统变量】下新建【NODE_PATH】【D:\Nodejs\node_global\node_modules】</li></ol><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221120162015871.png" alt="image-20221120162015871"></p><ol start="3"><li>在【系统变量】下的【Path】新建添加node全局文件夹【D:\Nodejs\node_global】，之后点击确定。</li></ol><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221120162114934.png" alt="image-20221120162114934" style="zoom:67%;" /><p>（四）下载cnpm命令</p><ol><li><p>说明：npm 默认的 registry ,也就是下载 npm 包时是从国外的服务器下载，国内很慢，一般都会指向淘宝 <a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a></p></li><li><p>npm config get registry         查看下当前的镜像源</p></li><li><p>npm config set registry <a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org/</a>     更换镜像为淘宝镜像</p></li><li><p>npm config get registry        检查配置是否成功 </p></li><li><p>npm install -g cnpm –registry&#x3D;<a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a>      全局安装基于淘宝源的cnpm</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;安装node-js步骤&quot;&gt;&lt;a href=&quot;#安装node-js步骤&quot; class=&quot;headerlink&quot; title=&quot;安装node.js步骤&quot;&gt;&lt;/a&gt;安装node.js步骤&lt;/h2&gt;&lt;p&gt;（一）官网下载安装包&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;官网下载：&lt;a hr</summary>
      
    
    
    
    
    <category term="node.js" scheme="http://example.com/tags/node-js/"/>
    
  </entry>
  
  <entry>
    <title>spring+springmvc+maven笔记</title>
    <link href="http://example.com/2022/11/20/spring+springmvc+maven%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2022/11/20/spring+springmvc+maven%E7%AC%94%E8%AE%B0/</id>
    <published>2022-11-19T16:00:00.000Z</published>
    <updated>2023-01-24T09:12:22.684Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>概念</strong>：Spring是分层的Java SE&#x2F;EE应用full-stack轻量级开源框架，以loC ( Inverse Of Control:反转控制)和AOP (Aspect Oriented Programming :面向切</p><p>面编程)为内核。</p><p><strong>应用</strong>：提供了展现层SpringMVC和持久层Spring JDBCTemplate 以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框</p><p>架和类库，逐渐成为使用最多的JavaEE企业应用开源框架”</p><p><strong>优势</strong></p><p>（1）方便解耦，简化开发</p><p>通过Spring提供的lOC容器，可以将对象间的依赖关系交由Spring进行控制，避免硬编码所造成的过度耦合。用户也不必再为单例模式类、属性文件解析</p><p>等这些很底层的需求编写代码，可以更专注于上层的应用。</p><p>（2）AOP编程的支持</p><p>通过Spring的AOP功能，方便进行面向切面编程，许多不容易用传统OOP实现的功能可以通过AOP轻松实现。</p><p>（3）声明式事务的支持</p><p>可以将我们从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活的进行事务管理提高开发效率和质量。</p><p>（4）方便集成各种优秀框架</p><p>Spring对各种优秀框架(Struts、Hibernate、Hessian、Quartz等)的支持。</p><p>（5）降低JavaEE API的使用难度</p><p>Spring对JavaEEAPI(如JDBC、JavaMail、远程调用等）进行了薄薄的封装层，使这些API的使用难度大为降低。</p><p>（6）Java源码是经典学习范例</p><p>Spring的源代码设计精妙、结构清晰、匠心独用，处处体现着大师对Java设计模式灵活运用以及对Java技术的高深造诣。它的源代码无疑是Java技术的最佳实践的范例。</p><h2 id="Spring-framework"><a href="#Spring-framework" class="headerlink" title="Spring framework"></a>Spring framework</h2><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221130172942524.png" alt="image-20221130172942524"></p><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><ul><li><p>概述：使用对象时，由主动new产生对象转换为由外部提供对象，此过程中对象创建控制权由程序转移到外部，此思想称为控制反转技术对IOC思想进行了实现，Spring提供了一个容器，称为IoC容器，用来充当IoC思想中的 “外部“，IoC容器负责对象的创建、初始化等一系列工作，被创建或被管理的对象在IoC容器中统称为Bean。</p></li><li><p><strong>创建Bean的步骤如下</strong></p><ol><li>pom.xml文件中导入spring-context坐标（版本5.0.5.RELEASE）</li><li>resource目录下创建spring的配置文件，通常将其命名为applicationContext.xml</li><li>在applicationContext.xml利用bean标签创建即可，如下所示</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 将bookDaoImpl类交给Spring的IOC管理(将其变为bean) --&gt;</span><br><span class="line">   &lt;!-- id值随便取，class值是指向实例类 --&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;bookDao&quot;</span> class=<span class="string">&quot;com.springbased.dao.impl.BookDaoImpl&quot;</span> /&gt;</span><br><span class="line">&lt;!-- 将bookServiceImpl类交给Spring的IOC管理(将其变为bean) --&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;bookService&quot;</span> class=<span class="string">&quot;com.springbased.service.impl.BookServiceImpl&quot;</span>  /&gt;</span><br></pre></td></tr></table></figure><ul><li>从IOC容器中获取bean</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//获取IOC容器</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//根据id获取具体的bean 两种方法：</span></span><br><span class="line">        <span class="comment">//1)通过id方式获取  Object getBean(String id);</span></span><br><span class="line">        <span class="comment">//2)通过类对象获取  Class getBean(类名称.class);</span></span><br><span class="line">        <span class="type">BookService</span> <span class="variable">bookDao</span> <span class="operator">=</span> (BookService)ac.getBean(<span class="string">&quot;bookService&quot;</span>);</span><br><span class="line">        <span class="comment">//调用方法</span></span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Bean基本属性"><a href="#Bean基本属性" class="headerlink" title="Bean基本属性"></a>Bean基本属性</h2><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221130175356015.png" alt="image-20221130175356015"></p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221130175501245.png" alt="image-20221130175501245"></p><p>scope默认单例的原因是：在非单例下，Ioc容器创建同一个类的bean多是不同的，对bean的复用性不高，当bean创建过多会导致性能的下降，还会浪费内存空间资源，故在单例模式下的优势在于，能避免实例重复创建；应用于避免存在多个实例引起程序逻辑错误的场合；较节约内存。</p><h2 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h2><ul><li>生命周期︰从创建到消亡的完整过程</li><li>bean生命周期：bean从创建到销毁的整体过程</li><li>bean生命周期控制：在bean创建后到销毁前做一些事情</li></ul><p>bean的生命周期可以实现InitializingBean，DisposableBean来重写bean的初始化和销毁的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span>, InitializingBean, DisposableBean &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;saving....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Bean被销毁前执行的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;destroy ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建Bean的初始化方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><ul><li><p>概述：依赖注入(Dependency Injection) :它是Spring框架核心IOC的具体实现。在编写程序时，通过控制反转，把对象的创建交给了Spring，但是代码中不可能出现没有依赖的情况。IOC解耦只是降低他们的依赖关系，但不会消除。例如:业务层仍会调用持久层的方法。那这种业务层和持久层的依赖关系，在使用Spring之后，就让Spring来维护了。简单的说，就是坐等框架把持久层对象传入业务层，而不用我们自己去获取。</p></li><li><p><strong>setter依赖注入方式</strong></p></li></ul><ol><li>在service层中定义成员变量来接收来自bean的注入</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="comment">//1. 创建一个dao对象，接收来自XMl文件注入bean</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    <span class="comment">//2. 构造set方法接收</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        bookDao.save();</span><br><span class="line">        System.out.println(<span class="string">&quot;service save ......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>在applicationContext.xml文件中配置如下，注意：其中name对应的值是set后边的单词，以小写开头，ref的值是将name的值赋值给定的类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 将bookDaoImpl类交给Spring的IOC管理(将其变为bean) --&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;bookDao&quot;</span> class=<span class="string">&quot;com.springbased.dao.impl.BookDaoImpl&quot;</span> /&gt;</span><br><span class="line">&lt;!-- 将bookServiceImpl类交给Spring的IOC管理(将其变为bean) --&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;bookService&quot;</span> class=<span class="string">&quot;com.springbased.service.impl.BookServiceImpl&quot;</span> &gt;</span><br><span class="line">    &lt;!--将service和dao通过property标签进行绑定--&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">        注意点：</span><br><span class="line">          name：是指向类属性的名称</span><br><span class="line">          ref：是指向bean中id为bookDao</span><br><span class="line">     --&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;bookDao&quot;</span> ref=<span class="string">&quot;bookDao&quot;</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221130181123964.png" alt="image-20221130181123964"></p><ul><li><strong>构造器依赖注入</strong></li></ul><ol><li>在service层中创建一个构造器如下</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="comment">//1. 创建一个dao对象，接收来自XMl文件注入bean</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BookServiceImpl</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. 创建一个构造器，为成员变量赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BookServiceImpl</span><span class="params">(BookDao bookDao, UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        bookDao.save();</span><br><span class="line">        System.out.println(<span class="string">&quot;service save ......&quot;</span>);</span><br><span class="line">        userDao.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>xml的配置如下，构造器注入的标签是constructor-arg</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 将bookDaoImpl类交给Spring的IOC管理(将其变为bean) --&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;bookDao&quot;</span> class=<span class="string">&quot;com.springbased1.dao.impl.BookDaoImpl&quot;</span>/&gt;</span><br><span class="line">&lt;!-- 将userDao加载成bean --&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;userDao&quot;</span> class=<span class="string">&quot;com.springbased1.dao.impl.UserDaoImpl&quot;</span>/&gt;</span><br><span class="line">&lt;!-- 将bookServiceImpl类交给Spring的IOC管理(将其变为bean) --&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;bookService&quot;</span> class=<span class="string">&quot;com.springbased1.service.impl.BookServiceImpl&quot;</span>&gt;</span><br><span class="line">    &lt;constructor-arg name=<span class="string">&quot;userDao&quot;</span> ref=<span class="string">&quot;userDao&quot;</span> /&gt;  </span><br><span class="line">    &lt;constructor-arg name=<span class="string">&quot;bookDao&quot;</span> ref=<span class="string">&quot;bookDao&quot;</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li>构造器注入的过程</li></ol><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221130183436290.png" alt="image-20221130183436290"></p><h2 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h2><ul><li>配置中使用bean标签autowire属性设置自动装配的类型，如下所示是applicationContext.xml的配置</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 将bookDaoImpl类交给Spring的IOC管理(将其变为bean) --&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;bookDao&quot;</span> class=<span class="string">&quot;com.springbased1.dao.impl.BookDaoImpl&quot;</span>/&gt;</span><br><span class="line">&lt;!-- 将userDao加载成bean --&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;userDao&quot;</span> class=<span class="string">&quot;com.springbased1.dao.impl.UserDaoImpl&quot;</span>/&gt;</span><br><span class="line">&lt;!-- byType是按类型注入 还有按名称注入byName--&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;bookService&quot;</span> class=<span class="string">&quot;com.springbased1.service.impl.BookServiceImpl&quot;</span> autowire=<span class="string">&quot;byType&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="comment">//1. 创建一个dao对象，接收来自XMl文件注入bean</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="comment">//在自动注入，必须提供一个setter方法，Spring的IOC容器会从setter方法作为入口赋值给该类的成员变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        bookDao.save();</span><br><span class="line">        System.out.println(<span class="string">&quot;service save ......&quot;</span>);</span><br><span class="line">        userDao.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用自动装配时需注意一下几点</p><ul><li>自动装配用于引用类型依赖注入，不能对简单类型进行操作</li><li>使用按类型装配时( byType )必须保障容器中相同类型的bean唯一，推荐使用</li><li>使用按名称装配时（byName )必须保障容器中具有指定名称的bean，因变量名与配置耦合，不推荐使用</li><li>自动装配优先级低于setter注入与构造器注入，同时出现时自动装配配置失效</li></ul><h2 id="整合第三方数据源"><a href="#整合第三方数据源" class="headerlink" title="整合第三方数据源"></a>整合第三方数据源</h2><ol><li>导入druid坐标</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.2</span><span class="number">.11</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>在applicationContext.xml中配置如下</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;dataSource&quot;</span> class=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;driverClassName&quot;</span> value=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span> /&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;username&quot;</span> value=<span class="string">&quot;root&quot;</span> /&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;password&quot;</span> value=<span class="string">&quot;123456&quot;</span> /&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;url&quot;</span> value=<span class="string">&quot;jdbc:mysql//localhost:3306/test&quot;</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li>整合成功的标志</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//获取IOC容器中的Bean对象</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//从容器中获取数据源</span></span><br><span class="line">        <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> (DataSource)ac.getBean(<span class="string">&quot;dataSource&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221201130442404.png" alt="image-20221201130442404"></p><h3 id="加载properties配置文件中的配置信息"><a href="#加载properties配置文件中的配置信息" class="headerlink" title="加载properties配置文件中的配置信息"></a>加载properties配置文件中的配置信息</h3><ul><li>开启context的命名空间，在xml页面上方增加如下信息</li></ul><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221201131141810.png" alt="image-20221201131141810"></p><ul><li>在resource目录下定义一个装连接数据库的配置文件.properties，配置信息如下</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jdbc.url=jdbc:mysql<span class="comment">//localhost:3306/test</span></span><br><span class="line">jdbc.druidName=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=<span class="number">123456</span></span><br></pre></td></tr></table></figure><ul><li>在数据库连接配置中，使用占位符方式取出.properties文件中对应的值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 利用context命令，使用通配符* 将所有的.properties文件引入--&gt;</span><br><span class="line">&lt;context:property-placeholder location=<span class="string">&quot;classpath:*.properties&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 使用$占位符方式，从.properties文件取出对应的值--&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;dataSource&quot;</span> class=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;driverClassName&quot;</span> value=<span class="string">&quot;$&#123;jdbc.druidName&#125;&quot;</span> /&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;username&quot;</span> value=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span> /&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;password&quot;</span> value=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span> /&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;url&quot;</span> value=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><h2 id="注解开发"><a href="#注解开发" class="headerlink" title="注解开发"></a>注解开发</h2><ul><li><strong>使用注解@Component加载Bean</strong><ol><li>开启xml文件组件扫描，使用context命令</li><li>在需要的类上加上注解@Component(“bean名称”)即可将此类加载成Bean</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 开启组件扫描，若没有开启扫描，注解将会失效 base-<span class="keyword">package</span>是扫描的范围--&gt;</span><br><span class="line">&lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">&quot;com.springbased1&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">//将此类加载成Bean，未给这个bean命名，则默认类型加载</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;service save ......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//获取IOC容器中的Bean对象</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//根据数据类型获取bean</span></span><br><span class="line">        <span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> ac.getBean(BookService.class);</span><br><span class="line">        bookService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>使用@ComponentScan注解代替xml中的组件扫描</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">//标记该类是配置类</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.springbased1&quot;)</span> <span class="comment">//开启组件扫描</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComponentConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在用配置类替换xml配置文件则需从配置类中获取容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//从配置类中获取容器</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(ComponentConfig.class);</span><br><span class="line">        <span class="comment">//根据数据类型获取bean，根据数据类型获取时应注意在IOC容器中只能有一个该类型的数据。</span></span><br><span class="line">        <span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> ac.getBean(BookService.class);</span><br><span class="line">        bookService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring&quot;&gt;&lt;a href=&quot;#Spring&quot; class=&quot;headerlink&quot; title=&quot;Spring&quot;&gt;&lt;/a&gt;Spring&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;</summary>
      
    
    
    
    
    <category term="ssm" scheme="http://example.com/tags/ssm/"/>
    
  </entry>
  
</feed>
