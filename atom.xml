<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hello World</title>
  
  <subtitle>故不积跬步，无以至千里；不积小流，无以成江海。</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-06-08T06:39:55.365Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>孤江自流</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>taowu-app</title>
    <link href="http://example.com/2023/05/14/taowu-doc/"/>
    <id>http://example.com/2023/05/14/taowu-doc/</id>
    <published>2023-05-14T08:14:00.000Z</published>
    <updated>2023-06-08T06:39:55.365Z</updated>
    
    <content type="html"><![CDATA[<h1 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h1><p style="color:red">因开发未完成，所以本文档内容非常的不完整，开发中会持续更新。</p><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>​随着时代的进步，信息化和数字化是现代的名词，而且现在网上用户逐年增多，各式各样的网上 APP 不断推出，尤为明显的就是电商行业，它解决了大部分用户的网购欲望。本人看到了在互联网的电商的所带来的便捷，想着开发一个属于自己的电商项目，作为自己的毕业作品，项目的页面设计灵感来源于淘宝app</p><h2 id="技术介绍"><a href="#技术介绍" class="headerlink" title="技术介绍"></a>技术介绍</h2><p>​项目涉及的技术有：java + springboot + mybatis-plus + vant2 + vue + minio + mysql + element-ui  + nginx + redis等等，如下思维导图所示是项目的所有涉及到的技术栈</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230608111341079.png" alt="taowu 技术栈导图"></p><p>文件存储：通过minio自主搭建的文件存储系统，用于存储电商中的商品图片和用户头像等等文件信息</p><p>redis：非关系型数据库，是基于内存的存储方式，是用于项目的后期优化，尽可能的提高响应速度</p><p>mybatis-plus：是基于ORM（对象关系映射）的持久层框架，用于后端和数据库的交互</p><p>mysql：关系型数据库，信息的存储数据库</p><p>微服务相关的技术：是用于拆分模块后模块与模块之间需要进行数据交互，以及模块间请求的负载均衡</p><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><table><thead><tr><th align="center">开发工具名称</th><th align="center">版本</th><th align="center">安装位置</th></tr></thead><tbody><tr><td align="center">navicat 15</td><td align="center">15.xx</td><td align="center">本地</td></tr><tr><td align="center">git</td><td align="center">xxx</td><td align="center">本地</td></tr><tr><td align="center">minio</td><td align="center">2019.x.x</td><td align="center">本地</td></tr><tr><td align="center">idea</td><td align="center">2022.1.3</td><td align="center">本地</td></tr><tr><td align="center">nginx</td><td align="center">1.18.0</td><td align="center">本地</td></tr><tr><td align="center">maven</td><td align="center">3.6.1</td><td align="center">本地</td></tr><tr><td align="center">node.js</td><td align="center">16.18.0</td><td align="center">本地</td></tr><tr><td align="center">jdk</td><td align="center">1.8.x</td><td align="center">本地</td></tr><tr><td align="center">redis</td><td align="center">5.0.x</td><td align="center">Linux</td></tr><tr><td align="center">mysql</td><td align="center">8.0.x</td><td align="center">本地</td></tr></tbody></table><h2 id="项目目标"><a href="#项目目标" class="headerlink" title="项目目标"></a>项目目标</h2><p>​主要致力于实现包括前台应用程序系统和后台数据管理系统，对于此次线上线下同时发展的taowu小型电商平台我们做部分简化，将线下购买流程与后台数据管理系统合并，即线下购买由管理人员填写订单信息。前台应用程序系统要求具有界面友好、功能完备、易使用等特点。而后台数据管理系统的数据要具有数据一致性、完整性、安全性。系统支持用户注册登录，浏览商品，加入购物车到生成订单等。管理员实现规范化管理，可以高效率的进行商品、订单、用户和产品分类的管理。</p><h2 id="模块结构图"><a href="#模块结构图" class="headerlink" title="模块结构图"></a>模块结构图</h2><p>​Taowu电商项目中包含仓储管理模块、订单模块、商品信息管理模块、验证码模块、用户管理模块、权限认证模块、媒资文件模块，如下图 所示，为Taowu电商项目的模块结构图。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230608125516981.png" alt="taowu模块结构图"></p><h3 id="各个模块的基本介绍"><a href="#各个模块的基本介绍" class="headerlink" title="各个模块的基本介绍"></a>各个模块的基本介绍</h3><p>（ 1 ）仓储管理模块：该模块是用作于维护商品库存，当用户购物商品时会调用此模块进行扣减库存，在此模块中的难点是需要在高并发量的情况下库存不能被扣减到负数。</p><p>（ 2 ）订单模块：顾客在购买商品后需要调用的模块，首先会生成订单，在生成订单后进入消息队列等待用户的下一步操作，在此模块中难点繁多，需要进一步的设计优化。</p><p>（ 3 ）商品信息管理模块：商品信息中存在优惠信息管理和基本信息管理，优惠信息模块是用于维护商品的优惠劵的相关功能，基本信息管理模块是维护商品的名称、介绍、规格等等的相关信息功能。</p><p>（ 4 ）验证码模块：专门用做移动端和后端管理系统的登入和注册页面的验证码生成，验证码可以防止用户恶意注册，是安全防护措施的一种。</p><p>（ 5 ）用户管理模块：此模块分为商户管理和顾客管理，用户和顾客的基本信息都是由此模块进行维护的。</p><p>（ 6 ） 权限认证模块：用于对用户的身份以及权限进行校验，权限控制是决定着用户在此系统中可以访问哪些资源，权限控制的前提是该用户是本系统中已注册过的对象，这样可以过滤掉一些想恶意搞破坏的人，起到一定的安全保护作用。</p><p>（ 7 ）媒资文件管理模块：此模块中存在着这个系统中的所有文件的访问接口和上传文件的接口。</p><h2 id="数据库设计介绍"><a href="#数据库设计介绍" class="headerlink" title="数据库设计介绍"></a>数据库设计介绍</h2><p>数据库设计分为：需求分析、概念结构设计、逻辑结构设计、物理结构设计、数据库实施、数据库的运行和维护，现在对于数据库前面3个阶段进行说明</p><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>（ 1 ）核心需求描述</p><p>​一个顾客可以拥有多个收货地址，一个收货地址只属于一个顾客，一个顾客可以购买或者收藏多个商品，一个商品也可以被多名顾客购买或者收藏，当顾客下单后系统会生成订单，若一个顾客购买多个商品时可以生成多个订单，一个订单只能被一个商户查看，一个商户可以查看多个订单，商户是提供商品的实体，一个商品可以有多个商户公共提供，一个商品存储在不同仓库中，不同仓库也可以存储不同的商品，商品种类中有多个商品，一个商品只能归属于一个商品种类。</p><p>（ 2 ）数据字典</p><table><thead><tr><th align="center">实体对象</th><th align="center">基本属性</th></tr></thead><tbody><tr><td align="center">顾客</td><td align="center">用户id、用户名（账户名）、密码、手机号、昵称、自我介绍、个性签名、性别、头像、用户级别、注册时间、信息修改时间</td></tr><tr><td align="center">收货地址</td><td align="center">商品id、商品名称、标题、价格、图片（封面图片、展示图片）、所属分类id、是否上架、品牌</td></tr><tr><td align="center">订单</td><td align="center">订单号（全局唯一）、商品id、订单状态、下单用户、下单时间、结账时间、实收金额、商品数量、订单备注、付款方式、地址id、商品总价、运费、创建时间、发货时间、配送时间。</td></tr><tr><td align="center">商品种类</td><td align="center">种类id、种类名称、种类图片、商品数量、排序</td></tr><tr><td align="center">商品</td><td align="center">商品id、商品名称、标题、价格、图片（封面图片、展示图片）、所属分类id、是否上架、品牌</td></tr><tr><td align="center">商户</td><td align="center">商家id、商家名称、店铺名称、店铺LOGO、所在地、保证金（是否已交给平台）、是否有资质证照，综合评分、营业期限、公司类型、店铺联系人信息（姓名、手机号码、邮箱）、店铺类型</td></tr><tr><td align="center">仓库</td><td align="center">仓库id、仓库名称、仓库所在地址、区域编号、管理员名称</td></tr></tbody></table><h3 id="概念结构设计"><a href="#概念结构设计" class="headerlink" title="概念结构设计"></a>概念结构设计</h3><p>（ 1 ）概述：概念结构设计是整个数据库设计的关键。在概念结构的设计过程中，设计者要对用户需求进行综合、归纳和抽象，形成一个独立于具体计算机和DBMS的概念模型。</p><p>（ 2 ）E-R图展示</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230608135311525.png" alt="ER图"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;项目介绍&quot;&gt;&lt;a href=&quot;#项目介绍&quot; class=&quot;headerlink&quot; title=&quot;项目介绍&quot;&gt;&lt;/a&gt;项目介绍&lt;/h1&gt;&lt;p style=&quot;color:red&quot;&gt;因开发未完成，所以本文档内容非常的不完整，开发中会持续更新。&lt;/p&gt;

&lt;h2 id=&quot;</summary>
      
    
    
    
    
    <category term="自研项目;" scheme="http://example.com/tags/%E8%87%AA%E7%A0%94%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>spring-security</title>
    <link href="http://example.com/2023/03/03/spring-secuerity/"/>
    <id>http://example.com/2023/03/03/spring-secuerity/</id>
    <published>2023-03-02T16:00:00.000Z</published>
    <updated>2023-04-09T12:33:38.126Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><strong>官方概述：</strong></p><p>（ 1 ）Spring Security is a powerful and highly customizable authentication and access-control framework. It is the de-facto standard for securing Spring-based applications.</p><p>（ 2 ）Spring Security is a framework that focuses on providing both authentication and authorization to Java applications. Like all Spring projects, the real power of Spring Security is found in how easily it can be extended to meet custom requirements</p><p><strong>中文直译：</strong></p><p>（ 1 ）Spring Security是一个功能强大且高度可定制的<strong>身份验证</strong>和<strong>访问控制</strong>框架。它是保护基于 Spring 的应用程序的事实标准。</p><p>（ 2 ） Spring Security是一个专注于为 Java 应用程序提供<strong>身份验证</strong>和<strong>授权</strong>的框架。像所有Spring项目一样，Spring 安全性的真正的优势在于它可以轻松扩展以满足自定义需求。</p><p><strong>身份认证和授权</strong></p><p>（ 1 ）身份认证：验证当前访问系统的是不是本系统的用户，并且要确认具体是哪个用户</p><p>（ 2 ）授权：经过认证后判断当前用户是否有权限进行某个操作</p><h1 id="项目实战"><a href="#项目实战" class="headerlink" title="项目实战"></a>项目实战</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>（ 1 ）需要创建一个SpringBoot工程项目</p><p>（ 2 ）添加以下依赖坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.24<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（ 3 ）<strong>注意：</strong>SpringBoot的版本是【2.3.12.RELEASE】，jdk版本是【1.8】</p><p>（ 4 ）编写Controller层的前端控制器代码，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/quickstart&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/demo&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello world...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（ 5 ）引入Spring Security 的依赖坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当引入Spring Security后再启动项目，访问 quickstart&#x2F;demo 下的资源时，Spring Security会有个默认登入页面，只有登入成功后才能访问到目标资源，账户默认为 uesr 密码是Spring Security框架自动生成的密码，在后端控制台会显示出来。</p><h2 id="认证基本流程"><a href="#认证基本流程" class="headerlink" title="认证基本流程"></a>认证基本流程</h2><p>下图是用户认证生命周期图</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230303123345134.png" alt="用户认证生命周期图"></p><h2 id="Spring-Security的完整流程"><a href="#Spring-Security的完整流程" class="headerlink" title="Spring Security的完整流程"></a>Spring Security的完整流程</h2><p>SpringSecurity的原理其实就是一个过滤器链，内部包含了提供各种功能的过滤器。（注意：下图并不是SpringSecurity的全部链路过滤器）</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230303125305748.png" alt="SpringSecurity核心链图"></p><p>（ 1 ）UsernamePasswordAuthenticationFilter：负责处理我们在登陆页面填写了用户名密码后的登陆请求。入门案例的认证工作主要有它负责。</p><p>（ 2 ）ExceptionTtanslationFilter：处理过滤器链中抛出的任何AccessDeniedException和AuthenticationException 。</p><p>（ 3 ）FilterSecuritylnterceptor：负责权限校验的过滤器。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;官方概述：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（ 1 ）Spring Security is a powerful and h</summary>
      
    
    
    
    
    <category term="security" scheme="http://example.com/tags/security/"/>
    
  </entry>
  
  <entry>
    <title>基于JSR303的数据校验</title>
    <link href="http://example.com/2023/02/28/java%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C/"/>
    <id>http://example.com/2023/02/28/java%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C/</id>
    <published>2023-02-28T11:27:00.000Z</published>
    <updated>2023-03-01T06:21:29.965Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JSR303前言"><a href="#JSR303前言" class="headerlink" title="JSR303前言"></a>JSR303前言</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>​是 Java EE 6 中的一项子规范，叫做 Bean Validation，官方参考实现是hibernate Validator。此实现与 Hibernate ORM 没有任何关系。 JSR 303 用于对 Java  Bean 中的字段的值进行验证。 Spring MVC 3.x 之中也大力支持 JSR-303，可以在控制器中对表单提交的数据方便地验证。简而言之就是可以在Spring<strong>框架中使用注解进行数据校验</strong></p><h2 id="Bean-Validation"><a href="#Bean-Validation" class="headerlink" title="Bean Validation"></a>Bean Validation</h2><p><strong>概述：</strong>在任何时候，当你要处理一个应用程序的业务逻辑，数据校验是你必须要考虑和面对的事情。应用程序必须通过某种手段来确保输入进来的数据从语义上来讲是正确的。在通常的情况下，应用程序是分层的，不同的层由不同的开发人员来完成。很多时候同样的数据验证逻辑会出现在不同的层，这样就会导致代码冗余和一些管理的问题，比如说语义的一致性等。为了避免这样的情况发生，最好是将验证逻辑与相应的域模型进行绑定。</p><p>【Bean Validation】 为 JavaBean 验证定义了相应的元数据模型和 API。缺省的元数据是 Java Annotations，通过使用 XML 可以对原有的元数据信息进行覆盖和扩展。在应用程序中，通过使用 Bean Validation 或是你自己定义的 constraint，例如 @NotNull, @Max, @ZipCode ， 就可以确保【数据模型】的正确性。constraint 可以附加到字段，getter 方法，类或者接口上面。对于一些特定的需求，用户可以很容易的开发定制化的 constraint。Bean Validation 是一个运行时的数据验证框架，在验证之后验证的错误信息会被马上返回。</p><p style="color:red">数据模型指的是 “ JavaBean ”</p><h1 id="JSR303的使用"><a href="#JSR303的使用" class="headerlink" title="JSR303的使用"></a>JSR303的使用</h1><h2 id="依赖引入"><a href="#依赖引入" class="headerlink" title="依赖引入"></a>依赖引入</h2><p>（ 1 ）若是在<strong>SpringBoot项目</strong>上使用JSR303数据校验，则需要引入以下坐标即可</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-validation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（ 2 ）<strong>非SpringBoot项目</strong>，则需要引入以下坐标，注意两个都需要引入（原因：上面的坐标是规则，下面的坐标是实现，如果只有规则没有实现，则校验规则不会生效）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 规则 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.validation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>validation-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 实现 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.0.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="数据校验注解介绍"><a href="#数据校验注解介绍" class="headerlink" title="数据校验注解介绍"></a>数据校验注解介绍</h2><p>JSR 303 基本的校验规则是Bean Validation 中的 constraint（约束），那么以下是对常用的一些constraint介绍</p><p><strong>（ 1 ）Bean Validation 中内置的 constraint</strong></p><table><thead><tr><th align="center">constraint</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">@Null</td><td align="center">被注释的字段必须为 null</td></tr><tr><td align="center">@NotNull</td><td align="center">被注释的字段必须不为 null</td></tr><tr><td align="center">@AssertTrue</td><td align="center">被注释的字段必须为 true</td></tr><tr><td align="center">@AssertFalse</td><td align="center">被注释的字段必须为 false</td></tr><tr><td align="center">@Min(value)</td><td align="center">被注释的字段必须是一个数字，其值必须大于等于指定的最小值</td></tr><tr><td align="center">@Max(value)</td><td align="center">被注释的字段必须是一个数字，其值必须小于等于指定的最大值</td></tr><tr><td align="center">@DecimalMin(value)</td><td align="center">被注释的字段必须是一个数字，其值必须大于等于指定的最小值</td></tr><tr><td align="center">@DecimalMax(value)</td><td align="center">被注释的字段必须是一个数字，其值必须小于等于指定的最大值</td></tr><tr><td align="center">@Size(max, min)</td><td align="center">被注释的字段的大小必须在指定的范围内[max, min]</td></tr><tr><td align="center">@Digits (integer, fraction)</td><td align="center">被注释的字段必须是一个数字，其值必须在可接受的范围内</td></tr><tr><td align="center">@Past</td><td align="center">被注释的字段必须是一个过去的日期</td></tr><tr><td align="center">@Futuret</td><td align="center">被注释的字段必须是一个将来的日期</td></tr><tr><td align="center">@Pattern(value)</td><td align="center">被注释的字段必须符合指定的正则表达式</td></tr><tr><td align="center">@NotBlank</td><td align="center">只能作用在接收的String类型上，只能为空字符串，不能为null</td></tr></tbody></table><p><strong>（ 2 ）Hibernate Validator 附加的 constraint</strong></p><table><thead><tr><th align="center">constraint</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">@Email</td><td align="center">被注释的字段必须是电子邮箱地址</td></tr><tr><td align="center">@Length</td><td align="center">被注释的字符串的大小必须在指定的范围内</td></tr><tr><td align="center">@NotEmpty</td><td align="center">被注释的字符串的必须非空</td></tr><tr><td align="center">@Range</td><td align="center">被注释的字段必须在合适的范围内</td></tr></tbody></table><h2 id="项目实战"><a href="#项目实战" class="headerlink" title="项目实战"></a>项目实战</h2><p>本篇文章所涉及到的工具类如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（ 1 ）<strong>需求：</strong>对在保存用户信息前需进行信息校验，以下是用户信息实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;  <span class="comment">// 用户ID</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username; <span class="comment">// 名称</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String password; <span class="comment">// 密码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String email; <span class="comment">// 邮箱</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age; <span class="comment">// 年龄</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Date birthday; <span class="comment">// 生日</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer sex; <span class="comment">// 性别</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若是用传统的数据校验方式，则需要在业务方法上进行一系列的用户信息校验，这样会显得代码冗余且杂乱。若使用JSR303的校验方式，可以在实体类中使用注解来进行校验，大大的减少在业务方法上数据校验的代码，如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;  <span class="comment">// 用户ID</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotEmpty</span></span><br><span class="line">    <span class="keyword">private</span> String username; <span class="comment">// 名称</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Length(min = 6,max = 16)</span></span><br><span class="line">    <span class="keyword">private</span> String password; <span class="comment">// 密码</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Email</span></span><br><span class="line">    <span class="keyword">private</span> String email; <span class="comment">// 邮箱</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Range(min = 0, max = 120)</span></span><br><span class="line">    <span class="keyword">private</span> Integer age; <span class="comment">// 年龄</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Date birthday; <span class="comment">// 生日</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer sex; <span class="comment">// 性别</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（ 2 ）以下是Controller层的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  用户前端控制器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="meta">@Log4j2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/save&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">saveUser</span><span class="params">(<span class="meta">@Valid</span> <span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断数据校验是否有错误</span></span><br><span class="line">        log.info(<span class="string">&quot;user：&#123;&#125;&quot;</span>,user);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Result.success();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230301123044875.png" alt="注意图"></p><p>（ 3 ）后端返回给前端的数据格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  返回给前端的数据接口类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Result</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer status; <span class="comment">// 响应状态</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String msg; <span class="comment">// 响应信息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object data; <span class="comment">// 响应数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; error;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 数据处理成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">success</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Result</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Result</span>();</span><br><span class="line">        r.status = <span class="number">200</span>;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">success</span><span class="params">(Object data)</span> &#123;</span><br><span class="line">        <span class="type">Result</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Result</span>();</span><br><span class="line">        r.status = <span class="number">200</span>;</span><br><span class="line">        r.data = data;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 数据处理失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">error</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Result</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Result</span>();</span><br><span class="line">        r.status = <span class="number">500</span>;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">error</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        <span class="type">Result</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Result</span>();</span><br><span class="line">        r.status = <span class="number">500</span>;</span><br><span class="line">        r.msg = msg;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title function_">error</span><span class="params">(Map&lt;String,Object&gt; map)</span> &#123;</span><br><span class="line">        <span class="type">Result</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Result</span>();</span><br><span class="line">        r.status = <span class="number">500</span>;</span><br><span class="line">        r.error = map;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（ 4 ）用postman测试保存用户信息的功能</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230301122543611.png" alt="用户JSON数据"></p><p>（ 5 ）响应结果为下图</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230301122653195.png" alt="结果1"></p><p>（ 6 ）上图的响应结果对用户并不友好，我们可以在后端定义专门处理数据校验的统一异常处理器，当数据校验失败后会报一个参数校验无效错误，该错误为<strong>org.springframework.web.bind.MethodArgumentNotValidException</strong>，那么我们可以对该错误进行一个统一的拦截，并取出对应的错误字段和错误信息，封装错误信息并返回给前端。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  统一异常处理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理数据验证的异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(MethodArgumentNotValidException.class)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">handlerValidateDataException</span><span class="params">(MethodArgumentNotValidException mane)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.获取有异常的全部字段</span></span><br><span class="line">        List&lt;FieldError&gt; fieldErrors = mane.getBindingResult().getFieldErrors();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 遍历取出各个错误字段和错误信息</span></span><br><span class="line">        Map&lt;String, Object&gt; errorMap = fieldErrors</span><br><span class="line">                .stream()</span><br><span class="line">                .collect(Collectors</span><br><span class="line">                        .toMap(key -&gt; key.getField(), value -&gt; value.getDefaultMessage()));</span><br><span class="line">        <span class="comment">// 3. 返回</span></span><br><span class="line">        <span class="keyword">return</span> Result.error(errorMap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后端响应结果变为下图形式，这样的响应格式很容易的看出到底是哪个字段的数据校验失败了。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230301123633872.png" alt="结果2"></p><h2 id="自定义数据校验注解"><a href="#自定义数据校验注解" class="headerlink" title="自定义数据校验注解"></a>自定义数据校验注解</h2><p>在User实体类中还有个性别字段还未被校验，性别字段在实际的开发过程中一般用0或者1来代表男女，我们可以来自定义一个注解来专门校验性别字段的值</p><p><strong>进阶需求：</strong>自定义注解对User实体类中的sex（性别）字段进行校验，只能是0或1</p><h3 id="前提知识"><a href="#前提知识" class="headerlink" title="前提知识"></a>前提知识</h3><p>（ 1 ）自定义数据校验注解需要以下的注解支持，在自定义数据校验注解上必须要有以下注解。</p><table><thead><tr><th align="center">注解</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">@Documented</td><td align="center">注解是否将包含在JavaDoc中</td></tr><tr><td align="center">@Constraint</td><td align="center">绑定数据校验类</td></tr><tr><td align="center">@Target</td><td align="center">注解作用于什么地方，例如，类上、方法、字段…</td></tr><tr><td align="center">@Retention</td><td align="center">什么时候使用该注解</td></tr></tbody></table><p>（ 2 ）@Retention(RetentionPolicy.XXX)，下表是RetentionPolicy策略的可选项</p><table><thead><tr><th align="center">RetentionPolicy</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">RetentionPolicy.SOURCE</td><td align="center">仅存在于源代码中，编译阶段会被丢弃，不会包含于class字节码文件中</td></tr><tr><td align="center">RetentionPolicy.CLASS</td><td align="center">【默认策略】在class字节码文件中存在，在类加载的时被丢弃，运行时无法获取到</td></tr><tr><td align="center">RetentionPolicy.RUNTIME</td><td align="center">【常用】始终不会丢弃，可以使用反射获得该注解的信息</td></tr></tbody></table><p>（ 3 ）一个标注(annotation) 是通过@interface关键字来定义的，这个标注中的属性是声明成类似方法的样式根据Bean Validation API 规范的要求：在注解中必须要有以下三个字段定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">message</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&#123;&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Class&lt;? <span class="keyword">extends</span> <span class="title class_">Payload</span>&gt;[] payload() <span class="keyword">default</span> &#123;&#125;;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">字段名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">message</td><td align="center">用来定义默认得消息模版, 当这个约束条件被验证失败的时候,此属性来输出错误信息</td></tr><tr><td align="center">groups</td><td align="center">用于指定这个约束条件属于哪(些)个校验组进行数据校验，数组类型</td></tr><tr><td align="center">payload</td><td align="center">约束条件指定严重级别，这个属性并不被API自身所使用</td></tr></tbody></table><h3 id="进阶需求的实现"><a href="#进阶需求的实现" class="headerlink" title="进阶需求的实现"></a>进阶需求的实现</h3><p>（ 1 ）首先定义一个注解，注解的类型是@interface，如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Constraint(validatedBy = &#123;CheckSexIsValid.class&#125;)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.FIELD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SexValid &#123;</span><br><span class="line">    <span class="comment">// 默认错误信息提示</span></span><br><span class="line">    String <span class="title function_">message</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&#123;org.example.annotation.constraint.SexValid.message&#125;&quot;</span>;</span><br><span class="line">    <span class="comment">// 用于接收被注解的字段数据</span></span><br><span class="line">    <span class="type">int</span>[] vals();</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Payload</span>&gt;[] payload() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（ 2 ）定义数据校验的实现类，实现ConstraintValidator&lt;A extends Annotation, T&gt;接口，该接口是处理数据校验的代码逻辑实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  检查性别是否是0,1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CheckSexIsValid</span> <span class="keyword">implements</span> <span class="title class_">ConstraintValidator</span>&lt;SexValid,Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">(SexValid constraintAnnotation)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取被SexValid注解的约束值</span></span><br><span class="line">        <span class="type">int</span>[] vals = constraintAnnotation.vals();</span><br><span class="line">        <span class="comment">// 将约束值放入集合中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> val: vals) &#123;</span><br><span class="line">            set.add(val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(Integer integer, ConstraintValidatorContext constraintValidatorContext)</span> &#123;</span><br><span class="line">        <span class="comment">// 判断真实值是否符号约束值</span></span><br><span class="line">        <span class="keyword">return</span> set.contains(integer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（ 3 ）@Constraint注解是可以将数据校验的实现类（CheckSexIsValid）和注解（@SexValid）进行一个绑定，以下是@Constraint绑定的过程图</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230301132449401.png" alt="@Constraint绑定的过程图"></p><p>（ 4 ）测试数据如下图</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230301132632364.png" alt="测试数据"></p><p>（ 5 ）结果</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230301132744046.png" alt="结果图3"></p><h2 id="分组校验"><a href="#分组校验" class="headerlink" title="分组校验"></a>分组校验</h2><p><strong>概述：</strong>分组校验也是在项目开发中很常见的校验方法，例如，在开发中有些字段在某些操作是不需要进行数据校验的，这种情况是需要对该字段进行分组校验，<strong>常见的分组定义</strong>有Post，Delete，Put，Get分别对应增删改查这四个操作。</p><p><strong>需求：</strong>需对User实体类中的ID字段进行一个分组校验，当用户注册时不对ID进行一个数据校验，当用户修改信息时需要对用户ID进行一个非空校验。</p><p>（ 1 ）首先需要先定义一个保存组和修改组，只需要定义个注解，无需在注解内部添加字段，这里的注解最主要是起到一个标志的作用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  保存组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Insert &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  修改组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Update &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（ 2 ）如何进行分组呢？在【前提知识章节】中有写到，每个注解中都需要有的三个字段，其中一个字段group就是用来指定分组校验的</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230301135656220.png" alt="image-20230301135656220"></p><p>controller层的新增加一个用户修改测试接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PutMapping(&quot;/update&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">updateInfo</span><span class="params">(<span class="meta">@Validated(Update.class)</span> <span class="meta">@RequestBody</span> User user)</span> &#123;</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">&quot;user：&#123;&#125;&quot;</span>,user);</span><br><span class="line">    <span class="keyword">return</span> Result.success();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230301135925310.png" alt="注意事项图"></p><p>（ 3 ）用户注册的测试结果</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230301140411708.png" alt="用户注册的测试结果图"></p><p>（ 4 ）用户修改的测试结果</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230301140549342.png" alt="修改操作结果图"></p><h2 id="Validate和-Valid的区别"><a href="#Validate和-Valid的区别" class="headerlink" title="@Validate和@Valid的区别"></a>@Validate和@Valid的区别</h2><p><strong>@Validate的特点</strong></p><p>（ 1 ）【Spring】提供的验证注解：org.springframework.validation.annotation.Validated</p><p>（ 2 ）提供了一个【分组功能】，可以在入参验证时，根据不同的分组采用不同的验证机制</p><p>（ 3 ）可以用在类型、方法和方法参数上。但是不能用在成员属性（字段）上</p><p>（ 4 ）无法提示框架进行嵌套验证</p><p><strong>@Valid的特点</strong></p><p>（ 1 ）javax提供的验证注解：javax.validation.Valid</p><p>（ 2 ）作为标准JSR-303规范，还没有分组的功能</p><p>（ 3 ）能够用在成员属性（字段）上，提示验证框架进行嵌套验证</p><p style="color:red">总体上@Validate和@Valid没有太大的差别，使用的效果都是差不多的，若业务需求没有要求分组校验和嵌套验证时，这两个注解都是可以使用的且效果相同。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JSR303前言&quot;&gt;&lt;a href=&quot;#JSR303前言&quot; class=&quot;headerlink&quot; title=&quot;JSR303前言&quot;&gt;&lt;/a&gt;JSR303前言&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
    <category term="数据校验" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>Mysql进阶部分</title>
    <link href="http://example.com/2023/02/18/mysql%E8%BF%9B%E9%98%B6%E9%83%A8%E5%88%86/"/>
    <id>http://example.com/2023/02/18/mysql%E8%BF%9B%E9%98%B6%E9%83%A8%E5%88%86/</id>
    <published>2023-02-18T08:00:00.000Z</published>
    <updated>2023-03-02T04:54:29.935Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mysql事务"><a href="#Mysql事务" class="headerlink" title="Mysql事务"></a>Mysql事务</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作<strong>要么同时成功，要么同时失败</strong></p><p style="color:red">默认MySQL的事务是自动提交的，也就是说，当执行一条DML语句，MySQL会立即隐式的提交事务。</p><p>（1）设置事务手动提交</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># @<span class="variable">@autocommit</span>默认为<span class="number">1</span></span><br><span class="line"><span class="keyword">set</span> @<span class="variable">@autocommit</span> <span class="operator">=</span> <span class="number">0</span>; </span><br></pre></td></tr></table></figure><p>（2）事务提交命令</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure><p>（3）回滚事务</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rollback</span>;</span><br></pre></td></tr></table></figure><h2 id="事务的四大特性ACID"><a href="#事务的四大特性ACID" class="headerlink" title="事务的四大特性ACID"></a>事务的四大特性ACID</h2><table><thead><tr><th align="center">名称</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">原子性(Atomicity)</td><td align="center">事务是不可分割的最小操作单元，要么全部成功，要么全部失败</td></tr><tr><td align="center">一致性(Consistency)</td><td align="center">事务完成时，必须使所有的数据都保持一致状态</td></tr><tr><td align="center">隔离性(lsolation)</td><td align="center">数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下</td></tr><tr><td align="center">永久性(Durability)</td><td align="center">运行事务一旦提交或回滚，它对数据库中的数据的改变就是永久的</td></tr></tbody></table><h2 id="并发事务问题"><a href="#并发事务问题" class="headerlink" title="并发事务问题"></a>并发事务问题</h2><table><thead><tr><th align="center">问题</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">脏读</td><td align="center">一个事务读取到另一个事务未提交的数据</td></tr><tr><td align="center">不可重复读</td><td align="center">一个事务读取先后读取同一个数据，但两次读取的数据互不相同</td></tr><tr><td align="center">幻读</td><td align="center">一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了”幻影”。</td></tr></tbody></table><h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><table><thead><tr><th align="center">隔离级别</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻读</th></tr></thead><tbody><tr><td align="center">Read uncommitted</td><td align="center">✔</td><td align="center">✔</td><td align="center">✔</td></tr><tr><td align="center">Read committed</td><td align="center">✘</td><td align="center">✔</td><td align="center">✔</td></tr><tr><td align="center">Repeatable Read(默认)</td><td align="center">✘</td><td align="center">✘</td><td align="center">✔</td></tr><tr><td align="center">Serializable</td><td align="center">✘</td><td align="center">✘</td><td align="center">✘</td></tr></tbody></table><p>说明：在上表中✔表示该隔离级别的事务会导致该问题，✘反之。</p><h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><h2 id="Mysql体系架构"><a href="#Mysql体系架构" class="headerlink" title="Mysql体系架构"></a>Mysql体系架构</h2><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230218165207772.png" alt="image-20230218165207772"></p><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>（1）在创建表的时候可以指定存储引擎，语句如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span>表名(</span><br><span class="line">字段<span class="number">1</span> 字段<span class="number">1</span>类型[COMMENT 字段<span class="number">1</span>注释],</span><br><span class="line">...</span><br><span class="line">字段n 字段n类型[COMMENT字段n注释]</span><br><span class="line">)ENGINE<span class="operator">=</span> INNODB [COMMENT表注释];</span><br></pre></td></tr></table></figure><p>（2）查看当前数据库支持的存储引擎</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> ENGINE;</span><br></pre></td></tr></table></figure><h2 id="InnoDB存储引擎"><a href="#InnoDB存储引擎" class="headerlink" title="InnoDB存储引擎"></a>InnoDB存储引擎</h2><p>概述：InnoDB是一种兼顾高可靠性和高性能的通用存储引擎，在MySQL5.5之后，InnoDB是默认的MySQL存储引擎。</p><p>特点：</p><ul><li>DML操作遵循ACID模型，支持事务</li><li>行级锁，提高并发访问性能</li><li>支持外键FOREIGN KEY约束，保证数据的完整性和正确性</li></ul><p>文件：xxx.ibd: xx代表的是表名，innoDB引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm、sdi)、数据和索引</p><p>参数: innodb_file_per_table（mysql8.0后默认打开的）</p><p><strong>下图是InnoDB存储引擎的结构图</strong></p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230218170126078.png" alt="InnoDB存储引擎的结构图"></p><h2 id="MylSAM"><a href="#MylSAM" class="headerlink" title="MylSAM"></a>MylSAM</h2><p>介绍：MylSAM是MySQL早期的默认存储引擎。</p><p>特点：不支持事务，不支持外键支持表锁，不支持行锁，访问速度快</p><p>文件</p><ul><li><p>xxx.sdi：存储表结构信息</p></li><li><p>XXX.MYD：存储数据</p></li><li><p>xxx.MYI：存储索引</p></li></ul><h2 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h2><p>概述：Memory引擎的表数据时存储在内存中的，由于受到硬件问题、或断电问题的影响，只能将这些表作为临时表或缓存使用。</p><p>特点：内存存放、hash索引（默认)</p><p>文件：xxx.sdi：存储表结构信息</p><h2 id="存储引擎特点"><a href="#存储引擎特点" class="headerlink" title="存储引擎特点"></a>存储引擎特点</h2><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230219103941014.png" alt="image-20230219103941014"></p><h2 id="存储引擎的选择"><a href="#存储引擎的选择" class="headerlink" title="存储引擎的选择"></a>存储引擎的选择</h2><p>在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。</p><table><thead><tr><th align="center">存储引擎</th><th align="center">特点</th></tr></thead><tbody><tr><td align="center">InnoDB</td><td align="center">Mysql的默认存储引擎，支持事务、外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择。</td></tr><tr><td align="center">MylSAM</td><td align="center">如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。</td></tr><tr><td align="center">Memory</td><td align="center">将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性。</td></tr></tbody></table><h1 id="Mysql安装（Linux版本）"><a href="#Mysql安装（Linux版本）" class="headerlink" title="Mysql安装（Linux版本）"></a>Mysql安装（Linux版本）</h1><p>（ 1 ）进入官网地址下载         </p><p><a href="https://downloads.mysql.com/archives/community/">https://downloads.mysql.com/archives/community/</a></p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230219105506257.png" alt="image-20230219105506257"></p><p>（ 2 ）将安装包上传到Linux系统上，然后进行压缩</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建目录，放mysql的包</span></span><br><span class="line">mkdir mysql</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">压缩命令</span></span><br><span class="line">tar -xvf 压缩包名称 -C mysql</span><br></pre></td></tr></table></figure><p>（ 3 ）解压完成后会看见很多的带有rpm后缀的安装包，该安装是严格安装一下步骤一步一步解压，否则会包依赖相关的错误</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh mysgl-community-common-8.0.26-1.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line">rpm -ivh mysql-community-client-plugins-8.0.26-1.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line">rpm -ivh mysql-community-libs-8.0.26-1.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line">rpm -ivh mysql-community-libs-compat-8.0.26-1.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line">yum install openssl-devel</span><br><span class="line"></span><br><span class="line">rpm -ivh mysql-community-devel-8.0.26-1.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line">rpm -ivh mysql-community-client-8.0.26-1.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line">rpm -ivh mysql-community-server-8.0.26-1.el7.x86_64.rpm</span><br></pre></td></tr></table></figure><p>（ 4 ）启动MySQL服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">systemctl start mysqld</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止MySQL服务</span></span><br><span class="line">systemctl stop mysqld</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重新启动</span></span><br><span class="line">systemctl restart mysqld</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开机自启</span></span><br><span class="line">systemctl enable mysqld</span><br></pre></td></tr></table></figure><p>（ 5 ）查询自动生成的root用户密码，需要进入mysql的目录下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &#x27;temporary password&#x27; /var/log/mysqld.log</span><br></pre></td></tr></table></figure><p>（ 6 ）查询完后，执行以下指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p 密码</span><br></pre></td></tr></table></figure><p>（ 7 ）修改mysql初始自动生成的密码，因为自动生成的密码复杂，不便于记忆，【需要登入到MySQL中执行】</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> <span class="string">&#x27;root&#x27;</span>@ <span class="string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;1234 &#x27;</span>;</span><br></pre></td></tr></table></figure><p>（ 8 ）执行上述的sql会报错，原因是因为设置的密码太简单，密码复杂度不够。我们可以设置密码的复杂度为简单类型，密码长度为4。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> validate_password.policy <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> validate_password.length <span class="operator">=</span> <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>最后再执行第（7）步的指令</p><p>（ 9 ）默认的root用户只能当前节点localhost访问，是无法远程访问的，我们还需要创建一个root账户，用户远程访问</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%’ IDENTIFIED WITH mysql_native_password BY &#x27;</span><span class="number">1234</span> <span class="string">&#x27;;</span></span><br></pre></td></tr></table></figure><p>（ 10 ）若还不能成功远程访问，则是linux的防火墙是默认不让外界访问的，需要开放端口让外界进行访问，MySQL的端口是3306，则执行以下指令即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=3306/tcp --permanent</span><br><span class="line"></span><br><span class="line">firewall-cmd --reload</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看开启的防火墙</span></span><br><span class="line">firewall-cmd --list-ports</span><br></pre></td></tr></table></figure><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>概述：索引(index)是帮助MysQL<strong>高效获取数据</strong>的<strong>数据结构</strong>(有序)。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。</p><p>假设，现执行SQL语句【select * from user where age &#x3D; 45】，全表扫描就是指的查找到age&#x3D;45的人后会往后继续查找，直到所有的行都被扫描到停止。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230219125523388.png" alt="image-20230219125523388"></p><p style="color:red">注意：上述二叉树索引结构的只是一个示意图，并不是真实的索引结构</p><p><strong>索引的优缺点：</strong></p><table><thead><tr><th align="center">优势</th><th align="center">劣势</th></tr></thead><tbody><tr><td align="center">提高数据检索的效率，降低数据库的IO成本</td><td align="center">索引列也是要占用空间的</td></tr><tr><td align="center">通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗</td><td align="center">索引大大提高了查询效率，同时却也降低更新表（增删改）的速度，</td></tr></tbody></table><h2 id="索引结构-Btree"><a href="#索引结构-Btree" class="headerlink" title="索引结构-Btree"></a>索引结构-Btree</h2><p>下图是二叉树的示意图，缺点是：顺序插入时会形成一个链表，查询效率就会大大降低，在大数据的情况下，二叉树层级较深，检索速度慢</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230219151448437.png" alt="image-20230219151448437"></p><p>【Btree】</p><p>以一颗最大度数(max-degree)为5(5阶)的b-tree为例（每个节点最多存储4个key，5个指针）</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230219151710809.png" alt="image-20230219151710809"></p><h2 id="索引结构-B-tree"><a href="#索引结构-B-tree" class="headerlink" title="索引结构-B+tree"></a>索引结构-B+tree</h2><p>相对于B-Tree区别：</p><p>（ 1 ）所有的数据都会出现在叶子节点</p><p>（ 2 ）叶子节点形成一个双向链表</p><p>MySQL索引数据结构对经典的B-Tree进行了优化。在原B-Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230219152041954.png" alt="image-20230219152041954"></p><h2 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h2><p>概述：哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。如果两个（或多个）键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表来解决。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230219152404629.png" alt="image-20230219152404629"></p><p>Hash索引特点：</p><p>（ 1 ）Hash索引只能用于对等比较(&#x3D;，in)，不支持范围查询（between，&gt;，&lt;，…）</p><p>（ 2 ）无法利用索引完成排序操作</p><p>（ 3 ）查询效率高，通常只需要一次检索就可以了，效率通常要高于B+tree索引</p><p><strong>【为什么InnoDB存储引擎选择使用B+tree索引结构？】</strong></p><p>答：相对于二叉树，层级更少，搜索效率高；对于B-tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低；相对Hash索引，B+tree支持范围匹配及排序操作。</p><h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h2><table><thead><tr><th align="center">分类</th><th align="center">含义</th><th align="center">特点</th><th align="center">关键字</th></tr></thead><tbody><tr><td align="center">主键索引</td><td align="center">针对于表中主键创建的索引</td><td align="center">默认自动创建，只能有一个</td><td align="center">PRIMARY</td></tr><tr><td align="center">唯一索引</td><td align="center">避免同一个表中某数据列中的值重复</td><td align="center">可以有多个</td><td align="center">UNIQUE</td></tr><tr><td align="center">常规索引</td><td align="center">快速定位特定数据</td><td align="center">可以有多个</td><td align="center"></td></tr><tr><td align="center">全文索引</td><td align="center">全文索引查找的是文本中的关键词，而不是比较索引中的值</td><td align="center">可以有多个</td><td align="center">FULLTEXT</td></tr></tbody></table><p>在InnoDB存储引擎中，根据索引的存储形式，又可以分为以下两种</p><table><thead><tr><th align="center">分类</th><th align="center">含义</th><th align="center">特点</th></tr></thead><tbody><tr><td align="center">聚集索引(Clustered Index)</td><td align="center">将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据</td><td align="center">必须有，而且只有一个</td></tr><tr><td align="center">二级索引(Secondary Index)</td><td align="center">将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键</td><td align="center">可以存在多个</td></tr></tbody></table><p>聚集索引选取规则如下</p><p>（ 1 ）如果存在主键，主键索引就是聚集索引。</p><p>（ 2 ）如果不存在主键，将使用第一个唯一(UNIQUE）索引作为聚集索引。</p><p>（ 3 ）如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引。</p><p>在下图，红色的是代表聚集索引，例如id就是聚集索引，绿色部分是二级索引name，可以通过聚集索引找到某一行的全部数据，而二级索引只能找到某一行的主键ID</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230219154447939.png" alt="image-20230219154447939"></p><p><strong>回表查询：</strong>就是先根据二级索引查到聚集索引的主键ID值，再根据主键ID值到聚集索引中查询到行数据</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230219154910984.png" alt="image-20230219154910984"></p><h2 id="索引语法"><a href="#索引语法" class="headerlink" title="索引语法"></a>索引语法</h2><p>（ 1 ）创建索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> [<span class="keyword">unique</span> <span class="operator">|</span> fulltext] index IndexName <span class="keyword">on</span> TableName(index_one...);</span><br></pre></td></tr></table></figure><p>（ 2 ）查看索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> TableName(表名)</span><br></pre></td></tr></table></figure><p>（ 3 ）删除索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> index IndexName <span class="keyword">from</span> TableName</span><br></pre></td></tr></table></figure><h2 id="SQL性能优化"><a href="#SQL性能优化" class="headerlink" title="SQL性能优化"></a>SQL性能优化</h2><p><strong>（ 1 ） 执行频率</strong></p><p>MysQL客户端连接成功后，通过show [sessionlgloball] status 命令可以提供服务器状态信息。通过如下指令，可以查看当前数据库的INSERT、UPDATE、DELETE、SELECT的访问频次</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> status <span class="keyword">like</span> <span class="string">&#x27;Com_______&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>（ 2 ）慢查询日志</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;slow_query_log&#x27;</span>; </span><br></pre></td></tr></table></figure><p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。<strong>MySQL的慢查询日志默认没有开启</strong>，需要在MySQL的配置文件（&#x2F;etc&#x2F;my.cnf）中配置如下信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#开启MySQL慢日志查询开关</span><br><span class="line">slow_query_log=1</span><br><span class="line"></span><br><span class="line">#设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志</span><br><span class="line">long_query_time=2</span><br></pre></td></tr></table></figure><p><strong>（ 3 ）profile详情</strong></p><p>show profiles能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。通过have_profiling参数，能够看到当前MysQL是否支持</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@have</span>_profiling;</span><br></pre></td></tr></table></figure><p>默认profiling是关闭的，可以通过set语句在session&#x2F;global级别开启profiling</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> profiling <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>执行一系列的业务SQL的操作，然后通过如下指令查看指令的执行耗时</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#查看每一条<span class="keyword">SQL</span>的耗时基本情况</span><br><span class="line"><span class="keyword">show</span> profiles;</span><br><span class="line"></span><br><span class="line">#查看指定query_id的<span class="keyword">SQL</span>语句各个阶段的耗时情况</span><br><span class="line"><span class="keyword">show</span> profile <span class="keyword">for</span> query query_id;</span><br><span class="line"></span><br><span class="line">#查看指定query_id的<span class="keyword">SQL</span>语句CPU的使用情况</span><br><span class="line"><span class="keyword">show</span> profile cpu <span class="keyword">for</span> query query_id;</span><br></pre></td></tr></table></figure><p><strong>（ 4 ）explain执行计划</strong></p><p>EXPLAIN或者DESC命令获取MySQL如何执行SELECT语句的信息，包括在SELECT语句执行过程中表如何连接和连接的顺序。</p><p>语法如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 条件;</span><br></pre></td></tr></table></figure><p>使用EXPLAIN语法后会出现下图的表结构</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230219170142286.png" alt="image-20230219170142286"></p><p>下表是对上图的各个字段的含义解释</p><table><thead><tr><th align="center">字段</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">表示查询中执行select子句或者是操作表的顺序【id相同，执行顺序从上到下；id不同，值越大，越先执行】。</td></tr><tr><td align="center">select_type</td><td align="center">表示SELECT的类型，常见的取值有SIMPLE（简单表，即不使用表连接或者子查询)、PRIMARY(主查询，即外层的查询)、UNION（UNION中的第二个或者后面的查询语句）、SUBQUERY (SELECT&#x2F;WHERE之后包含了子查询）等</td></tr><tr><td align="center">type</td><td align="center">表示连接类型，性能由好到差的连接类型为NULL、system、const、eq_ref、ref、range、index、all</td></tr><tr><td align="center">possible_keys</td><td align="center">显示可能应用在这张表上的索引，一个或多个。</td></tr><tr><td align="center">key</td><td align="center">实际使用的索引，如果为NULL，则没有使用索引</td></tr><tr><td align="center">key_len</td><td align="center">表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好。</td></tr><tr><td align="center">rows</td><td align="center">MySQL认为必须要执行查询的行数，在innodb引擎的表中，是一个估计值，可能并不总是准确的。</td></tr><tr><td align="center">filtered</td><td align="center">表示返回结果的行数占需读取行数的百分比， filtered的值越大越好。</td></tr></tbody></table><p>type字段的各个连接类型含义如下</p><table><thead><tr><th align="center">连接类型</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">all</td><td align="center">MySQL将遍历全表以找到匹配的行</td></tr><tr><td align="center">index</td><td align="center">遍历索引树</td></tr><tr><td align="center">range</td><td align="center">索引范围扫描，对索引的扫描开始于某一点，返回匹配值域的行，常见于between、&lt;、&gt;等的查询</td></tr><tr><td align="center">ref</td><td align="center">非唯一性索引扫描，返回匹配某个单独值的所有行</td></tr><tr><td align="center">eq_ref</td><td align="center">唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描</td></tr><tr><td align="center">const、system</td><td align="center">当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问</td></tr><tr><td align="center">NULL</td><td align="center">MySQL在优化过程中分解语句，执行时甚至不用访问表或索引</td></tr></tbody></table><h2 id="索引使用"><a href="#索引使用" class="headerlink" title="索引使用"></a>索引使用</h2><p><strong>（ 1 ）最左前缀法则</strong></p><p>如果索引了多列（联合索引），要遵守最左前缀法则。最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳跃某一列，索引将部分失效（后面的字段索引失效）。</p><p>【例】现存在一张学生表且该表中存在联合索引，索引名（pro_age_status）这是三个字段组成的，执行以下查询语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">where</span> profession<span class="operator">=</span>&quot;软件工程&quot; <span class="keyword">and</span> age <span class="operator">=</span> <span class="number">15</span> <span class="keyword">and</span> status <span class="operator">=</span> <span class="number">0</span> </span><br></pre></td></tr></table></figure><p>是遵守最左前缀法则的，因为查询条件中把所有的联合索引的字段都用上了，下列语句是不遵守最左前缀法则，因为把最左边的profession条件给跳过了</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">where</span> age <span class="operator">=</span> <span class="number">15</span> <span class="keyword">and</span> status <span class="operator">=</span> <span class="number">0</span> </span><br></pre></td></tr></table></figure><p><strong>（ 2 ）范围查询：</strong>联合索引中，出现范围查询(&gt;，&lt;)，范围查询右侧的列索引失效</p><p><strong>（ 3 ）索引列运算：</strong>不要在索引列上进行运算操作，<span style="color:red">索引将失效</span >。</p><p><strong>（ 4 ）字符串不加引号：</strong>字符串类型字段使用时，不加引号，<span style="color:red">索引将失效</span >。</p><p><strong>（ 5 ）模糊查询：</strong>如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，<span style="color:red">索引失效</span >。</p><p>【例】若是按下面第一条SQL查询语句是不会造成索引失效的，第二条和第三条是会造成索引失效</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">like</span> <span class="string">&#x27;张%&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">like</span> <span class="string">&#x27;%张&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">like</span> <span class="string">&#x27;%张%&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>（ 6 ）用or连接查询条件：</strong>用or分割开的条件，如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到 ，<span style="color:red">索引失效</span >。</p><p>【例】现存在一张student表且age没有索引，其余条件都有索引，则若条件中存在用or拼接age字段条件，则索引失效，如下SQL语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> age <span class="operator">=</span> <span class="number">10</span> <span class="keyword">or</span> phone <span class="operator">=</span> <span class="string">&#x27;15632415271&#x27;</span> <span class="keyword">or</span> id <span class="operator">=</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p>由于age没有索引，所以即使id、phone有索引，索引也会失效。所以需要针对于age也要建立索引。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_stu_age <span class="keyword">on</span> student(age);</span><br></pre></td></tr></table></figure><p><strong>（ 7 ）数据分布影响：</strong>如果MySQL评估使用索引比全表更慢，则不使用索引。</p><p><strong>（ 8 ）SQL提示：</strong>SQL提示，是优化数据库的一个重要手段，简单来说，就是在5QL语句中加入一些人为的提示来达到优化操作的目的。</p><p><strong>（ 9 ）覆盖索引：</strong>尽量使用覆盖索引（查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到）减少select * 的写法。</p><p>【思考】一张表，有四个字段（id, username, password , status)，由于数据量大，需要对以下SQL语句进行优化，该如何进行才是最优方案</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id, username, password <span class="keyword">from</span> tb_user <span class="keyword">where</span> username <span class="operator">=</span> <span class="string">&#x27;lisi&#x27;</span>;</span><br></pre></td></tr></table></figure><p>答：若只建立username索引，虽然能提高性能，但也是需要进行回表查询的，并不是最优方案，应该建立（username,password）这两个字段的联合索引</p><p><strong>（ 10 ）前缀索引：</strong>当字段类型为字符串（varchar, text等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO，影响查询效率。此时可以只将字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。</p><p>【语法如下】</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> index idx_xxxxx <span class="keyword">on</span> table_name(<span class="keyword">column</span>(n)); # n是取字段前缀的长度作为索引</span><br></pre></td></tr></table></figure><p><strong>（ 11 ）单列索引与联合索引</strong></p><p>单例索引：索引只包含一个列</p><p>联合索引：索引包含了多个列</p><p>在业务场景中若出现了多个查询条件，考虑对查询字段建立索引时建议建立联合索引，而非单列索引，<span style="color:red" >多条件联合查询时，MySQL优化器会评估哪个字段的索引效率更高，会选择该索引完成本次查询。</span></p><p>【例】执行以下SQL语句，若数据量特别大，则最优方案是建立（name，phone）的联合索引，这样建立索引则可以避免【回表查询】。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id,phone,name <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;张三&#x27;</span> <span class="keyword">and</span> phone <span class="operator">=</span> <span class="string">&#x27;14526321451&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230220195114569.png" alt="image-20230220195114569"></p><h2 id="索引的设计原则"><a href="#索引的设计原则" class="headerlink" title="索引的设计原则"></a>索引的设计原则</h2><p>（ 1 ）针对于数据量较大，且查询比较频繁的表建立索引。</p><p>（ 2 ）针对于常作为查询条件(where)、排序(order by)、分组(group by)操作的字段建立索引。</p><p>（ 3 ）尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。</p><p>（ 4 ）如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立【前缀索引】。</p><p>（ 5 ）尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。</p><p>（ 6 ）要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。</p><p>（ 7 ）如果索引列不能存储NULL值，请在创建表时使用NOTNULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询。</p><h1 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h1><h2 id="Insert优化"><a href="#Insert优化" class="headerlink" title="Insert优化"></a>Insert优化</h2><p>（ 1 ）批量插入</p><p>（ 2 ）手动提交事务</p><p>（ 3 ）主键按顺序插入：在批量插入时主键最好是按照升序或者降序插入。</p><p>（ 4 ）若涉及到大量数据（超过100w的数据量）最好使用Mysql中的<strong>load指令</strong>进行插入数据</p><p>使用<strong>load指令</strong>的前提设置如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#客户端连接服务端时，加上参数<span class="comment">--local-infile</span></span><br><span class="line">mysql <span class="comment">--local-infile -u root-p</span></span><br><span class="line"></span><br><span class="line">#设置全局参数local_infile为<span class="number">1</span>，开启从本地加载文件导入数据的开关</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> local_infile <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">#执行load指令将准备好的数据，加载到表结构中</span><br><span class="line">load data <span class="keyword">local</span> infile <span class="string">&#x27;/root/sql1.log&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> <span class="string">&#x27;tb_user&#x27;</span> fields terminated <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span> lines terminated <span class="keyword">by</span> <span class="string">&#x27;\n&#x27;</span> ;</span><br></pre></td></tr></table></figure><h2 id="主键优化"><a href="#主键优化" class="headerlink" title="主键优化"></a>主键优化</h2><p><strong>前提知识</strong></p><p><span style="color:blue">（ 1 ）数据组织方式：</span>在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表(index organized table IOT)。</p><p>下图中除了叶子节点上挂着对应的行数据，非叶子节点的ID只起到索引的作用。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230220205523785.png" alt="image-20230220205523785"></p><p><span style="color:blue">（ 2 ）页分裂：</span>页可以为空，也可以填充一半，也可以填充100%。每个页<span style="color:red">至少包含了2-N行数据</span>（如果一行数据过大，会产生行溢出），根据主键排列。</p><p><strong>主键顺序插入：</strong>不会产生【页分裂】现象，这样mysql数据库就可以省去页的重新填充的步骤，可以提高运行效率。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230220210000080.png" alt="image-20230220210000080"></p><p><strong>主键乱序插入：</strong>下图是页分裂的整体过程，说明：原本存在1# page和2# page这两张页数据（满），现ID为50的行数据要插入到表中，因为原本的页是满的，所以数据库会创建新页存储新数据，数据库系统会根据主键进行重新排序。如下过程</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230220211130870.png" alt="image-20230220211130870"></p><p><span style="color:blue">（ 3 ）页合并：</span>当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记（flaged）为删除并且它的空间变得允许被其他记录声明使用。</p><p>当页中删除的记录达到MERGE_THRESHOLD（默认为页的50%），InnoDB会开始寻找最靠近的页（前或后）看看是否可以将两个页合并以优化空间使用。</p><h3 id="主键设计原则"><a href="#主键设计原则" class="headerlink" title="主键设计原则"></a>主键设计原则</h3><p>（ 1 ）满足业务需求的情况下，尽量降低主键的长度。</p><p>（ 2 ）插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键。</p><p>（ 3 ）尽量不要使用UUID做主键或者是其他自然主键，如身份证号。</p><p>（ 4 ）业务操作时尽量减少主键的修改</p><h2 id="order-by-优化"><a href="#order-by-优化" class="headerlink" title="order by 优化"></a>order by 优化</h2><p>下列两个参数是在使用explain（执行计划）中出现在Extra列中</p><p><strong>（ 1 ）Using filesort：</strong>通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区sortbuffer中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫FileSort排序。</p><p><strong>（ 2 ）Using index：</strong>通过有序索引顺序扫描直接返回有序数据，这种情况即为using index，不需要额外排序，操作效率高。</p><p><strong>order by 优化的建议：</strong></p><p>（ 1 ）根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则。</p><p>（ 2 ）尽量使用覆盖索引。</p><p>（ 3 ）多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则(ASC&#x2F;DESC)。</p><p>（ 4 ）如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小 sort_buffer_size(默认256k)。</p><h2 id="group-by-优化"><a href="#group-by-优化" class="headerlink" title="group by 优化"></a>group by 优化</h2><p>（ 1 ）在分组操作时，可以通过索引来提高效率。</p><p>（ 2 ）分组操作时，索引的使用也是满足最左前缀法则</p><h2 id="limit优化"><a href="#limit优化" class="headerlink" title="limit优化"></a>limit优化</h2><p>一个常见又非常头疼的问题就是limit 2000000,10，此时需要MySQL排序前2000010记录，仅仅返回2000000 - 2000010的记录，其他记录丢弃，查询排序的代价非常大。</p><p><strong>优化思路：</strong>一般分页查询时，通过创建覆盖索引能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 先创建需要查找字段的联合索引</span><br><span class="line"><span class="keyword">create</span> index idx_na_emi_pro_age <span class="keyword">on</span> student(name,email,profession,age);</span><br><span class="line"></span><br><span class="line"># 联表查询</span><br><span class="line"><span class="keyword">select</span> s.id,s.name,s.email,s.profession,s.age </span><br><span class="line"><span class="keyword">from</span> student s, (<span class="keyword">select</span> id <span class="keyword">from</span> student limit <span class="number">900000</span>,<span class="number">10</span>) x <span class="keyword">where</span> s.id <span class="operator">=</span> x.id;</span><br></pre></td></tr></table></figure><h2 id="count优化"><a href="#count优化" class="headerlink" title="count优化"></a>count优化</h2><p><strong>count的几种用法：</strong></p><p>（ 1 ）count()是一个聚合函数，对于返回的结果集，一行行地判断，如果count函数的参数不是NUL，累计值就加1，否则不加，最后返回累计值。</p><p>（ 2 ）用法：count (*) 、count(主键)、count(字段)、count (1)</p><p><span style="color:red">count(主键)：</span>InnoDB引擎会遍历整张表，把每一行的主键id 值都取出来，返回给服务层。服务层拿到主键后，直接按行进行累加(主键不可能为null)。</p><p><span style="color:red">count(字段)</span></p><p>​情况一：没有not null约束，InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为null，不为null，计数累加。</p><p>​情况二：有not null约束， InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加。</p><p><span style="color:red">count (1)：</span>InnoDB引擎遍历整张表，但不取值。服务层对于返回的每一行，放一个数字“1”进去，直接按行进行累加。</p><p><span style="color:red">count (*)：</span>InnoDB引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加。</p><p><strong>执行效率：count (*)  ≈ count(1) &gt; count(主键) &gt; count(字段)</strong></p><h2 id="update优化"><a href="#update优化" class="headerlink" title="update优化"></a>update优化</h2><p><strong>优化方案：</strong>按照条件去更新某个数据时，该条件字段最好是索引字段，否则行锁会升级为表锁，锁的范围加大，性能降低，并发能力也会随其降低。</p><p style="color:red">注意：InnoDB的行锁是针对索引加的锁，不是针对记录加的锁,并且该索引不能失效，否则会从行锁升级为表锁。</p><h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><p>概述：视图(View)是一种虚拟存在的表。视图中的数据并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。</p><p><strong>通俗的讲，视图只保存了查询的SQL逻辑，不保存查询结果。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。</strong></p><h2 id="相关语法"><a href="#相关语法" class="headerlink" title="相关语法"></a>相关语法</h2><p>（ 1 ）创建视图</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">OR</span> REPLACE] <span class="keyword">VIEW</span> 视图名称[(列名列表)] <span class="keyword">AS</span> <span class="keyword">SELECT</span>语句 [<span class="keyword">WITH</span> <span class="operator">|</span> <span class="keyword">CASCADED</span> <span class="operator">|</span> <span class="keyword">LOCAL</span> <span class="operator">|</span> <span class="keyword">CHECK</span> OPTION]</span><br></pre></td></tr></table></figure><p>（ 2 ）查询视图</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段名 <span class="keyword">FROM</span> <span class="keyword">VIEW</span>名称</span><br></pre></td></tr></table></figure><p>（ 3 ）修改视图</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 方式一</span><br><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">OR</span> REPLACE] <span class="keyword">VIEW</span> 视图名称[(列名列表)] <span class="keyword">AS</span> <span class="keyword">SELECT</span>语句 [<span class="keyword">WITH</span> <span class="operator">|</span> <span class="keyword">CASCADED</span> <span class="operator">|</span> <span class="keyword">LOCAL</span> <span class="operator">|</span> <span class="keyword">CHECK</span> OPTION]</span><br><span class="line"># 方式二</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">VIEW</span> 视图名称[(列名列表)] <span class="keyword">AS</span> <span class="keyword">SELECT</span>语句 [<span class="keyword">WITH</span> <span class="operator">|</span> <span class="keyword">CASCADED</span> <span class="operator">|</span> <span class="keyword">LOCAL</span> <span class="operator">|</span> <span class="keyword">CHECK</span> OPTION]</span><br></pre></td></tr></table></figure><p>（ 4 ）删除视图</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> [IF <span class="keyword">EXISTS</span>] 视图名称...</span><br></pre></td></tr></table></figure><h2 id="视图检查选项"><a href="#视图检查选项" class="headerlink" title="视图检查选项"></a>视图检查选项</h2><p><strong>概述：</strong>当使用WITH CHECK OPTION子句创建视图时，MySQL会通过视图检查正在更改的每个行，例如插入，更新，删除，以使其符合视图的定义。MySQL允许基于另一个视图创建视图，它还会检查依赖视图中的规则以保持一致性。为了确定检查的范围，mysql提供了两个选项：CASCADED和LOCAL，默认值为CASCADED。</p><p>【例】现假设存在一张student(id, name, profession, email, age)表，需要创建一个视图，分别执行了以下指令</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">1.</span> 创建视图</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> stu_v_1 <span class="keyword">as</span> <span class="keyword">select</span> id,name,profession <span class="keyword">from</span> student <span class="keyword">where</span> id <span class="operator">&lt;=</span> <span class="number">16</span>;</span><br><span class="line"># <span class="number">2.</span> 插入数据</span><br><span class="line"><span class="keyword">insert</span> stu_v_1 <span class="keyword">values</span>(<span class="number">14</span>,<span class="string">&#x27;Rocy&#x27;</span>,<span class="string">&#x27;计算机科学与技术&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> stu_v_1 <span class="keyword">values</span>(<span class="number">22</span>,<span class="string">&#x27;Tom&#x27;</span>,<span class="string">&#x27;计算机科学与技术&#x27;</span>);</span><br></pre></td></tr></table></figure><p>在插入数据的两条指令都会插入成功的，但第二条指令的数据不会出现在视图表中，只会插入到基本表里，原因是：在创建视图中存在条件ID小于16，视图中就只显示ID&lt;&#x3D;16的数据。</p><p><strong>说明：</strong>让插入数据中的第二条指令插入成功是不合理的，所以我们需要限制超出条件的数据插入到基本表中，可以使用视图检查选项，如下语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> stu_v_1 <span class="keyword">as</span> </span><br><span class="line"><span class="keyword">select</span> id,name,profession <span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">where</span> id <span class="operator">&lt;=</span> <span class="number">16</span> <span class="keyword">with</span> <span class="keyword">cascaded</span> <span class="keyword">check</span> option;</span><br></pre></td></tr></table></figure><p>在创建或修改视图的语句中多添加with cascaded check option指令即可防止超出视图条件的数据更新、修改、删除。</p><h2 id="更新及作用"><a href="#更新及作用" class="headerlink" title="更新及作用"></a>更新及作用</h2><p>要使视图可更新，视图中的行与基础表中的行之间必须存在一对一的关系。如果视图包含以下任何一项，则该视图不可更新：</p><p>（ 1 ）聚合函数或窗口函数，SUM()、MIN()、MAX()、COUNT()等</p><p>（ 2 ）DISTINCT</p><p>（ 3 ）GROUP BY</p><p>（ 4 ）HAVING</p><p>（ 5 ）UNION或者UNION ALL</p><p><strong>作用如下</strong></p><p><span style="color:blue">（ 1 ）简单：</span>视图不仅可以简化用户对数据的理解，也可以简化他们的操作。那些被经常使用的查询可以被定义为视图，从而使得用户不必为以后的操作每次指定全部的条件</p><p><span style="color:blue">（ 2 ）安全：</span>数据库可以授权，但不能授权到数据库特定行和特定的列上。通过视图用户只能查询和修改他们所能见到的数据</p><p><span style="color:blue">（ 2 ）数据独立：</span>视图可以屏蔽真实表的变化从而给用户带来的影响</p><h1 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h1><p><strong>概述：</strong>存储过程是事先经过编译并存储在数据库中的一段SQL语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。存储过程思想上很简单，就是数据库SQL语言层面的代码封装与重用。</p><p>特点</p><p>（ 1 ）封装，复用</p><p>（ 2 ）可以接收参数，也可以返回数据</p><p>（ 3 ）减少网络交互，效率提升</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>（ 1 ）创建存储过程的语法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> 存储过程名称([参数列表])</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="comment">-- SQL语句</span></span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>（ 2 ）调用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">call</span> 存储过程名称([参数列表])</span><br></pre></td></tr></table></figure><p>（ 3 ）查看</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">procedure</span> 存储过程名称;</span><br></pre></td></tr></table></figure><p>（ 4 ）删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop procedure [if exists] 存储过程名称;</span><br></pre></td></tr></table></figure><p>若采用命令行来创建存储过程其默认的END结束符号不是” ; “，需要采用以下指令指定结束符</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delimiter $$</span><br></pre></td></tr></table></figure><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h3><p><strong>概述：</strong>系统变量是MySQL服务器提供，不是用户定义的，属于服务器层面。分为全局变量（GLOBAL)、会话变量（SESSION）。</p><p>（ 1 ）查看系统变量</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--查看所有系统变量</span></span><br><span class="line"><span class="keyword">SHOW</span> [ SESSION<span class="operator">|</span><span class="keyword">GLOBAL</span> ] VARIABLES ;</span><br><span class="line"></span><br><span class="line"> <span class="comment">--可以通过LIKE模糊匹配方式查找变量</span></span><br><span class="line"><span class="keyword">SHOW</span> [SESSION <span class="operator">|</span> <span class="keyword">GLOBAL</span> ] VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;...&#x27;</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">--查看指定变量的值</span></span><br><span class="line"><span class="keyword">SELECT</span> @@[SESSION <span class="operator">|</span><span class="keyword">GLOBAL</span>] 系统变量名;</span><br></pre></td></tr></table></figure><p>（ 2 ）设置系统变量</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> [ SESSION <span class="operator">|</span> <span class="keyword">GLOBAL</span>] 系统变量名<span class="operator">=</span>值;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> @@[SESSION <span class="operator">|</span> <span class="keyword">GLOBAL</span>].系统变量名<span class="operator">=</span>值;</span><br></pre></td></tr></table></figure><p><span style="color:red">注意：如果没有指定SESSION&#x2F;GLOBAL，默认是SESSION会话变量。mysql服务重新启动之后，所设置的全局参数会失效，要想不失效，可以在&#x2F;etc&#x2F;my.cnf 中配置。</span></p><h3 id="用户自定义变量"><a href="#用户自定义变量" class="headerlink" title="用户自定义变量"></a>用户自定义变量</h3><p><strong>概述：</strong>用户定义变量是用户根据需要自己定义的变量，用户变量不用提前声明，在用的时候直接用“@变量名”使用就可以。其作用域为当前连接。</p><p>（ 1 ）赋值语句SET</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> @变量名称 <span class="operator">=</span> <span class="string">&#x27;值&#x27;</span>;</span><br><span class="line"><span class="keyword">SET</span> @变量名称 :<span class="operator">=</span> <span class="string">&#x27;值&#x27;</span>;</span><br></pre></td></tr></table></figure><p>（ 2 ）赋值语句SELECT</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @变量名称 <span class="operator">=</span> <span class="string">&#x27;值&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span> 字段名称 <span class="keyword">INTO</span> @变量名称 <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure><p>（ 3 ）使用变量</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @变量名称;</span><br></pre></td></tr></table></figure><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p><strong>概述：</strong>局部变量是根据需要定义的在局部生效的变量，访问之前，需要DECLARE声明。可用作存储过程内的局部变量和输入参数，局部变量的范围是在其内声明的BEGIN …END块。</p><p>（ 1 ）声明变量，变量类型就是数据库字段类型：INT、BIGINT、CHAR、VARCHAR、DATE、TIME等。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> 变量名 变量类型 [<span class="keyword">DEFAULT</span> ...];</span><br></pre></td></tr></table></figure><p>（ 2 ）赋值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> 变量名 <span class="operator">=</span> 值;</span><br><span class="line"><span class="keyword">SET</span> 变量名 :<span class="operator">=</span> 值;</span><br><span class="line"><span class="keyword">SELECT</span> 字段名<span class="keyword">INTO</span> 变量名 <span class="keyword">FROM</span> 表名...;</span><br></pre></td></tr></table></figure><h2 id="判断条件"><a href="#判断条件" class="headerlink" title="判断条件"></a>判断条件</h2><h3 id="IF"><a href="#IF" class="headerlink" title="IF"></a>IF</h3><p>语法如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IF 条件<span class="number">1</span> <span class="keyword">THEN</span> 操作<span class="number">1</span></span><br><span class="line">...</span><br><span class="line">[ ELSEIF 条件<span class="number">2</span> <span class="keyword">THEN</span> 操作<span class="number">2</span> ] </span><br><span class="line">...</span><br><span class="line"><span class="keyword">END</span> IF</span><br></pre></td></tr></table></figure><h3 id="CASE"><a href="#CASE" class="headerlink" title="CASE"></a>CASE</h3><p>（ 1 ）语法1，说明：该变量若满足值1，则执行操作1，满足值2，则执行操作2，依次判断。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CASE</span> 变量;</span><br><span class="line"><span class="keyword">WHEN</span> 值<span class="number">1</span> <span class="keyword">THEN</span> 操作<span class="number">1</span>;</span><br><span class="line"><span class="keyword">WHEN</span> 值<span class="number">2</span> <span class="keyword">THEN</span> 操作<span class="number">2</span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">ELSE</span> 操作n;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">CASE</span>;</span><br></pre></td></tr></table></figure><p>（ 2 ）语法2，说明：该变量若满足条件1，则执行操作1，满足条件2，则执行操作2，依次判断。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CASE</span></span><br><span class="line"><span class="keyword">WHEN</span> 条件<span class="number">1</span> <span class="keyword">THEN</span> 操作<span class="number">1</span>;</span><br><span class="line"><span class="keyword">WHEN</span> 条件<span class="number">2</span> <span class="keyword">THEN</span> 操作<span class="number">2</span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">ELSE</span> 操作n;</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">CASE</span>;</span><br></pre></td></tr></table></figure><p>【例】季度判断</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p6(<span class="keyword">in</span> mon <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span> </span><br><span class="line"><span class="keyword">declare</span> res <span class="type">varchar</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> </span><br><span class="line"><span class="keyword">when</span> mon <span class="operator">&lt;=</span> <span class="number">3</span> <span class="keyword">and</span> mon <span class="operator">&gt;=</span> <span class="number">1</span> <span class="keyword">then</span> <span class="keyword">set</span> res <span class="operator">=</span> <span class="string">&#x27;第一季度&#x27;</span>;</span><br><span class="line"><span class="keyword">when</span> mon <span class="operator">&lt;=</span> <span class="number">6</span> <span class="keyword">and</span> mon <span class="operator">&gt;=</span> <span class="number">4</span> <span class="keyword">then</span> <span class="keyword">set</span> res <span class="operator">=</span> <span class="string">&#x27;第二季度&#x27;</span>;</span><br><span class="line"><span class="keyword">when</span> mon <span class="operator">&lt;=</span> <span class="number">9</span> <span class="keyword">and</span> mon <span class="operator">&gt;=</span> <span class="number">7</span> <span class="keyword">then</span> <span class="keyword">set</span> res <span class="operator">=</span> <span class="string">&#x27;第三季度&#x27;</span>;</span><br><span class="line"><span class="keyword">when</span> mon <span class="operator">&lt;=</span> <span class="number">10</span> <span class="keyword">and</span> mon <span class="operator">&gt;=</span> <span class="number">12</span> <span class="keyword">then</span> <span class="keyword">set</span> res <span class="operator">=</span> <span class="string">&#x27;第四季度&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">set</span> res <span class="operator">=</span> <span class="string">&#x27;月份输入错误&#x27;</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">case</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> res;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> p6(<span class="number">13</span>);</span><br></pre></td></tr></table></figure><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>（ 1 ）参数类型</p><table><thead><tr><th align="center">类型</th><th align="center">含义</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">IN</td><td align="center">该类参数作为输入，也就是需要调用时传入值</td><td align="center">默认</td></tr><tr><td align="center">OUT</td><td align="center">该类参数作为输出，也就是该参数可以作为返回值</td><td align="center"></td></tr><tr><td align="center">INOUT</td><td align="center">既可以作为输入参数，也可以作为输出参数</td><td align="center"></td></tr></tbody></table><p>（ 2 ）用法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> 存储过程名称([<span class="keyword">IN</span><span class="operator">/</span><span class="keyword">OUT</span><span class="operator">/</span><span class="keyword">INOUT</span> 参数名 参数类型])</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="comment">--SQL语句</span></span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>【例】分数判断</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p4(<span class="keyword">in</span> score <span class="type">int</span>,<span class="keyword">out</span> <span class="keyword">result</span> <span class="type">varchar</span>(<span class="number">10</span>))</span><br><span class="line"><span class="keyword">begin</span> </span><br><span class="line">if score <span class="operator">&gt;=</span> <span class="number">85</span> <span class="keyword">then</span> </span><br><span class="line"><span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> <span class="string">&#x27;优秀&#x27;</span>;</span><br><span class="line">elseif score <span class="operator">&gt;=</span> <span class="number">60</span> <span class="keyword">then</span> </span><br><span class="line"><span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> <span class="string">&#x27;及格&#x27;</span>;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">set</span> <span class="keyword">result</span> :<span class="operator">=</span> <span class="string">&#x27;不及格&#x27;</span>;</span><br><span class="line"><span class="keyword">end</span> if;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> p4(<span class="number">84</span>,<span class="variable">@result</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="variable">@result</span>;</span><br></pre></td></tr></table></figure><h2 id="循环语法"><a href="#循环语法" class="headerlink" title="循环语法"></a>循环语法</h2><h3 id="WILIE"><a href="#WILIE" class="headerlink" title="WILIE"></a>WILIE</h3><p><strong>概述：</strong>while循环是有条件的循环控制语句。满足条件后，再执行循环体中的SQL语句。具体语法如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WILIE 条件 DO</span><br><span class="line"></span><br><span class="line"><span class="keyword">SQL</span>逻辑...</span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span> WILIE;</span><br></pre></td></tr></table></figure><p>【例】计算从1累加到n的值，n为传入的参数值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> addToN(<span class="keyword">in</span> n <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> res <span class="type">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">while n <span class="operator">&gt;</span> <span class="number">0</span> do</span><br><span class="line"><span class="keyword">set</span> res <span class="operator">=</span> res <span class="operator">+</span> n;</span><br><span class="line"><span class="keyword">set</span> n <span class="operator">=</span> n <span class="operator">-</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span> while;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> res;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> addToN(<span class="number">4</span>);</span><br></pre></td></tr></table></figure><h3 id="REPEAT"><a href="#REPEAT" class="headerlink" title="REPEAT"></a>REPEAT</h3><p><strong>概述：</strong>repeat是有条件的循环控制语句，当满足条件的时候退出循环。具体语如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#先执行一次逻辑，然后判定逻辑是否满足，如果满足，则退出。如果不满足，则继续下一次循环</span><br><span class="line">REPEAT </span><br><span class="line"></span><br><span class="line"><span class="keyword">SQL</span>逻辑...</span><br><span class="line">UNTIL 条件</span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span> REPEAT;</span><br></pre></td></tr></table></figure><h3 id="LOOP"><a href="#LOOP" class="headerlink" title="LOOP"></a>LOOP</h3><p><strong>概述：</strong>LOOP实现简单的循环，如果不在SQL逻辑中增加退出循环的条件，可以用其来实现简单的死循环。LOOP可以配合一下两个语句使用</p><p>（ 1 ）LEAVE：配合循环使用，退出循环。</p><p>（ 2 ）TERATE：必须用在循环中，作用是跳过当前循环剩下的语句，直接进入下一次循环。</p><p>语法如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[begin_lab:] LOOP</span><br><span class="line"></span><br><span class="line"><span class="keyword">SQL</span>逻辑..;</span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span> LOOP[<span class="keyword">end</span> label;</span><br></pre></td></tr></table></figure><h3 id="CURSOR"><a href="#CURSOR" class="headerlink" title="CURSOR"></a>CURSOR</h3><p>游标（CURSOR）是用来<span style="color:red">存储查询结果集</span>的数据类型，在存储过程和函数中可以使用游标对结果集进行循环的处理。游标的使用包括游标的声明、OPEN、FETCH和 CLOSE，其语法分别如下。</p><p>（ 1 ）声明游标</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> 游标名称 <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> 查询语句;</span><br></pre></td></tr></table></figure><p>（ 2 ）打开游标</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">OPEN</span> 游标名称;</span><br></pre></td></tr></table></figure><p>（ 3 ）获取游标中记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FETCH</span> 游标名称 <span class="keyword">INTO</span> 变量 [，变量];</span><br></pre></td></tr></table></figure><p>（ 4 ）关闭游标</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CLOSE</span> 游标名称;</span><br></pre></td></tr></table></figure><p><span style="color:red">条件处理程序（Handler）</span>可以用来定义在流程控制结构执行过程中遇到问题时相应的处理步骤。具体语法如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> [EXIT <span class="operator">|</span> COUNTINE] HANDLE <span class="keyword">FOR</span> 条件值... <span class="keyword">SQL</span>命令</span><br></pre></td></tr></table></figure><p>（ 1 ）EXIT：终止执行当前程序</p><p>（ 2 ）COUNTINE：继续执行当前程序</p><p>条件值表如下</p><table><thead><tr><th align="center">条件值</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">SQLSTATE</td><td align="center">状态码，如02000</td></tr><tr><td align="center">SQLWARNING</td><td align="center">所有以01开头的SQLSTATE代码的简写</td></tr><tr><td align="center">NOT FOUND</td><td align="center">所有以02开头的SQLSTATE代码的简写</td></tr><tr><td align="center">SQLEXCEPTION</td><td align="center">所有没有被SQLWARNING或 NOT FOUND捕获的SQLSTATE代码的简写</td></tr></tbody></table><p>【例】根据传入的参数uage，来查询用户表student中，所有的学生年龄小于等于uage的学生姓名(name)和专业(profession)，并将用户的姓名和专业插入到所创建的一张新表(id,uname,uprofession)中。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> p8(<span class="keyword">in</span> uage <span class="type">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">declare</span> u_name <span class="type">varchar</span>(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">declare</span> u_profession <span class="type">varchar</span>(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">declare</span> u_cursor <span class="keyword">cursor</span> <span class="keyword">for</span> <span class="keyword">select</span> name,profession <span class="keyword">from</span> student <span class="keyword">where</span> age <span class="operator">&lt;=</span> uage;</span><br><span class="line"><span class="keyword">declare</span> exit handler <span class="keyword">for</span> <span class="keyword">sqlstate</span> <span class="string">&#x27;02000&#x27;</span> <span class="keyword">close</span> u_cursor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> ustudent; </span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> ustudent(</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">profession <span class="type">varchar</span>(<span class="number">100</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> u_cursor;</span><br><span class="line">while <span class="literal">true</span> do</span><br><span class="line"><span class="keyword">fetch</span> u_cursor <span class="keyword">into</span> u_name,u_profession;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> ustudent <span class="keyword">values</span> (<span class="keyword">null</span>,u_name,u_profession);</span><br><span class="line"><span class="keyword">end</span> while;</span><br><span class="line"><span class="keyword">close</span> u_cursor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> p8(<span class="number">20</span>);</span><br></pre></td></tr></table></figure><h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><p><strong>概述：</strong>触发器是与表有关的数据库对象，指在insert&#x2F;update&#x2F;delete之前或之后，触发并执行触发器中定义的SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性，日志记录，数据校验等操作。</p><p style="color:blue">使用别名OLD和NEW来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发。</p><table><thead><tr><th align="center">触发器类型</th><th align="center">NEW 和 OLD</th></tr></thead><tbody><tr><td align="center">INSERT型触发器</td><td align="center">NEW表示将要或者已经新增的数据</td></tr><tr><td align="center">UPDATE型触发器</td><td align="center">OLD表示修改之前的数据，NEW表示将要或已经修改后的数据</td></tr><tr><td align="center">DELETE型触发器</td><td align="center">OLD表示将要或者已经删除的数据</td></tr></tbody></table><h2 id="相关语法-1"><a href="#相关语法-1" class="headerlink" title="相关语法"></a>相关语法</h2><p>（ 1 ）创建一个触发器</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> 触发器名 [AFTER <span class="operator">|</span> BEFORE] [<span class="keyword">INSERT</span> <span class="operator">|</span> <span class="keyword">UPDATE</span> <span class="operator">|</span> <span class="keyword">DELETE</span>] # 可选项中需要各选一个参数</span><br><span class="line"><span class="keyword">ON</span> 表名 <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span> </span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">触发器命令</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>（ 2 ）查看触发器</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TRIGGER</span>;</span><br></pre></td></tr></table></figure><p>（ 3 ）删除</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> 触发器名</span><br></pre></td></tr></table></figure><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><p><strong>概述：</strong>锁是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源（CPU、RAM、I&#x2F;O）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发订问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。</p><p>【分类】</p><p>MySQL中的锁，按照锁的粒度分，分为以下三类</p><p>（ 1 ）全局锁：锁定数据库中的所有表。</p><p>（ 2 ）表级锁：每次操作锁住整张表。</p><p>（ 3 ）行级锁：每次操作锁住对应的行数据。</p><h2 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h2><p><strong>概述：</strong>全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句都将被阻塞。</p><p><strong>应用场景：</strong>做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。</p><p>（ 1 ）若在数据库备份时未加锁，则会出现数据不一致问题，如下图所示</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230225122332867.png" alt="数据不一致性问题"></p><p>（ 2 ）在备份中有加锁的情况，下图所示</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230225122716964.png" alt="加锁的备份过程图"></p><p>（ 3 ）全局锁的相关指令如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 开启全局锁</span><br><span class="line">flush tables <span class="keyword">with</span> read lock ;</span><br><span class="line"></span><br><span class="line"># 启用备份功能</span><br><span class="line">mysqldump <span class="operator">-</span>uroot <span class="operator">-</span>p1234 数据库名称 <span class="operator">&gt;</span> 备份文件名称</span><br><span class="line"></span><br><span class="line"># 释放锁</span><br><span class="line">unlock tables;</span><br></pre></td></tr></table></figure><p>（ 4 ）特点：数据库中加全局锁，是一个比较重的操作，存在以下问题</p><ul><li><p>如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得处于堵塞状态。</p></li><li><p>如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（binlog)，会导致主从延迟。</p></li></ul><p style="color:red">在InnoDB引擎中，我们可以在备份时加上参数--single-transaction参数来完成不加锁的一致性数据备份。</p><h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><p>对于表锁分为以下两类：</p><p>（ 1 ）表共享读锁(read lock)；</p><p>（ 2 ）表独占写锁(write lock)；</p><p>相关指令如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 加锁</span><br><span class="line">lock tables 表名... [read <span class="operator">|</span> write];</span><br><span class="line"></span><br><span class="line"># 释放锁</span><br><span class="line">unlock tables;</span><br></pre></td></tr></table></figure><p><strong>加读锁的过程图如下</strong></p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230225130309867.png" alt="读锁"></p><p><strong>加写锁的过程图</strong></p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230225130536637.png" alt="image-20230225130536637"></p><p style="color:red">读锁不会阻塞其他客户端的读，但是会阻塞写。写锁既会阻塞其他客户端的读，又会阻塞其他客户端的写。例如上两张图所示，【加读锁】，客户端A和客户端B都是可以进行读操作（DQL），而写操作是都不能执行的。【加写锁】，若是客户端A加的写锁，那么只有客户端A可以进行读写操作，其它客户端时不能进行仍何的操作的。</p><h3 id="元数据锁（DML）"><a href="#元数据锁（DML）" class="headerlink" title="元数据锁（DML）"></a>元数据锁（DML）</h3><p>概述：MDL加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL锁主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。<span style="color:red">为了避免DML与DDL冲突，保证读写的正确性。</span ></p><p>在MySQL5.5中引入了MDL，当对一张表进行增删改查的时候，加MDL读锁(共享)，当对表结构进行变更操作的时候，加MDL写锁(排他)。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230225131546192.png" alt="image-20230225131546192"></p><h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><p><strong>引入：</strong>没有意向锁的多线程对表的操作：线程A需要对ID为3的行进行修改操作，在修改操作前MySQL会自动的加上DML锁，修改还未完成，此时线程B需要对该表进行加表锁的操作，线程B在加锁前会对整张表进行一个检查，检查是否存在行锁，若存在行锁会判断是否兼容表锁，若不兼容则线程B加锁失败。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230225132229440.png" alt="无意向锁操作图"><span style="color:red">为了避免DML在执行时，加的行锁与表锁的冲突，在lnnoDB中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。</span></p><p>存在意向锁的操作情况：线程A修改ID为3的行数据时，MySQL会加上意向锁，线程B此时需要加表锁，则只需要根据意向锁的类型来判断是否兼容表锁即可，无需逐行的扫描，提高了性能。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230225133335150.png" alt="有意向锁后的操作过程"></p><p style="color:blue">意向锁的分类</p><p>（ 1 ）<strong>意向共享锁(IS)：</strong>由语句select … lock in share mode添加</p><p>（ 2 ）<strong>意向排他锁(IX)：</strong>由insert、update、delete、select … for update添加</p><p style="color:blue">意向锁的兼容性</p><p>（ 1 ）<strong>意向共享锁(IS)：</strong>与表锁共享锁（read）兼容，与表锁排它锁（write）互斥</p><p>（ 2 ）<strong>意向排他锁(IX)：</strong>与表锁共享锁（read）及排它锁（write）都互斥。意向锁之间不会互斥</p><p><strong>综上总结：意向锁的存在是为了解决行锁和表锁的冲突问题。</strong></p><h2 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h2><p>概述：行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在lnnoDB存储引擎中。</p><p>InnoDB的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁。对于行级锁，主要分为以下三类</p><table><thead><tr><th align="center">锁名称</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">行锁(Record Lock)</td><td align="center">锁定单个行记录的锁，防止其他事务对此行进行update和delete。在RC、RR隔离级别下都支持。</td></tr><tr><td align="center">间隙锁(GapLock)</td><td align="center">锁定索引记录间隙(不含该记录)，确保索引记录间隙不变，防止其他事务在这个间隙进行insert，产生幻读。在RR隔离级别下都支持</td></tr><tr><td align="center">临键锁(Next-Key Lock)</td><td align="center">行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。在RR隔离级别下支持。</td></tr></tbody></table><h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><p>InnoDB实现了下列两种行锁：</p><p>（ 1 ）共享锁(S)：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。</p><p>（ 2 ）排他锁(X)：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。</p><p><strong>执行不同的SQL语句，会加不同的锁，如下表所示</strong></p><table><thead><tr><th align="center">SQL</th><th align="center">行锁类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">INSERT</td><td align="center">排他锁（X）</td><td align="center">自动加锁</td></tr><tr><td align="center">UPDATE</td><td align="center">排他锁（X）</td><td align="center">自动加锁</td></tr><tr><td align="center">DELETE</td><td align="center">排他锁（X）</td><td align="center">自动加锁</td></tr><tr><td align="center">SELECT</td><td align="center"><span style="color:red">不加仍何锁</span></td><td align="center"></td></tr><tr><td align="center">SELECT … LOCK IN SHARE MODE</td><td align="center">共享锁（S）</td><td align="center">需要手动在SELECT之后加LOCK IN SHARE MODE</td></tr><tr><td align="center">SELECT … FOR UPDATE</td><td align="center">排他锁（X）</td><td align="center">需要手动在SELECT之后加FOR UPDATE</td></tr></tbody></table><p>默认情况下，InnoDB在REPEATABLEREAD事务隔离级别运行，InnoDB使用 next-key锁进行搜索和索引扫描，以防止幻读。</p><p>（ 1 ）针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。</p><p>（ 2 ）InnoDB的行锁是针对于索引加的锁，<strong>不通过索引条件检索数据</strong>，那么InnoDB将对表中的所有记录加锁，此时就会<span style="color:red">升级为表锁。</span></p><h3 id="间隙锁-amp-临键锁"><a href="#间隙锁-amp-临键锁" class="headerlink" title="间隙锁&amp;临键锁"></a>间隙锁&amp;临键锁</h3><p>默认情况下，InnoDB在REPEATABLEREAD事务隔离级别运行，InnoDB使用 next-key锁进行搜索和索引扫描，以防止幻读。</p><p>（ 1 ）索引上的等值查询(唯一索引)，给不存在的记录加锁时，优化为间隙锁。</p><p>（ 2 ）索引上的等值查询(普通索引)，向右遍历时最后一个值不满足查询需求时，next-key lock退化为间隙锁。</p><p>（ 3 ）索引上的范围查询(唯一索引)，会访问到不满足条件的第一个值为止。</p><p>注意：间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁。</p><h1 id="InnoDB引擎"><a href="#InnoDB引擎" class="headerlink" title="InnoDB引擎"></a>InnoDB引擎</h1><p>MySQL5.5 版本开始，默认使用InnoDB存储引擎，它擅长事务处理，具有崩溃恢复特性，在日常开发中使用非常广泛。下面是InnoDB架构图，左似为内存结构，右侧为磁盘结构。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230218170126078.png" alt="InnoDB存储引擎的结构图"></p><p>【说明】</p><p>（ 1 ）<span style="color:blue">表空间：</span>一个mysql实例可以对应多个表空间，用于存储记录、索引等数据。</p><p>（ 2 ）<span style="color:blue">段：</span>分为数据段（Leaf node segment）、索引段（Non-leaf node segment）、回滚段（Rollback segment），InnoDB是索引组织表，数据段就是B+树的叶子节点，索引段即为B+树的非叶子节点。段用来管理多个Extent（区）。</p><p>（ 3 ）<span style="color:blue">区：</span>表空间的单元结构，每个区的大小为1M。默认情况下， InnoDB存储引擎页大小为16K，即一个区中一共有64个连续的页。</p><p>（ 4 ）<span style="color:blue">页：</span>是InnoDB存储引擎磁盘管理的最小单元，每个页的大小默认为16KB。为了保证页的连续性，InnoDB存储引擎每次从磁盘申请4-5个区。</p><p>（ 5 ）<span style="color:blue">行：</span>InnoDB存储引擎数据是按行进行存放的。</p><h2 id="事务原理"><a href="#事务原理" class="headerlink" title="事务原理"></a>事务原理</h2><p><strong>概述：</strong>事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230225152213458.png" alt="image-20230225152213458"></p><h3 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h3><p><strong>redo log：</strong>重做日志，记录的是事务提交时数据页的物理修改，是用来实现事务的持久性。</p><p><strong>该日志文件由两部分组成：</strong>重做日志缓冲（redo log buffer）以及重做日志文件（redo log file），前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都存到该日志文件中,用于在刷新脏页到磁盘,发生错误时，进行数据恢复使用。</p><p>（ 1 ）在没有redo log日志的情况下，客户端向MySQL服务器发送更新数据的操作，数据首先会经过内存处理，然后再刷新到磁盘中，若此过程发生了错误，则无法完成数据的持久保存，不能保证持久性。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230225153416081.png" alt="没有redo log日志文件的刷新过程"></p><p>（ 2 ）存在redo log日志的情况下，客户端更新数据经过Buffer Pool中，然后再保存到redo  log日志缓冲，最后在异步刷新，从而保证持久性。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230225154311734.png" alt="存在Redolog日志的刷新过程"></p><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p><strong>undo log回滚日志</strong>，用于记录数据被修改前的信息，作用包含两个：提供回滚和MVCC(多版本并发控制)。undo log和redo log记录物理日志不一样，它是逻辑日志。可以认为当delete一条记录时undo log中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。当执行rollback时，就可以从undo log中的逻辑记录读取到相应的内容并进行回滚。</p><p>（ 1 ）Undo log销毁：undo log在事务执行时产生，事务提交时，并不会立即删除undo log，因为这些日志可能还用于MVCC。</p><p>（ 2 ）Undo log存储：undo log采用段的方式进行管理和记录，存放在前面介绍的rollback segment回滚段中，内部包含1024个undo log segment。</p><h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>（ 1 ）<span style="color:blue">当前读：</span>读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。对于我们日常的操作，如：select … lock in share mode(共享锁)，select … for update、update、insert、delete(排他锁)都是一种当前读。</p><p>（ 2 ）<span style="color:blue">快照读：</span>简单的select(不加锁）就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读。</p><table><thead><tr><th align="center">隔离级别</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Read Committed</td><td align="center">每次select，都生成一个快照读。</td></tr><tr><td align="center">Repeatable Read</td><td align="center">开启事务后第一个select语句才是快照读的地方</td></tr><tr><td align="center">Serializable</td><td align="center">快照读会退化为当前读。</td></tr></tbody></table><p>（ 3 ）<span style="color:blue">MVCC概念：</span>全称Mult-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为MySQL实现MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需要依赖于数据库记录中的三个隐式字段、undo log日志、readView。</p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p><strong>（ 1 ）记录中的三个隐式字段</strong>，会随表的创建而自动增加到表字段中，不会在表中显示的。</p><table><thead><tr><th align="center">字段名称</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">DB_TRX_ID</td><td align="center">最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务ID。</td></tr><tr><td align="center">DB_ROLL_PTRR</td><td align="center">回滚指针，指向这条记录的上一个版本，用于配合undo log，指向上一个版本。</td></tr><tr><td align="center">DB_ROW_ID</td><td align="center">隐藏主键，如果表结构没有指定主键，将会生成该隐藏字段。</td></tr></tbody></table><p><strong>（ 2 ）undo log日志（回滚日志）</strong></p><p>undo log日志的删除：</p><p>​当insert的时候，产生的undo log日志只在回滚时需要，在事务提交后，可被立即删除。</p><p>​而update、delete的时候，产生的undo log日志不仅在回滚时需要，在快照读时也需要，不会立即被删除。</p><p>【undo log版本链】</p><p><strong>下图说明：</strong>事务2，3，4都是对ID为30的记录进行修改操作，每次修改MySQL都会维护一条undo log版本链，以便事务的回滚。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230225164939655.png" alt="undo log形成过程图"></p><p style="color:blue">不同事务或相同事务对同一条记录进行修改，会导致该记录的undolog生成一条记录版本链表，链表的头部是最新的旧记录，链表尾部是最早的旧记录。</p><p><strong>（ 3 ）readView</strong></p><p>​ReadView（读视图）是快照读SQL执行时MVCC提取数据的依据，记录并维护系统当前活跃的事务（未提交的） id。</p><p>下表是ReadView的四个核心字段</p><table><thead><tr><th align="center">字段名</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">m_ids</td><td align="center">当前活跃的事务ID集合</td></tr><tr><td align="center">min_trx_id</td><td align="center">最小活跃事务ID</td></tr><tr><td align="center">max_trx_id</td><td align="center">预分配事务ID,当前最大事务ID+1（因为事务ID是自增的）</td></tr><tr><td align="center">creator_trx_id</td><td align="center">ReadView创建者的事务ID</td></tr></tbody></table><p style="color:blue">readView主要作用：当快照读时决定在undo log版本链中读取哪个数据。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230225170401092.png" alt="image-20230225170401092"></p><p><strong>【例】分析读取RC（读取已提交）的隔离级别下的快照读过程。</strong></p><p>读取下图的红色框的readView</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230225171356590.png" alt="分析"></p><p>通过下图DB_TRX_ID字段和ReadView的四个核心字段进行比较即可，若遇到满足条件的，则说明事务已提交，这时就可以终止比较，将符合条件的数据返回给客户端。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230225174511846.png" alt="过程图"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Mysql事务&quot;&gt;&lt;a href=&quot;#Mysql事务&quot; class=&quot;headerlink&quot; title=&quot;Mysql事务&quot;&gt;&lt;/a&gt;Mysql事务&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简</summary>
      
    
    
    
    
    <category term="mysql" scheme="http://example.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>redis基础与进阶</title>
    <link href="http://example.com/2023/02/17/redis%E5%9F%BA%E7%A1%80%E4%B8%8E%E8%BF%9B%E9%98%B6/"/>
    <id>http://example.com/2023/02/17/redis%E5%9F%BA%E7%A1%80%E4%B8%8E%E8%BF%9B%E9%98%B6/</id>
    <published>2023-02-17T02:16:00.000Z</published>
    <updated>2023-02-24T05:41:51.951Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis基础篇"><a href="#Redis基础篇" class="headerlink" title="Redis基础篇"></a>Redis基础篇</h1><h2 id="Nosql和SQL的介绍"><a href="#Nosql和SQL的介绍" class="headerlink" title="Nosql和SQL的介绍"></a>Nosql和SQL的介绍</h2><p>概述：数据库存储类型有分为SQL（关系型）和NOSQL（非关系型）型数据库</p><p><strong>SQL型的数据库存储特点：</strong></p><p>（ 1 ）结构化：表结构存储</p><p>（ 2 ）表之间是有关联的</p><p>（ 3 ）可以使用SQL语句进行操作</p><p>（ 4 ）满足ACID特性：原子性、永久性、一致性、隔离性</p><p>（ 5 ）存储方式：磁盘</p><p><strong>NOSQL型数据库存储特点：</strong></p><p>（ 1 ）非结构型：像redis数据库是以key-value结构进行存储的</p><p>（ 2 ）无关联的</p><p>（ 3 ）非SQL</p><p>（ 4 ）存储方式：内存（性能比较好）</p><p><strong>使用场景：</strong></p><p>（ 1 ）SQL型：对数据安全性和一致性要求较高，数据结构固定</p><p>（ 2 ）NOSQL型：数据结构不固定，对性能要求较高，对一致性和安全性要求不高</p><h2 id="Redis的基本介绍"><a href="#Redis的基本介绍" class="headerlink" title="Redis的基本介绍"></a>Redis的基本介绍</h2><p>概述：Redis诞生于2009年全称是Remote Dictionary Server，远程词典服务器，是一个基于内存的键值型NoSQL数据库。</p><p><strong>Redis的特征：</strong></p><p>（ 1 ）键值性（key-value）：value支持多种数据结构，功能丰富</p><p>（ 2 ）单线程，每个命令具备原子性</p><p>（ 3 ）低延迟，速度快（基于内存、IO多路复用、良好的编码）</p><p>（ 4 ）支持数据持久化</p><p>（ 5 ）支持主从集群、分片集群支持多语言客户端</p><h2 id="Redis的在Linux上安装"><a href="#Redis的在Linux上安装" class="headerlink" title="Redis的在Linux上安装"></a>Redis的在Linux上安装</h2><p>（ 1 ）因为Redis是基于c语言编写的，所以首先需要安装gcc依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y gcc tcl</span><br></pre></td></tr></table></figure><p>（ 2 ）可以到Redis官网下载linux的安装压缩包，【<a href="https://redis.io/download/#redis-downloads%E3%80%91">https://redis.io/download/#redis-downloads】</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解压命令</span></span><br><span class="line">tar -zxvf redis压缩包文件名称</span><br></pre></td></tr></table></figure><p>（ 3 ）进入redis的目录下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd redisxxx</span><br></pre></td></tr></table></figure><p>（ 4 ）执行编译命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make $$ make install </span><br></pre></td></tr></table></figure><p>（ 5 ）若没有出错，则说明安装成功</p><p>（ 6 ）redis-cli的默认安装路径在 &#x2F;usr&#x2F;local&#x2F;bin 目录下</p><h3 id="Redis指定配置文件打开"><a href="#Redis指定配置文件打开" class="headerlink" title="Redis指定配置文件打开"></a>Redis指定配置文件打开</h3><p>如果要让Redis以(后台方式启动，则必须修改Redis配置文件，就在我们之前解压的redis安装包下，进入redis的目录下，找到redis.conf文件，然后进行修改，但在修改前最好进行备份</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp redis.conf redis.conf.bak</span><br></pre></td></tr></table></figure><p>使用以下命令进入redis.conf文件进行编辑</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi redis.conf</span><br></pre></td></tr></table></figure><p><strong>修改配置文件（必要）</strong></p><p>（ 1 ）监听的地址，默认是127.0.0.l，会导致只能在本地访问。修改为0.0.0.0则可以在任意IP访问，生产环境下不要设置为0.0.0.0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bind 0.0.0.0</span><br></pre></td></tr></table></figure><p>（ 2 ）守护进程，让redis服务器后台运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes</span><br></pre></td></tr></table></figure><p>（ 3 ）设置密码，每次进入redis客户端时需要密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requirepass xxxxx</span><br></pre></td></tr></table></figure><p><strong>其它配置（非必要）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#监听的端口</span><br><span class="line">port 6379</span><br><span class="line"></span><br><span class="line">#工作目录，默认是当前目录，也就是运行redis-server时的命令，日志、持久化等文件会保存在这个目录</span><br><span class="line">dir</span><br><span class="line"></span><br><span class="line">#数据库数量，设置为l，代表只使用1个库，默认有16个库，编号0~15</span><br><span class="line">databases 1</span><br><span class="line"></span><br><span class="line">#设置redis能够使用的最大内存</span><br><span class="line">maxmemory 512mb</span><br><span class="line"></span><br><span class="line">#日志文件，默认为空，录日志，可以指定日志文件名</span><br><span class="line">logfile &quot;redis.log&quot;</span><br></pre></td></tr></table></figure><h3 id="运行Redis服务器和客户端"><a href="#运行Redis服务器和客户端" class="headerlink" title="运行Redis服务器和客户端"></a>运行Redis服务器和客户端</h3><p>必要修改的配置文件完成后就进入到&#x2F;redis&#x2F;src目录下，执行以下命令运行redis服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server redis.conf</span><br></pre></td></tr></table></figure><p>执行以下命令执行客户端</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 虚拟机ip -p 端口号 -a 密码</span><br></pre></td></tr></table></figure><h2 id="Redis的数据结构"><a href="#Redis的数据结构" class="headerlink" title="Redis的数据结构"></a>Redis的数据结构</h2><table><thead><tr><th align="center">数据类型</th><th align="center">表现形式</th></tr></thead><tbody><tr><td align="center"><strong>String</strong></td><td align="center"><strong>hello world</strong></td></tr><tr><td align="center"><strong>Hash</strong></td><td align="center"><strong>{name: “jack”,age : 21}</strong></td></tr><tr><td align="center"><strong>List</strong></td><td align="center"><strong>[A —&gt; B —&gt; C]</strong></td></tr><tr><td align="center"><strong>Set</strong></td><td align="center"><strong>{A, B, C}</strong></td></tr><tr><td align="center"><strong>SortedSet</strong></td><td align="center"><strong>{A: 1, B: 2, C: 3}</strong></td></tr><tr><td align="center"><strong>GEO</strong></td><td align="center"><strong>{A: (30.5, 60.6)}</strong></td></tr><tr><td align="center"><strong>BitMap</strong></td><td align="center"><strong>01010010101</strong></td></tr><tr><td align="center"><strong>HyperLog</strong></td><td align="center"><strong>01010010101</strong></td></tr></tbody></table><h2 id="Redis通用命令"><a href="#Redis通用命令" class="headerlink" title="Redis通用命令"></a>Redis通用命令</h2><p>（ 1 ）查询符合模板的key命令，生产模式下不建议使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keys pattern</span><br></pre></td></tr></table></figure><p>（ 2 ）删除key的命令，可以删除多个</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del key ...</span><br></pre></td></tr></table></figure><p>（ 3 ）判断key是否存在</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exists key ...</span><br></pre></td></tr></table></figure><p>（ 4 ）设置key的有效期</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expire key second</span><br></pre></td></tr></table></figure><p>（ 5 ）TTL：查看一个key的有效期</p><h2 id="String类型的相关命令"><a href="#String类型的相关命令" class="headerlink" title="String类型的相关命令"></a>String类型的相关命令</h2><p>String类型，也就是字符串类型，是Redis中最简单的存储类型。其value是字符串，不过根据字符串的格式不同，又可以分为3类</p><ul><li><p>string：普通字符串</p></li><li><p>int：整数类型，可以做自增、自减操作</p></li><li><p>float：浮点类型，可以做自增、自减操作</p></li></ul><p>不管是哪种格式，底层都是字节数组形式存储，只不过是编码方式不同。字符串类型的最大空间不能超过512m。</p><table><thead><tr><th align="center">命令</th><th align="center">作用</th><th align="center">使用形式</th></tr></thead><tbody><tr><td align="center">set</td><td align="center">添加或者修改一个String类型的键值对</td><td align="center">set key value</td></tr><tr><td align="center">get</td><td align="center">获取已存在key对应的value</td><td align="center">get key</td></tr><tr><td align="center">mset</td><td align="center">批量添加或修改String类型的键值对</td><td align="center">mset k1 v1 k2 v2 …</td></tr><tr><td align="center">mget</td><td align="center">批量获取多个key对应的value</td><td align="center">mget k1 k2 k3 …</td></tr><tr><td align="center">incr</td><td align="center">让一个整型的key自增1</td><td align="center">incr key</td></tr><tr><td align="center">incrby</td><td align="center">让一个整型的key自增并指定步长</td><td align="center">incrby key 步长</td></tr><tr><td align="center">incrbyfloat</td><td align="center">让一个浮点类型的数字自增并指定步长</td><td align="center">incrbyfloat key 步长</td></tr><tr><td align="center">setnx</td><td align="center">添加一个String类型的键值对，前提是这个key不存在，否则不执行</td><td align="center">setnx key value</td></tr><tr><td align="center">setex</td><td align="center">添加一个String类型的键值对，并且指定有效期</td><td align="center">setex key value</td></tr></tbody></table><h3 id="Key的层级结构"><a href="#Key的层级结构" class="headerlink" title="Key的层级结构"></a>Key的层级结构</h3><p>（ 1 ）Redis的key允许有多个单词形成层级结构，多个单词之间用∵’隔开，格式【项目名:业务名:id】，可以根据实际需要进行改变</p><p>（ 2 ）如果Value是一个ava对象，例如一个User对象，则可以将对象序列化为JSON字符串后存储</p><table><thead><tr><th align="center">key</th><th align="center">value</th></tr></thead><tbody><tr><td align="center">xxx:user:1</td><td align="center">{name: “jack”, age: 5}</td></tr><tr><td align="center">xxx:user:2</td><td align="center">{name: “mike”, age: 10}</td></tr></tbody></table><h2 id="Hash结构相关的命令"><a href="#Hash结构相关的命令" class="headerlink" title="Hash结构相关的命令"></a>Hash结构相关的命令</h2><p>概述：Hash类型，也叫散列，其value是一个无序字典，类似于Java中的HashMap结构</p><p>hash数据类型可以对对象中的每个字段进行CRUD操作，hash类型的形象图如下</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230217153701353.png" alt="image-20230217153701353"></p><p><strong>Hash结构相关命令表如下</strong></p><table><thead><tr><th align="center">命令</th><th align="center">作用</th><th align="center">使用形式</th></tr></thead><tbody><tr><td align="center">hset</td><td align="center">添加或者修改hash类型key的field的值</td><td align="center">hset key field value</td></tr><tr><td align="center">hget</td><td align="center">获取一个hash类型key的field的值</td><td align="center">hget key filed</td></tr><tr><td align="center">hmset</td><td align="center">批量添加多个hash类型key的field的值</td><td align="center">hmset key f1 v1  f2 v2 …</td></tr><tr><td align="center">hmget</td><td align="center">批量获取多个hash类型key的field的值</td><td align="center">hmget key f1  f2  …</td></tr><tr><td align="center">hgetall</td><td align="center">获取一个hash类型的key中的所有的field和value</td><td align="center">hgetall key</td></tr><tr><td align="center">hkeys</td><td align="center">获取一个hash类型的key中的所有的field</td><td align="center">hkeys key</td></tr><tr><td align="center">hvals</td><td align="center">获取一个hash类型的key中的所有的value</td><td align="center">hvals key</td></tr><tr><td align="center">hincrby</td><td align="center">让一个hash类型key的字段值自增并指定步长</td><td align="center">hincrby key filed 步长</td></tr><tr><td align="center">hsetnx</td><td align="center">添加一个hash类型的key的field值，前提是这个field不存在，否则不执行</td><td align="center">hsetnx key filed</td></tr></tbody></table><h2 id="List类型相关的命令"><a href="#List类型相关的命令" class="headerlink" title="List类型相关的命令"></a>List类型相关的命令</h2><p>Redis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。</p><p><strong>特征也与LinkedList类似：有序、元素可以重复插入和删除快查询速度一般。</strong></p><table><thead><tr><th align="center">命令</th><th align="center">作用</th><th align="center">使用形式</th></tr></thead><tbody><tr><td align="center">lpush</td><td align="center">向左列表插入一个或多个元素</td><td align="center">lpush key element …</td></tr><tr><td align="center">lpop</td><td align="center">移除并返回列表左侧的第一个元素，没有则返回nil</td><td align="center">lpop key</td></tr><tr><td align="center">rpush</td><td align="center">向右列表插入一个或多个元素</td><td align="center">rpush key element …</td></tr><tr><td align="center">rpop</td><td align="center">移除并返回列表右侧的第一个元素，没有则返回nil</td><td align="center">rpop key</td></tr><tr><td align="center">lrange</td><td align="center">返回一段角标范围内的所有元素</td><td align="center">lrange key start end</td></tr><tr><td align="center">blpop</td><td align="center">在没有元素时等待指定时间，而不是直接返回nil</td><td align="center">blpop key</td></tr><tr><td align="center">brpop</td><td align="center">在没有元素时等待指定时间，而不是直接返回nil</td><td align="center">brpop key</td></tr></tbody></table><h2 id="Set类型的相关的命令"><a href="#Set类型的相关的命令" class="headerlink" title="Set类型的相关的命令"></a>Set类型的相关的命令</h2><p>Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征：</p><ul><li>无序</li><li>元素不可重复</li><li>查询块</li><li>支持交集、并集和差集操作</li></ul><p>常见的命令如下</p><table><thead><tr><th align="center">命令</th><th align="center">作用</th><th align="center">使用形式</th></tr></thead><tbody><tr><td align="center">sadd</td><td align="center">往set集合中添加一个或多个成员</td><td align="center">sadd key member …</td></tr><tr><td align="center">srem</td><td align="center">在set集合中删除指定成员</td><td align="center">srem key member …</td></tr><tr><td align="center">scard</td><td align="center">返回set集合中的成员个数</td><td align="center">scard key</td></tr><tr><td align="center">sismember</td><td align="center">判断某个成员是否在集合中</td><td align="center">sismember key member</td></tr><tr><td align="center">smembers</td><td align="center">获取set集合中的所有成员</td><td align="center">smembers key</td></tr><tr><td align="center">sinter</td><td align="center">求key1和key2的交集</td><td align="center">sinter key1 key2</td></tr><tr><td align="center">sdiff</td><td align="center">求key1和key2的差集</td><td align="center">sdiff key1 key2</td></tr><tr><td align="center">sunion</td><td align="center">求key1和key2的并集</td><td align="center">sunion key1 key2</td></tr></tbody></table><p><strong>下图是有关于交集、并集和差集的关系图（注意，并集是下图A和B的所有部分）</strong></p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230217164812431.png" alt="image-20230217164812431"></p><h2 id="SortSet类型相关的命令"><a href="#SortSet类型相关的命令" class="headerlink" title="SortSet类型相关的命令"></a>SortSet类型相关的命令</h2><p>Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加hash表。SortedSet具备下列特性：</p><ul><li>可排序</li><li>元素不重复</li><li>查询速度快</li></ul><p>因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能。</p><table><thead><tr><th align="center">命令</th><th align="center">作用</th><th align="center">使用形式</th></tr></thead><tbody><tr><td align="center">zadd</td><td align="center">添加一个或多个元素到sortedset，如果已经存在则更新其score值</td><td align="center">zadd key score member …</td></tr><tr><td align="center">zrem</td><td align="center">删除指定的元素</td><td align="center">zrem key member …</td></tr><tr><td align="center">zscore</td><td align="center">获取sorted set中的指定元素的score值</td><td align="center">zscore key member</td></tr><tr><td align="center">zrank</td><td align="center">获取sorted set 中的指定元素的排名</td><td align="center">zrank key member</td></tr><tr><td align="center">zcard</td><td align="center">获取sorted set中的元素个数</td><td align="center">zcard key</td></tr><tr><td align="center">zcount</td><td align="center">统计score值在给定范围内的所有元素的个数</td><td align="center">zcount key mim max</td></tr><tr><td align="center">zincreby</td><td align="center">让sorted set中的指定元素自增，步长为指定的increment值</td><td align="center">zincreby key increment member</td></tr><tr><td align="center">zrange</td><td align="center">按照score排序后，获取指定排名范围内的元素</td><td align="center">zrange key mim max</td></tr><tr><td align="center">zrangebyscore</td><td align="center">按照score排序后，获取指定排名范围内的元素（按照分数排名）</td><td align="center">zrangebyscore key mim max</td></tr></tbody></table><p style="color: red">注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可</p><h1 id="Redis的Java客户端"><a href="#Redis的Java客户端" class="headerlink" title="Redis的Java客户端"></a>Redis的Java客户端</h1><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230217172404149.png" alt="image-20230217172404149"></p><h2 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h2><p>概述：Jedis是java连接redis服务器的客户端，以下是spring集成Jedis的步骤</p><p>（ 1 ）引入Jedis的坐标依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（ 2 ）通过编码的方式连接到redis服务器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisdemoApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接到Redis服务器配置（编码形式）</span></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">redisConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 建立连接</span></span><br><span class="line">        jedis = <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;192.168.177.131&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// 配置相关参数</span></span><br><span class="line">        jedis.auth(<span class="string">&quot;1234560&quot;</span>);</span><br><span class="line"></span><br><span class="line">        jedis.select(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// key - value操作</span></span><br><span class="line">        jedis.set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;zhansganan&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;name：&quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当测试类销毁前执行的方法</span></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(jedis != <span class="literal">null</span>) &#123;</span><br><span class="line">            jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p style="color: red" >注意：Jedis本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，因此我们推荐大家使用Jedis连接池代替Jedis的<p>基本使用方式如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisPoolDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">JedisPool</span> <span class="variable">jedisPool</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 创建配置对象</span></span><br><span class="line">        <span class="type">JedisPoolConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">        <span class="comment">// 配置连接池的相关参数</span></span><br><span class="line">        config.setMaxTotal(<span class="number">8</span>);</span><br><span class="line">        config.setMinIdle(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 最多等待1000ms</span></span><br><span class="line">        config.setMaxWaitMillis(<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">// 创建连接池</span></span><br><span class="line">        jedisPool =<span class="keyword">new</span> <span class="title class_">JedisPool</span>(config,<span class="string">&quot;192.168.177.131&quot;</span>,<span class="number">6379</span>,<span class="number">1000</span>,<span class="string">&quot;1234560&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title function_">getJedis</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">poolDemo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> getJedis();</span><br><span class="line"></span><br><span class="line">        jedis.set(<span class="string">&quot;nameoo&quot;</span>,<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(jedisPool != <span class="literal">null</span>) &#123;</span><br><span class="line">            jedisPool.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SpringDataRedis"><a href="#SpringDataRedis" class="headerlink" title="SpringDataRedis"></a>SpringDataRedis</h2><p>概述：SpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做SpringDataRedis</p><p>（ 1 ）提供了对不同Redis客户端的整合（Lettuce和Jedis）提供了RedisTemplate统一API来操作Redis</p><p>（ 2 ）支持Redis的发布订阅模型</p><p>（ 3 ）支持Redis哨兵和Redis集群支持基于Lettuce的响应式编程</p><p>（ 4 ）支持基于JDK、JSON、字符串、Spring对象的数据序列化及反序列化</p><p>（ 5 ）支持基于Redis的JDKCollection实现</p><p><strong>SpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。并且将不同数据类型的操作API封</strong></p><table><thead><tr><th align="center">API</th><th align="center">返回值类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">redisTemplate.opsForValue()</td><td align="center">ValueOperations</td><td align="center">操作String数据类型</td></tr><tr><td align="center">redisTemplate.opsForHash()</td><td align="center">HashOperations</td><td align="center">操作Hash数据类型</td></tr><tr><td align="center">redisTemplate.opsForSet()</td><td align="center">ListOperations</td><td align="center">操作Set数据类型</td></tr><tr><td align="center">redisTemplate.opsForList</td><td align="center">SetOperations</td><td align="center">操作List数据类型</td></tr><tr><td align="center">redisTemplate.opsForZSet()</td><td align="center">ZSetOperations</td><td align="center">操作SortSet数据类型</td></tr><tr><td align="center">redisTemplate</td><td align="center"></td><td align="center">通用命令</td></tr></tbody></table><p><strong>步骤如下</strong></p><p>（ 1 ）引入srping-boot-starter-data-redis坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（ 2 ）配置.yml文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">1234560</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.177</span><span class="number">.131</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="string">1000ms</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span></span><br></pre></td></tr></table></figure><p>（ 3 ）依赖注入RedisTemplate即可使用</p><h3 id="Redis序列化Bean对象"><a href="#Redis序列化Bean对象" class="headerlink" title="Redis序列化Bean对象"></a>Redis序列化Bean对象</h3><p>RedisTemplate可以接收任意Object作为值写入Redis，只不过写入前会把Object序列化为字节形式，默认是采用JDK，这样的序列化方式会导致Bean对象序列化到Redis数据库是类似于乱码的表现形式</p><p>采用默认序列化方式的缺点：</p><ul><li>可读性差</li><li>内存占用大</li></ul><p>需要引入以下的坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们可以自定义Redis的序列化方式，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisSeriesConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String,Object&gt; <span class="title function_">productRedisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建RedisTemplate对象</span></span><br><span class="line">        RedisTemplate&lt;String,Object&gt; redisTemplate = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 设置连接工厂</span></span><br><span class="line">        redisTemplate.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="comment">// 序列工具</span></span><br><span class="line">        <span class="type">GenericJackson2JsonRedisSerializer</span> <span class="variable">jsonRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>();</span><br><span class="line">        <span class="comment">// 设置key的序列化方式</span></span><br><span class="line">        redisTemplate.setKeySerializer(RedisSerializer.string());</span><br><span class="line">        redisTemplate.setHashKeySerializer(RedisSerializer.string());</span><br><span class="line">        <span class="comment">// 设置value的序列化方式</span></span><br><span class="line">        redisTemplate.setValueSerializer(jsonRedisSerializer);</span><br><span class="line">        redisTemplate.setHashValueSerializer(jsonRedisSerializer);</span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>尽管JSON的序列化方式可以满足我们的需求，但依然存在一些问题为了在反序列化时知道对象的类型，JSON序列化器会将类的class类型写入json结果中，存入Redis，会带来额外的内存开销。</p><h3 id="StringRedisTemplate"><a href="#StringRedisTemplate" class="headerlink" title="StringRedisTemplate"></a>StringRedisTemplate</h3><p>为了节省内存空间，我们并不会使用JSON序列化器来处理value，而是统一使用String序列化器，要求只能存储String类型的key和value。当需要存储Java对象时，手动完成对象的序列化和反序列化。</p><p>需要引入JSON和Bean对象转换的工具包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.79<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>直接注入以下的对象即可使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br></pre></td></tr></table></figure><p>说明：StringRedisTemplate等同于RedisTemplate&lt;String,String&gt;</p><h1 id="Redis进阶篇"><a href="#Redis进阶篇" class="headerlink" title="Redis进阶篇"></a>Redis进阶篇</h1><h2 id="Redis的持久化—RDB"><a href="#Redis的持久化—RDB" class="headerlink" title="Redis的持久化—RDB"></a>Redis的持久化—RDB</h2><p>Redis内部有触发RDB的机制，可以在redis.conf文件中找到，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 900秒内，如果至少有1个key被修改，则执行bgsave ,如果是save &quot;&quot; 则表示禁用RDB</span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure><p>RDB的其它配置也可以在redis.conf文件中设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#是否压缩,建议不开启，压缩也会消耗cpu，磁盘的话不值钱</span><br><span class="line">rdbcompression yes</span><br><span class="line"></span><br><span class="line">#RDB文件名称</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line">#文件保存的路径目录</span><br><span class="line">dir ./</span><br></pre></td></tr></table></figure><p style="color:blue">RDB的原理fork原理如下</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Redis基础篇&quot;&gt;&lt;a href=&quot;#Redis基础篇&quot; class=&quot;headerlink&quot; title=&quot;Redis基础篇&quot;&gt;&lt;/a&gt;Redis基础篇&lt;/h1&gt;&lt;h2 id=&quot;Nosql和SQL的介绍&quot;&gt;&lt;a href=&quot;#Nosql和SQL的介绍&quot; cla</summary>
      
    
    
    
    
    <category term="redis;nosql" scheme="http://example.com/tags/redis-nosql/"/>
    
  </entry>
  
  <entry>
    <title>nginx基础详解</title>
    <link href="http://example.com/2023/02/15/nginx%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2023/02/15/nginx%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/</id>
    <published>2023-02-15T02:34:00.000Z</published>
    <updated>2023-02-24T05:39:32.268Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nginx的基本介绍"><a href="#Nginx的基本介绍" class="headerlink" title="Nginx的基本介绍"></a>Nginx的基本介绍</h1><p><strong>概述：</strong>Nginx是一个高性能的HTTP反向代理服务器，特点是占用内存小，并发能力强</p><p><strong>Nginx作为Web服务器：</strong>Nginx可以作为静态页面的web服务器，同时还支持CGI协议的动态语言，比如perl，php等。但是不支持java。Java程序只能通过与tomcat配合完成。Nginx,专为性能优化而开发，性能是其最重要的考量，实现上非常注重效率，能经受高负载的考验，有报告表明能支持高达50000个并发连接数。</p><h1 id="Nging的基本特性"><a href="#Nging的基本特性" class="headerlink" title="Nging的基本特性"></a>Nging的基本特性</h1><ul><li>反向代理</li><li>负载均衡</li><li>动静分离</li></ul><p><strong>正向代理概念：客户端（浏览器）通过配置代理服务器访问到目标资源</strong></p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230215132101431.png" alt="image-20230215132101431"></p><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>概述：反向代理，其实客户端对代理是无感知的，因为客户端不需要任何配置就可以访问，我们只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，在返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器P地址。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230215133524255.png" alt="image-20230215133524255"></p><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>若是在小项目中并发量并不是很大，一般都会采用下图所示最基本的架构，好处是开发成本低，易于维护。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230215135802654.png" alt="image-20230215135802654"></p><p>但如今的大数据时代，一般的软件都有一定的用户量，现大部分的软件都会优先采用负载均衡进行用户请求的各个目标服务器上，增加目标服务器的数量，这时需要将用户请求平均分发，如下图所示</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230215140744602.png" alt="image-20230215140744602"></p><h2 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h2><p>在大部分的传统小项目中都是采用动态资源和静态资源不分离开发，虽然这样可以降低开发难度，但对开发人员的技术要求高，开发效率也会受到影响。</p><p>（1）动态资源就是放到数据库的数据，具有实时性，动态更新数据等特点，像jsp，servlet等。</p><p>（2）静态资源就是HTML，CSS，JS等文件</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230215141724380.png" alt="image-20230215141724380"></p><p>那什么是动静分离？动静分离就是让动态资源和静态资源分离开来，将静态资源放到代理服务器中，代理服务器中有专门用于存放静态资源的文件，当用户请求代理服务会先将页面渲染到客户端，然后根据客户需求将请求发送给目标服务器。如下图</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230215152851632.png" alt="image-20230215152851632"></p><h1 id="Nginx的常用命令"><a href="#Nginx的常用命令" class="headerlink" title="Nginx的常用命令"></a>Nginx的常用命令</h1><p><em><strong>使用nginx的（linux）命令的前提是进入root&#x2F;usr&#x2F;nginx&#x2F;sbin目录下才会生效</strong></em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看nginx的版本号</span></span><br><span class="line">nginx -v</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动nginx的命令</span></span><br><span class="line">./nginx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭nginx的命令</span></span><br><span class="line">nginx -s stop</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重新加载nginx服务器</span></span><br><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure><h1 id="Nginx的配置文件"><a href="#Nginx的配置文件" class="headerlink" title="Nginx的配置文件"></a>Nginx的配置文件</h1><p>nginx的配置文件在xxx&#x2F;nginx&#x2F;conf目录下的nginx.conf文件，我们需要对该文件进行一些配置需要知道该配置是由什么组成的？组成部分如下</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230215150412247.png" alt="image-20230215150412247"></p><p>（1）<strong>全局块：</strong>主要会设置一些影响nginx服务器整体运行的配置指令。</p><p>比如 worker_processes 1，worker_processes值越大，可以支持的并发处理量也越多</p><p>（2）<strong>events块：</strong>events涉及的指令主要是影响用户和Nginx服务器的网络连接数量</p><p>比如worker_connections  1024，表示用连接数最大为1024</p><p>（3）<strong>http块：</strong>这算是Nginx服务器配置中最频繁的部分，代理、缓存和日志定义等绝大多数功能和第三方模块的配置都在这里</p><p>如下图是http块的组成部分</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230215151525508.png" alt="image-20230215151525508"></p><h1 id="Nginx的应用"><a href="#Nginx的应用" class="headerlink" title="Nginx的应用"></a>Nginx的应用</h1><p>在这部分会实现反向代理、负载均衡、动静分离。</p><h2 id="反向代理的实现"><a href="#反向代理的实现" class="headerlink" title="反向代理的实现"></a>反向代理的实现</h2><p>需求：通过nginx代理服务器将<u><a href="http://www.123.com/">www.123.com</a></u>网站发送的请求转发到192.168.177.130:8080的服务器上，nginx的服务端口是192.168.166.120:80</p><p><strong>反向代理过程如下图</strong></p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230215153036342.png" alt="image-20230215153036342"></p><p>对nginx&#x2F;conf目录下的nginx.conf文件的配置参数如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"># 配置最大并发量</span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line"># 配置最大连接数</span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line"># 请求类型和响应类型</span><br><span class="line">    default_type  application/json;</span><br><span class="line"># 连接超时时间</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line"># 监听的ip端口192.168.166.120:80</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  192.168.166.120;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">         root   html/htm_pro;</span><br><span class="line"># 将发送的请求代理到192.168.177.130:8080</span><br><span class="line">proxy_pass 192.168.177.130:8080;</span><br><span class="line">         index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>进阶需求：</strong>根据用户访问不同的路径代理到不同的目标服务器上，现用户访问了两次不同的路径如下</p><p>（1）192.168.166.120:80&#x2F;edu&#x2F;index.html 代理到 192.168.130:8081服务器上。</p><p>（2）192.168.166.120:80&#x2F;gig&#x2F;index.html  代理到 192.168.130:8086服务器上。</p><p><strong>过程图如下</strong></p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230215155246819.png" alt="image-20230215155246819"></p><p>对nginx&#x2F;conf目录下的nginx.conf文件的配置参数如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"># 配置最大并发量</span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line"># 配置最大连接数</span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line"># 请求类型和响应类型</span><br><span class="line">    default_type  application/json;</span><br><span class="line"># 连接超时时间</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line"># 监听的ip端口192.168.166.120:80</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  192.168.166.120;</span><br><span class="line"># 访问根页面</span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html/htm_pro;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"># 若访问路径包含edu，则代理到192.168.130:8081</span><br><span class="line">location ~ /edu/ &#123;</span><br><span class="line">proxy_pass 192.168.130:8081;</span><br><span class="line">        &#125;</span><br><span class="line">        # 若访问路径包含gig，则代理到192.168.130:8086</span><br><span class="line">location ~ /gig/ &#123;</span><br><span class="line">proxy_pass 192.168.130:8086;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="负载均衡的实现"><a href="#负载均衡的实现" class="headerlink" title="负载均衡的实现"></a>负载均衡的实现</h2><p><strong>需求：</strong>现有两台服务器A和B，现在需要将用户的请求平均分配给A和B服务器，那么以下是配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"># 配置最大并发量</span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line"># 配置最大连接数</span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">   include mime.types;</span><br><span class="line"># 请求类型和响应类型</span><br><span class="line">   default_type  application/json;</span><br><span class="line"># 连接超时时间</span><br><span class="line">   keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line"># A和B的服务器列表</span><br><span class="line">upstream myserver&#123;</span><br><span class="line">    server 192.168.166.1:9091 # A的ip</span><br><span class="line">    server 192.168.166.1:9092 # B的ip</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line"> #监听的ip端口192.168.166.120:80</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  192.168.166.120;</span><br><span class="line"> #访问根页面</span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html/htm_pro;</span><br><span class="line">   proxy_pass http://myserver;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>四种负载均衡策略</strong></p><p>（1）轮询：每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。【默认】</p><p>（2）权重：weight代表权，重默认为1，权重越高的服务器被分配的客户端请求就越多。适用于各个服务器性能不均衡的情况下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream myserver&#123;</span><br><span class="line">server 192.168.166.1:9091 weight=10;</span><br><span class="line">server 192.168.166.1:9092 weight=20;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）ip_hash：每个请求按访间ip.的 hash结果分配,这样每个访额固定访问一个后端服务器,可以解决session的问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream myserver&#123;</span><br><span class="line">ip_hash;</span><br><span class="line">server 192.168.166.1:9091;</span><br><span class="line">server 192.168.166.1:9092;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）fair(第三方)：按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream myserver&#123;</span><br><span class="line">fair;</span><br><span class="line">server 192.168.166.1:9091;</span><br><span class="line">server 192.168.166.1:9092;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动静分离的实现"><a href="#动静分离的实现" class="headerlink" title="动静分离的实现"></a>动静分离的实现</h2><p>将静态资源（HTML、JS、CSS）文件放到…&#x2F;nginx&#x2F;html目录下即可，然后再配置nginx.conf文件，配置如下</p><pre><code>location / &#123;   # 配置静态资源的所在目录htm_pro   root   /htm_pro;   ndex  index.html index.htm;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Nginx的基本介绍&quot;&gt;&lt;a href=&quot;#Nginx的基本介绍&quot; class=&quot;headerlink&quot; title=&quot;Nginx的基本介绍&quot;&gt;&lt;/a&gt;Nginx的基本介绍&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;概述：&lt;/strong&gt;Nginx是一个高性能的HTTP反向</summary>
      
    
    
    
    
    <category term="nginx" scheme="http://example.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>23种设计模式详解笔记</title>
    <link href="http://example.com/2023/02/04/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2023/02/04/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-02-04T08:59:00.000Z</published>
    <updated>2023-02-16T02:51:49.937Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h1><p>在软件开发中，为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性，程序员要尽量根据6条原则来开发程序，从而提高软件开发效率、节约软件开发成本和维护成本。</p><h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><p><em><strong>对修改关闭，对扩展开放</strong></em>，在程序需要进行扩展的时候，不能修改原有的代码，程序设计之初就需要考虑如何扩展功能而不修改源码，实现一个动态扩展功能的效果，简而言之就是提高程序的可扩展性、易于维护和升级。</p><p>​下图是对开闭原则的一个实践测试，在现实生活中人们一部手机就可以走天下，这个很大程度得益于手机支付功能，手机支付有很多的渠道，有微信支付、支付宝支付、银行卡支付等等不同的支付方式，那你需要开发一个可以扩展这些支付的程序那应该如何设计呢？首先需要对支付这个行为抽象定义为抽象类，然后把具体的支付行为交给派生类去实现，这样就可以实现扩展支付的方式了。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230204180422604.png" alt="手机支付扩展图"></p><p>代码设计（demo）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  抽象支付类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractPayment</span> &#123;</span><br><span class="line">    <span class="comment">// 支付方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">payment</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  微信支付</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeixinPayment</span> <span class="keyword">extends</span> <span class="title class_">AbstractPayment</span>&#123;</span><br><span class="line">    <span class="comment">// 具体实现交由子类实现</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">payment</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;微信支付。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  支付宝支付</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZhifubaiPayment</span> <span class="keyword">extends</span> <span class="title class_">AbstractPayment</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">payment</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;支付宝支付。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  支付完成</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentComplete</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> AbstractPayment pay;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPay</span><span class="params">(AbstractPayment pay)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.pay = pay;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        pay.payment();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="里氏代换原则"><a href="#里氏代换原则" class="headerlink" title="里氏代换原则"></a>里氏代换原则</h2><p>里氏代换原则：任何基类可以出现的地方，子类一定可以出现。通俗理解∶子类可以扩展父类的功能，但不能改变父类原有的功能。换句话说，子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。</p><p>如果通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大。</p><p><strong>【例】长方体不是正方体</strong></p><p>​在数学领域里，正方形毫无疑问是长方形，它是一个长宽相等的长方形。所以，我们开发的一个与几何图形相关的软件系统，就可以顺理成章的让正方形继承自长方形。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230206142930889.png" alt="image-20230206142930889"></p><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  长方形类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="comment">// 宽度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> width;</span><br><span class="line">    <span class="comment">// 长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> length;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getWidth</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> width;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWidth</span><span class="params">(<span class="type">double</span> width)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getLength</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLength</span><span class="params">(<span class="type">double</span> length)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.length = length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  正方形：长和宽相同</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">extends</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLength</span><span class="params">(<span class="type">double</span> length)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.setLength(length);</span><br><span class="line">        <span class="built_in">super</span>.setWidth(length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWidth</span><span class="params">(<span class="type">double</span> width)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.setWidth(width);</span><br><span class="line">        <span class="built_in">super</span>.setLength(width);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RectangleDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建长方形对象</span></span><br><span class="line">        <span class="type">Rectangle</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line">        <span class="comment">// 设置长和宽</span></span><br><span class="line">        r.setLength(<span class="number">20.0</span>);</span><br><span class="line">        r.setWidth(<span class="number">10.0</span>);</span><br><span class="line">        <span class="comment">// 进行扩宽</span></span><br><span class="line">        resize(r);</span><br><span class="line">        <span class="comment">// 打印信息</span></span><br><span class="line">        printWidthAndLength(r);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;=======正方形扩宽=======&quot;</span>);</span><br><span class="line">        <span class="type">Square</span> <span class="variable">square</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Square</span>();</span><br><span class="line"></span><br><span class="line">        square.setWidth(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        resize(square);</span><br><span class="line">        printWidthAndLength(square);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 扩大宽度的方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(Rectangle rectangle)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (rectangle.getWidth() &lt;= rectangle.getLength()) &#123;</span><br><span class="line">            rectangle.setWidth(rectangle.getWidth() + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printWidthAndLength</span><span class="params">(Rectangle r)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;长度：&quot;</span> + r.getLength());</span><br><span class="line">        System.out.println(<span class="string">&quot;宽度：&quot;</span> + r.getWidth());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230206143910071.png" alt="image-20230206143910071"></p><p>​在运行结果中可以看出，在长方形扩宽操作中是符合我们的预期的，因为长方形不要求长和宽相等，故长方形的宽扩大时它的长是不会跟着改变的，而在正方形扩宽中是一个死循环，因为长方形的宽扩大时长也会跟的扩大，这样就会形成一个死循环，直到报错为止。我们得出结论：在resize方法中，Rectangle类型的参数是不能被Square类型的参数所代替，如果进行了替换就得不到预期结果。因此，Square类和Rectangle类之间的继承关系违反了里氏代换原则，它们之间的继承关系不成立，正方形不是长方形。</p><p>知道了问题的所在，那我们可以在抽象出一个四边形接口，来分别获取长方形和正方形的宽和长。看以下类图</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230206145939216.png" alt="image-20230206145939216"></p><h2 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h2><p>​高层模块不应该依赖底层模块，两者都应依赖于抽象，抽象不应该依赖细节，细节应该依赖于抽象。简单的说是要求对抽象进行编程而不是对细节实现进行编程。这样就降低了客户和实现模块的耦合。</p><p><strong>【例】组装电脑</strong></p><p>​现要组装一台电脑，需要配件cpu，硬盘，内存条。只有这些配置都有了，计算机才能正常的运行。选择cpu有很多选择，如Intel，AMD等，硬盘可以选择希捷，西数等，内存条可以选择金士顿，海盗船等。类图如下</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230206151504078.png" alt="image-20230206151504078"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  电脑</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line">    <span class="comment">// cpu</span></span><br><span class="line">    <span class="keyword">private</span> IntelCpu cpu;</span><br><span class="line">    <span class="comment">// 内存条</span></span><br><span class="line">    <span class="keyword">private</span> KingstonMemory memory;</span><br><span class="line">    <span class="comment">// 硬盘</span></span><br><span class="line">    <span class="keyword">private</span> XijieHardDisk hardDisk;</span><br><span class="line">    <span class="keyword">public</span> IntelCpu <span class="title function_">getCpu</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cpu;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCpu</span><span class="params">(IntelCpu cpu)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cpu = cpu;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> KingstonMemory <span class="title function_">getMemory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> memory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMemory</span><span class="params">(KingstonMemory memory)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.memory = memory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> XijieHardDisk <span class="title function_">getHardDisk</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> hardDisk;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHardDisk</span><span class="params">(XijieHardDisk hardDisk)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.hardDisk = hardDisk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;计算机启动中...&quot;</span>);</span><br><span class="line">        cpu.run();</span><br><span class="line">        memory.save();</span><br><span class="line">        hardDisk.save(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> hardDisk.getData();</span><br><span class="line">        System.out.println(<span class="string">&quot;从硬盘的初始化中读取到数据：&quot;</span> + data);</span><br><span class="line">        System.out.println(<span class="string">&quot;启动完成...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  IntelCpu -- 一种cpu的品牌</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntelCpu</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;IntelCpu正在运行中...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  金士顿内存条 -- 某种品牌</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KingstonMemory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;金士顿内存条正在保存数据...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  希捷硬盘类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XijieHardDisk</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(String data)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;数据在希捷硬盘中保存成功！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;数据从希捷硬盘中获取中...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;data...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComputerDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建组装计算机的各个部件</span></span><br><span class="line">        <span class="type">IntelCpu</span> <span class="variable">cpu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntelCpu</span>();</span><br><span class="line">        <span class="type">KingstonMemory</span> <span class="variable">memory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">KingstonMemory</span>();</span><br><span class="line">        <span class="type">XijieHardDisk</span> <span class="variable">hardDisk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XijieHardDisk</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 组装部件</span></span><br><span class="line">        computer.setCpu(cpu);</span><br><span class="line">        computer.setMemory(memory);</span><br><span class="line">        computer.setHardDisk(hardDisk);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 运行计算机</span></span><br><span class="line">        computer.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230206152951968.png" alt="image-20230206152951968"></p><p>​在以上的设计模式中存在一个问题，就是用户需要更换其他品牌的硬件时需要对原代码进行修改，这样就违反了开闭原则，那么可以根据依赖倒转原则进行改进，改进的类图如下</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230206160227874.png" alt="image-20230206160227874"></p><p>​这样设计可以解决起初设计的问题，用户若要更换其他品牌的内存或其他的硬件，则直接实现相关的接口重写方法即可，这样就不用对Computer中的代码进行修改了。</p><h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><p>客户端不应该被迫依赖于它不使用的方法；一个类对异个类的依赖应该建立在最小的接口上。概念过于抽象，请看下图可以有助于理解</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230206162548228.png" alt="image-20230206162548228"></p><p><strong>【例】不同类别的智能门</strong></p><p>​XX品牌的A类智能门上需要有人脸识别、密码解锁和指纹识别的功能；B类智能门需要有人脸识别和密码解锁功能；C类智能门需要有密码解锁功能；那应该如何设计才会比较合理呢？若将人脸识别、密码解锁和指纹识别抽象为一个接口，那明显不符合该需求，应该将人脸识别、密码解锁和指纹识别抽象为三个接口，哪类智能门需要哪个功能就实现哪个接口，这样就符合接口隔离原则，详细类图如下（该类图是实现了A类智能门，其余智能门实现思路只需要实现相应的接口即可）</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230206165528415.png" alt="image-20230206165528415"></p><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  密码解锁 功能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PasswordUnlock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">passwordValidate</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指纹识别</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RecognitionDactylogram</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dactylogramValidate</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  人脸识别 功能接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RecognitionSurface</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">surfaceValidate</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  A类智能门</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntelligentDoorA</span> <span class="keyword">implements</span> <span class="title class_">PasswordUnlock</span>,RecognitionSurface,RecognitionDactylogram&#123;</span><br><span class="line">    <span class="comment">// 类别</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">char</span> <span class="variable">type</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(type + <span class="string">&quot;类智能门正在工作。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 密码验证</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">passwordValidate</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;密码认证服务启动成功。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 指纹验证</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dactylogramValidate</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;指纹认证服务启动成功。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 扫脸验证</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">surfaceValidate</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;扫脸识别服务启动成功。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  智能门测试类 -- 接口隔离原则</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntelligentDoorDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建A类智能门对象</span></span><br><span class="line">        <span class="type">IntelligentDoorA</span> <span class="variable">doorA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntelligentDoorA</span>();</span><br><span class="line">        <span class="comment">// 启动服务</span></span><br><span class="line">        doorA.dactylogramValidate();</span><br><span class="line">        doorA.surfaceValidate();</span><br><span class="line">        doorA.passwordValidate();</span><br><span class="line"></span><br><span class="line">        doorA.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230206170929837.png" alt="image-20230206170929837"></p><h2 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h2><p>迪米特法则又叫最少知识原则。</p><p>只和你的直接朋友交谈，不跟”陌生人”说话“(Talk only to your immediate friends and not to strangers)。</p><p>其含义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。</p><p>迪米特法则中的”朋友”是指:当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。概念有些抽象，请看下图理解</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230206194111351.png" alt="image-20230206194111351"></p><p>【例】明星和经纪人的关系</p><p>​明星由于全身心投入工作中，所以许多日常事务由经纪人负责处理，如和粉丝的见面会，和媒体公司的业务洽淡等。这里的经纪人是明星的朋友，而粉丝和媒体公司是陌生人，所以适合使用迪米特法则。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230206192156492.png" alt="image-20230206192156492"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  公司类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Company</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  粉丝类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fans</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  明星类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Star</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  经纪人代理类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Agent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Fans fans;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Company company;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Star star;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFans</span><span class="params">(Fans fans)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.fans = fans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCompany</span><span class="params">(Company company)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.company = company;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStar</span><span class="params">(Star star)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.star = star;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 安排粉丝见面</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">meeting</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(fans.getName() + <span class="string">&quot;和&quot;</span> + star.getName() + <span class="string">&quot;见面了~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理与其他公司的合作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">business</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(company.getName() + <span class="string">&quot;和&quot;</span> + star.getName() + <span class="string">&quot;又签约了1年的合同~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AgentDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建经纪人对象</span></span><br><span class="line">        <span class="type">Agent</span> <span class="variable">agent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Agent</span>();</span><br><span class="line">        <span class="comment">// 公司</span></span><br><span class="line">        <span class="type">Company</span> <span class="variable">company</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Company</span>();</span><br><span class="line">        company.setName(<span class="string">&quot;XXX娱乐传媒公司&quot;</span>);</span><br><span class="line">        <span class="comment">// 粉丝</span></span><br><span class="line">        <span class="type">Fans</span> <span class="variable">fans</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Fans</span>();</span><br><span class="line">        fans.setName(<span class="string">&quot;小明&quot;</span>);</span><br><span class="line">        <span class="comment">// 明星</span></span><br><span class="line">        <span class="type">Star</span> <span class="variable">star</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Star</span>();</span><br><span class="line">        star.setName(<span class="string">&quot;ikun&quot;</span>);</span><br><span class="line">        <span class="comment">// 粉丝和明星的见面、明星与公司的业务都是通过经纪人的代理的</span></span><br><span class="line">        agent.setCompany(company);</span><br><span class="line">        agent.setFans(fans);</span><br><span class="line">        agent.setStar(star);</span><br><span class="line">        <span class="comment">// 开始见面会和业务合作</span></span><br><span class="line">        agent.business();</span><br><span class="line">        agent.meeting();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h2><p>合成复用原则是指:尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。通常类的复用分为继承复用和合成复用两种。</p><p>继承复用虽然有简单和易实现的优点，但它也存在以下缺点:</p><ol><li>继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为”白箱”复用。</li><li>子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。</li><li>它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。</li></ol><p>采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能。以下是它的优点</p><ol><li>它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为”黑箱”复用。</li><li>对象间的耦合度低。可以在类的成员位置声明抽象。</li><li>复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。</li></ol><p>【例】汽车分类管理程序</p><p>​汽车有很多的标准来进行分类，可以按颜色分为白色、黑色等等，也可以按照“动力源”的不同分为需要加油的汽车和需要充电的汽车，那么通过颜色和动力源进行组合可以组合成：白色汽车、白色电动汽车、黑色汽车、黑色电动汽车等等，以下类图是通过继承的方式去实现该需求。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230206201613763.png" alt="image-20230206201613763"></p><p>​那么按照以上的设计，如果需要新增新能源汽车类别，那应该如何新增呢？那就需要让新能汽车类继承Car类，从而在根据颜色继承新能源汽车类，这样就会至少得增加2个类，若又有很多颜色的汽车，那还要增加类，这样就有点不合理。我们可以通过聚合的方式去设计，避免多级继承，如下是改进后的类图</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230206202625839.png" alt="image-20230206202625839"></p><h1 id="创建者模式"><a href="#创建者模式" class="headerlink" title="创建者模式"></a>创建者模式</h1><p>创建型模式的主要关注点是”怎样创建对象? ”，它的主要特点是”将对象的创建与使用分离”。这样可以降低系统的耦合度，使用者不需要关注对象的创建细节。</p><p>创建者模式可以分为</p><ul><li>单例模式</li><li>工厂 方法模式</li><li>抽象工程模式</li><li>原型模式</li><li>建造者模式</li></ul><h2 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h2><p>单例设计模式是java设计模式中最简单的一种设计模式，这种模式下只涉及到一个类对象被创建，需要保证该类创建的对象只能有一个，提供一个访问该类的唯一对象方法，实例化一次，然后每次访问的对象都是同一个，这就是单例设计模式。</p><p><strong>单例模式的实现</strong></p><p>单例模式分为两种：</p><ul><li>饿汉式：类加载就会导致单例对象被创建</li><li>懒汉式：类加载不会使单例对象被创建，只有在首次用到对象时才会被创建</li></ul><h3 id="饿汉式单例设计模式"><a href="#饿汉式单例设计模式" class="headerlink" title="饿汉式单例设计模式"></a>饿汉式单例设计模式</h3><p>单例模式直接在成员变量中实例化并将其设为静态变量，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  单例类 -- 饿汉式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;单例类初始化。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供访问唯一对象的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>利用静态代码块实现饿汉式单例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  单例类 -- 饿汉式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;单例类初始化。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供访问唯一对象的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="懒汉式单例设计模式"><a href="#懒汉式单例设计模式" class="headerlink" title="懒汉式单例设计模式"></a>懒汉式单例设计模式</h3><p>概述：使用饿汉式单例设计模式，如果在某个单例类所占用的内存很大，可能会发生内存浪费问题，因为饿汉式在类加载阶段就被创建，而该类一直并未被使用，最后就占着茅坑不拉屎。那么可以使用懒汉式加载单例模式，但其有个缺点：懒汉式响应的速度比饿汉式的慢，因为懒汉式只有对象被使用时才进行加载的，而饿汉式对象还未被使用就已经提前加载完了。以下是实现懒汉式的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  懒汉式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;懒汉式单例初始化。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>懒汉式(静态内部类方式)</strong></p><p>​静态内部类单例模式中实例由内部类创建，由于JM在加载外部类的过程中，是不会加载静态内部类的，只有内部类的属性&#x2F;方法被调用时才会被加载，并初始化其静态属性。静态属性由于被static修饰，保证只被实例化一次，并且严格保证实例化顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  懒汉式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;懒汉式单例初始化。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong>第一次加载Singleton类是不会初始化实例的，当只有调用getInstance()方法时JVM虚拟机会加载SingletonHolder并初始化instance实例，这样不仅保证了线程安全，也保证了创建Singleton的唯一性。</p><p><strong>小结：</strong>静态内部类方式创建懒汉式单例模式是比较优秀的创建方式，在很多的开源项目中都会优先采用该方式，在没有加任何锁的情况下解决了线程安全破坏单例，并且性能没有收到影响和造成内存浪费问题。</p><p>注意：这样有几种方式会破坏单例，因为我在java面试篇中有详细说明到，所以在这不多赘述。</p><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>概述：工厂模式就类似我们生活中加工厂，从其它地方提供原料到加工厂中进行装配，待装配完成后就可以将完整的产品出厂。工厂模式分很多种模式，如下</p><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>【例】点咖啡案例</p><p>咖啡在我们生活中随处可见，咖啡有分为美式咖啡、拿铁、玛奇朵等等种类，现在个需求就是根据客户需要生产出不同的咖啡，因为有些咖啡非常的苦，可以根据客户需求进行加糖或者加奶，现有一个咖啡店，这种需求符合工厂模式，类图如下</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230207142341618.png" alt="image-20230207142341618"></p><p>代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  咖啡类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span> <span class="keyword">instanceof</span> AmericanoCoffee) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;美式咖啡&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span> <span class="keyword">instanceof</span>  LatteCoffee)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;拿铁咖啡&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">adSugar</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;加糖步骤完成。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addMilk</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;加奶步骤完成。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  美式咖啡</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AmericanoCoffee</span> <span class="keyword">extends</span> <span class="title class_">Coffee</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  拿铁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LatteCoffee</span> <span class="keyword">extends</span> <span class="title class_">Coffee</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  咖啡店</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CoffeeStore</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">orderCoffee</span><span class="params">(Class&lt;?&gt; type)</span> &#123;</span><br><span class="line">        Coffee coffee;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(AmericanoCoffee.class == type) &#123;</span><br><span class="line">            <span class="comment">// 创建美式咖啡</span></span><br><span class="line">            coffee = <span class="keyword">new</span> <span class="title class_">AmericanoCoffee</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(LatteCoffee.class == type) &#123;</span><br><span class="line">            <span class="comment">// 创建拿铁</span></span><br><span class="line">            coffee = <span class="keyword">new</span> <span class="title class_">LatteCoffee</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;咖啡不存在~~~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 加配料</span></span><br><span class="line">        coffee.addMilk();</span><br><span class="line">        coffee.adSugar();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> coffee.getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CoffeeStore</span> <span class="variable">store</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CoffeeStore</span>();</span><br><span class="line">        <span class="comment">// 客户点咖啡</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">coffeeName</span> <span class="operator">=</span> store.orderCoffee(AmericanoCoffee.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;客户拿到了【&quot;</span> + coffeeName + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong>在引入中的例子存在着Coffee(咖啡)类和CoffeeStore(咖啡店)类的耦合，因为在orderCoffee中每次都需要根据客户需求去new不同的对象，创建(new)对象的操作本身就是高耦合的操作，若咖啡店中需要引入新种类的咖啡，在以上的设计中是需要修改orderCoffee方法中的判断的，这样就违背了【开闭原则】，若使用工厂模式来设计的话，我们只需要跟工厂打交道，若出现新种类的咖啡，那么就交给工厂本身内部处理即可，这样就达到了与对象解耦的目的了，所有工厂模式最大的优点就是【解耦】。工厂模式分以下几种</p><h3 id="2-2-1-简单工厂模式"><a href="#2-2-1-简单工厂模式" class="headerlink" title="2.2.1 简单工厂模式"></a>2.2.1 简单工厂模式</h3><p>简单工厂模式不是一种设计模式，是一种编程习惯</p><p><strong>组成结构如下：</strong></p><ul><li>抽象产品：定义了产品的规范，描述了产品的主要特性和功能</li><li>具体产品：实现或者继承抽象产品的子类</li><li>具体工厂：提供了创建产品的方法，调用者通过该方法来创建产品</li></ul><p>对引入中例子通过简单工厂模式进行改进，咖啡店中的咖啡从专门生产咖啡中获取咖啡原料，咖啡工厂根据咖啡店所需要的咖啡豆生产即可，改进后的类图如下图</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230207150115757.png" alt="image-20230207150115757"></p><p>代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  美式咖啡</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AmericanoCoffee</span> <span class="keyword">extends</span> <span class="title class_">Coffee</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  拿铁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LatteCoffee</span> <span class="keyword">extends</span> <span class="title class_">Coffee</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  咖啡类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span> <span class="keyword">instanceof</span> AmericanoCoffee) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;美式咖啡&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span> <span class="keyword">instanceof</span>  LatteCoffee)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;拿铁咖啡&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">adSugar</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;加糖步骤完成。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addMilk</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;加奶步骤完成。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  咖啡店</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CoffeeStore</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">orderCoffee</span><span class="params">(Class&lt;?&gt; type)</span> &#123;</span><br><span class="line">        <span class="type">SimpleCoffeeFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleCoffeeFactory</span>();</span><br><span class="line">        <span class="comment">// 从工厂中获取咖啡</span></span><br><span class="line">        <span class="type">Coffee</span> <span class="variable">coffee</span> <span class="operator">=</span> factory.produceCoffee(type);</span><br><span class="line">        <span class="comment">// 加配料</span></span><br><span class="line">        coffee.addMilk();</span><br><span class="line">        coffee.adSugar();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> coffee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  简单咖啡工厂 -- 专门生成咖啡</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleCoffeeFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生产咖啡</span></span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">produceCoffee</span><span class="params">(Class&lt;?&gt; type)</span> &#123;</span><br><span class="line">        Coffee coffee;</span><br><span class="line">        <span class="comment">// 获取全部子类</span></span><br><span class="line">        <span class="keyword">if</span>(AmericanoCoffee.class == type) &#123;</span><br><span class="line">            <span class="comment">// 创建美式咖啡</span></span><br><span class="line">            coffee = <span class="keyword">new</span> <span class="title class_">AmericanoCoffee</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(LatteCoffee.class == type) &#123;</span><br><span class="line">            <span class="comment">// 创建拿铁</span></span><br><span class="line">            coffee = <span class="keyword">new</span> <span class="title class_">LatteCoffee</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;咖啡不存在~~~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> coffee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong>以上的设计中CoffeeStore每次都是从简单咖啡工厂中获取咖啡原料，而不必关心咖啡原料的加工过程，这样实现了CoffeeStore和Coffee的解耦，同时又产生了新的耦合简单咖啡工厂和咖啡的耦合，若又有新的咖啡新品加入的话需要修改SimpleCoffeeFactory类中的处理逻辑，这样也是违反了【开闭原则】，但比起初设计修修改更为简单，只需要修改SimpleCoffeeFactory中的即可省去了其它的操作。</p><h3 id="2-2-2-工厂方法模式"><a href="#2-2-2-工厂方法模式" class="headerlink" title="2.2.2 工厂方法模式"></a>2.2.2 工厂方法模式</h3><p>概念：定义一个用于创建对象的接口，让子类决定实例化哪个产品类对象。工厂方法使一个产品类的实例化延迟到其工厂的子类。</p><p>工厂方法的主要结构如下</p><ul><li>抽象工厂：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品。</li><li>具体工厂：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。</li><li>抽象产品：定义产品的规范，描述产品的特征和功能</li><li>具体产品：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。</li></ul><p>对以上的例子通过工厂方法模式进一步改进，在这次改进中可以遵守【开闭原则】，类图如下</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230208125507300.png" alt="image-20230208125507300"></p><p>代码自行测试</p><p><strong>工厂方法的优点</strong></p><ul><li>用户只需要知道具体工厂的名称就可以获取到产品，无需知道产品的实现细节</li><li>在系统中添加新产品时只需要添加具体工厂类和具体产品类分别继承对应的父类，这样无需修改源码，满足【开闭原则】</li></ul><p><strong>工厂方法的缺点</strong></p><ul><li>每增加一个新产品都需要添加一个具体工厂和具体产品类，这无疑是增加了系统的复杂度，对后期维护非常的不友好</li></ul><h3 id="2-2-3-抽象工厂模式"><a href="#2-2-3-抽象工厂模式" class="headerlink" title="2.2.3 抽象工厂模式"></a>2.2.3 抽象工厂模式</h3><p>前面介绍的工厂方法模式中考虑的是一类产品的生产，如畜牧场只养动物、电视机厂只生产电视机、服装厂只生产服装等。</p><p>​这些工厂只生产同种类产品，同种类产品称为同等级产品，也就是说：工厂方法模式只考虑生产同等级的产品，但是在现实生活中许多工厂是综合型的工厂，能生产多等级（种类)―的产品，如电器厂既生产电视机又生产洗衣机或空调，大学既有软件专业又有生物专业等。本章要介绍的抽象工厂模式将考虑多等级产品的生产，将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族</p><p><strong>抽象工厂模式结构</strong></p><ul><li>抽象工厂(Abstract Factory)：提供了创建产品的接口，它包含多个创建产品的方法，可以创建多个不同等级的产品。</li><li>具体工厂(Concrete Factory)︰主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。</li><li>抽象产品(Product)：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。</li><li>具体产品(Cancrete Product)：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间是多对一的关系。</li></ul><p><strong>【例】服装厂的生产</strong></p><p>XX服装厂中有生产很多种类的服装，有西式、古风等风格的服装，西式风格的服装有：西装、茄克衫等等；古风类型的服装有：盘扣立领连衣裙、国潮长袖针织衫等等，该服装厂还有生产领带、项链等服饰。若采用 工厂方法模式模式设计在如此多的风格下很容易产生类爆炸，按照抽象工厂模式设计，只需要将服装风格分为古风类和西式风格类，领带、胸针划分为西式配饰类；步摇、发带划分为古风配饰中；最后将西式风格类和西式配饰类分发给西式工厂生产，古风配饰和古风分发给古风服装工厂生产。以下类图会描述更清楚</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230208141215630.png" alt="image-20230208141215630"></p><p><strong>抽象工厂模式的优缺点</strong></p><p><strong>优点：</strong>当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。</p><p><strong>缺点：</strong>当新增新产品时所有的工厂类中的代码都需要修改</p><p><strong>使用场景如下</strong></p><ul><li><p>当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等</p></li><li><p>系统中有多个产品族，但每次只使用其中的某一族产品。如有人只喜欢穿某一个品牌的衣服和鞋。</p></li><li><p>系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。</p></li></ul><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p><strong>概述：</strong>用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型对象相同的新对象（类似克隆）。</p><p><strong>结构：</strong></p><ul><li>抽象原型类：规定了具体原型对象必须实现的的 clone ()方法。</li><li>具体原型类：实现抽象原型类的clone ()方法，它是可被复制的对象。</li><li>访问类：使用具体原型类中的 clone ()方法来复制新的对象。</li></ul><p>接口类图如下</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230209144558097.png" alt="image-20230209144558097"></p><p><strong>原型模式分为深克隆和浅克隆</strong></p><p><strong>浅克隆：</strong>创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。（克隆出来的对象与原对象地址是相同的）</p><p><strong>深克隆：</strong>创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。（克隆出来的对象地址与原对象不同）</p><p>Java中的object类中提供了clone()方法来实现浅克隆。cloneable接口是上面的类图中的抽象原型类，而实现了cloneable接口的子实现类就是具体的原型类。代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  真实对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Realizetype</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Realizetype</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;原型真实对象创建成功~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;克隆对象创建成功！！！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>【例】克隆羊</strong></p><p>克隆羊一般外形都会很向，所以需要对克隆羊进行编号以防识别混乱，所以克隆羊除了编号不同，宏观上都几乎相同，以下是克隆羊的类图</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230209151345250.png" alt="image-20230209151345250"></p><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  真实的羊</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RealSheep</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;羊名称：【&quot;</span> + name + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> RealSheep <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> (RealSheep) <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CloneSheepTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">RealSheep</span> <span class="variable">realSheep</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealSheep</span>();</span><br><span class="line">        <span class="comment">// 克隆</span></span><br><span class="line">        <span class="type">RealSheep</span> <span class="variable">clone1</span> <span class="operator">=</span> realSheep.clone();</span><br><span class="line">        realSheep.setName(<span class="string">&quot;多利（真实羊）&quot;</span>);</span><br><span class="line">        clone1.setName(<span class="string">&quot;001（克隆羊）&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印</span></span><br><span class="line">        realSheep.show();</span><br><span class="line">        clone1.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>概述：将一个复杂对象的构建和表示分离，使同样的构建过程可以创建不同的表示</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230210142739106.png" alt="image-20230210142739106"></p><p>( 1 )、分离了部件的构建（由Builder完成）和装配（由Director完成），从而构建出复杂对象，适用于：某个对象的构建过程复杂的情况</p><p>( 2 ) 、由于实现了装配和构建器的解耦，相同的构建器，不同的装配可以建造出不同的对象；不同的构建器，相同的装配也可创建出不同的对象，提高了复用性</p><p>( 3 )、建造者模式可以将部件和组装过程分开，一步一步构建复杂对象，用户只需要指定目标对象，就可以获得该对象，无需关心内部实现。</p><p><strong>建造者模式的结构</strong></p><p>( 1 )、抽象建造者类(Builder)：这个接口规定要实现复杂对象的那些部分的创建，并不涉及具体的部件对象的创建。</p><p>( 2 )、具体建造者类(ConcreteBuilder)：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。在构造过程完成后，提供产品的实例。</p><p>( 3 )、产品类(Product)：要创建的复杂对象。</p><p>( 4 )、指挥者类(Director)：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230210145317708.png" alt="image-20230210145317708"></p><p>【例】手机的生产构建</p><p>假设，手机的构建过程都是大同小异，不同品牌的手机可能外形不一样或者内部芯片不一样，但归根结底每种智能手机都有芯片、存储器（内存）等部件，这样的一个构建过程就可以使用创建者模式进行构建出。现在需要构建出OPPO和华为这两种品牌的手机，只需要构建芯片、存储器（内存）即可，类图如下</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230210153633699.png" alt="image-20230210153633699"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  智能手机类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Smartphone</span> &#123;</span><br><span class="line">    <span class="comment">// 名称</span></span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="comment">// 品牌</span></span><br><span class="line">    <span class="keyword">protected</span> String brand;</span><br><span class="line">    <span class="comment">// 内存</span></span><br><span class="line">    <span class="keyword">private</span> String memory;</span><br><span class="line">    <span class="comment">// 芯片</span></span><br><span class="line">    <span class="keyword">private</span> String chip;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMemory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> memory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMemory</span><span class="params">(String memory)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.memory = memory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getChip</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> chip;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setChip</span><span class="params">(String chip)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.chip = chip;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  oppo品牌手机</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OppoPhone</span> <span class="keyword">extends</span> <span class="title class_">Builder</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">buildChip</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.phone.setChip(<span class="string">&quot;马里亚纳 MariSilicon X&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">buildMemory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.phone.setMemory(<span class="string">&quot;128G&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">buildBaseInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.phone.brand = <span class="string">&quot;OPPO&quot;</span>;</span><br><span class="line">        <span class="built_in">super</span>.phone.name = <span class="string">&quot;OPPO Reno9&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Smartphone <span class="title function_">getProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> phone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  华为</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HuaweiPhone</span> <span class="keyword">extends</span> <span class="title class_">Builder</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">buildChip</span><span class="params">()</span> &#123;</span><br><span class="line">        phone.setChip(<span class="string">&quot;骁龙888&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">buildMemory</span><span class="params">()</span> &#123;</span><br><span class="line">        phone.setMemory(<span class="string">&quot;256G&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">buildBaseInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        phone.name = <span class="string">&quot;HUAWEI P50&quot;</span>;</span><br><span class="line">        phone.brand = <span class="string">&quot;华为&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Smartphone <span class="title function_">getProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> phone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  指挥者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Director</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Builder builder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Director</span><span class="params">(Builder builder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.builder = builder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取已构建完成的产品</span></span><br><span class="line">    <span class="keyword">public</span> Smartphone <span class="title function_">construct</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 装配</span></span><br><span class="line">        builder.buildChip();</span><br><span class="line">        builder.buildMemory();</span><br><span class="line">        builder.buildBaseInfo();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> builder.getProduct();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  抽象建造者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">Smartphone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Smartphone</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建芯片</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildChip</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 构建内存</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildMemory</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 构建基础信息</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildBaseInfo</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 获取到具体产品</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> Smartphone <span class="title function_">getProduct</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  客户</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建指挥者对象并传入目标品牌的手机对象</span></span><br><span class="line">        <span class="comment">// Director director = new Director(new HuaweiPhone());</span></span><br><span class="line">        <span class="type">Director</span> <span class="variable">director</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Director</span>(<span class="keyword">new</span> <span class="title class_">OppoPhone</span>());</span><br><span class="line">        <span class="comment">// 进行构建</span></span><br><span class="line">        <span class="type">Smartphone</span> <span class="variable">phone</span> <span class="operator">=</span> director.construct();</span><br><span class="line">        <span class="comment">// 打印信息</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;成功建造出 品牌【%s】,名称【%s】,芯片型号【%s】,内存【%s】&quot;</span>,phone.brand,phone.name,</span><br><span class="line">                phone.getChip(),phone.getMemory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点如下</strong></p><p>( 1 )、建造者模式的封装性很好。使用建造者模式可以有效的封装变化，在使用建造者模式的场景中，一般产品类和建造者类是比较稳定的，因此，将主要的业务逻辑封装在指挥者类中对整体而言可以取得比较好的稳定性。</p><p>( 2 )、在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。</p><p>( 3 )、可以更加精细地控制产品的创建过程。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。</p><p>( 4 )、建造者模式很容易进行扩展。如果有新的需求，通过实现一个新的建造者类就可以完成，基本上不用修改之前已经测试通过的代码，因此也就不会对原有功能引入风险。符合【开闭原则】。</p><p><strong>缺点：</strong>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。</p><p><em><strong>使用场景</strong></em></p><p>建造者(Builder)模式创建的是复杂对象，其产品的各个部分经常面临着剧烈的变化，但将它们组合在一起的算法却相对稳定，所以它通常在以下场合使用。</p><p>( 1 )、创建的对象较复杂，由多个部件构成，各部件面临着复杂的变化，但构件间的建造顺序是稳定的。</p><p>( 2 )、创建复杂对象的算法独立于该对象的组成部分以及它们的装配方式，即产品的构建过程和最终的表示是独立的。</p><h2 id="创建者模式的对比"><a href="#创建者模式的对比" class="headerlink" title="创建者模式的对比"></a>创建者模式的对比</h2><h3 id="工厂方法模式VS建造者模式"><a href="#工厂方法模式VS建造者模式" class="headerlink" title="工厂方法模式VS建造者模式"></a>工厂方法模式VS建造者模式</h3><p>工厂方法模式注重的是对整体对象的创建，而建造者模式注重的是部件构建的过程，意在一步一步的通过精确的构建出复杂对象</p><p><strong>例子：</strong>假如A工厂（采用工厂方法模式）需要生产台式电脑，那么A工厂是直接生产出整台的电脑。B工厂（采用建造者模式）生产台式电脑是通过一个一个部件组装成一台电脑。</p><h3 id="抽象工厂模式VS建造者模式"><a href="#抽象工厂模式VS建造者模式" class="headerlink" title="抽象工厂模式VS建造者模式"></a>抽象工厂模式VS建造者模式</h3><p>抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式则是不需要关心构建过程，只关心什么产品由什么工厂生产即可。</p><p>建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品。</p><p>如果将抽象工厂模式看成汽车配件生产工厂，生产一个产品族的产品，那么建造者模式就是一个汽车组装工厂，通过对部件的组装可以制造出—辆完整的汽车</p><h1 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h1><p>概述：结构型模式描述如何将类或对象按某种布局组成更大的结构。它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类。后者采用组合或聚合来组合对象。由于组合关系或聚合关系比继承关系耦合度低，满足【合成复用原则】，所以对象结构型模式比类结构型模式具有更大的灵活性。</p><p><strong>分为7种模式：代理模式、适配器模式、桥接模式、装饰模式、外观模式、组合模式、享元模式。</strong></p><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p><strong>概述：</strong>由于某种原因需要某个对象提供代理控制对该对象访问。这时，访问对象不适合或者不能直接访问到目标对象，代理对象是作为访问对象和目标对象的中介</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230212133649876.png" alt="image-20230212133649876"></p><p><strong>分类：</strong>java中按照代理类生成时机不同，分为<u>静态代理</u>和<u>动态代理</u>，静态代理类是在编译时期完成，动态代理是在java程序运行时期动态生成的类，动态代理又分为JDK和CGLIB代理。</p><p>代理模式分为以下三最种角色：</p><p>( 1 )、抽象主题(subject)类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。</p><p>( 2 )、真实主题(Real subject)类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。</p><p>( 3 )、代理(Proxy)类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问控制或扩展真实主题的功能。</p><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p><strong>【例】火车站买票</strong> </p><p>如果要买火车票的话，需要去火车站买票，坐车到火车站，排队等一系列的操作，显然比较麻烦而火车站在多个地方都有代售点，我们去代售点买票就方便很多了。这个例子其实就是典型的代理模式，火车站是目标对象，代售点是代理对象。类图如下：</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230212134745447.png" alt="image-20230212134745447"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  售卖票窗口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SellTicketWindow</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sellTicket</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  火车站</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrainStation</span> <span class="keyword">implements</span> <span class="title class_">SellTicketWindow</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sellTicket</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;火车票数售卖成功~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  代理售卖点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyPoint</span> <span class="keyword">implements</span> <span class="title class_">SellTicketWindow</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">TrainStation</span> <span class="variable">trainStation</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrainStation</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sellTicket</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;收取售卖代理费用10元&quot;</span>);</span><br><span class="line">        trainStation.sellTicket();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  客户</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 用户找代理商买票</span></span><br><span class="line">        <span class="type">ProxyPoint</span> <span class="variable">point</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyPoint</span>();</span><br><span class="line"></span><br><span class="line">        point.sellTicket();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong>从以上代码中可以看出ProxyPoint类是目标对象和访问对象的中介，ProxyPoint类可以对售卖票这一行为进行增强，例如收取一定的代理服务费用等等</p><h3 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><p>对【火车站买票】卖票的例子进行一个改造，使用动态代理动态生成代理售卖点，使用java提供的java.lang.reflect.Proxy包下的newProxyInstance方法动态代理，<strong>注意：JDK代理是只能对接口进行代理。</strong></p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230212203321103.png" alt="image-20230212203321103"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  售卖票窗口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SellTicketWindow</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sellTicket</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  火车站</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrainStation</span> <span class="keyword">implements</span> <span class="title class_">SellTicketWindow</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sellTicket</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;火车票数售卖成功~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  获取代理对象的工厂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyPointFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> TrainStation station;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        station = <span class="keyword">new</span> <span class="title class_">TrainStation</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SellTicketWindow <span class="title function_">getProxyPoint</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">SellTicketWindow</span> <span class="variable">instance</span> <span class="operator">=</span> (SellTicketWindow) Proxy.newProxyInstance(</span><br><span class="line">                station.getClass().getClassLoader(),</span><br><span class="line">                station.getClass().getInterfaces(),</span><br><span class="line">                <span class="comment">// 动态代理后执行的方法</span></span><br><span class="line">                ((proxy, method, args) -&gt; &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;收取代理费用（JDK动态代理执行）&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span>  method.invoke(station,args);</span><br><span class="line">                &#125;));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建代理工厂</span></span><br><span class="line">        <span class="type">ProxyPointFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyPointFactory</span>();</span><br><span class="line">        <span class="comment">// 从代理工厂中生产一个代理对象</span></span><br><span class="line">        <span class="type">SellTicketWindow</span> <span class="variable">proxyPoint</span> <span class="operator">=</span> factory.getProxyPoint();</span><br><span class="line">        proxyPoint.sellTicket();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态代理VS动态代理"><a href="#静态代理VS动态代理" class="headerlink" title="静态代理VS动态代理"></a>静态代理VS动态代理</h3><p>动态代理与静态代理相比较，最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理。这样，在接口方法数量比较多的时候，我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。如果接口增加一个方法，静态代理模式除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。而动态代理不会出现该问题</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>优点：</strong></p><p>( 1 )、代理模式是在客户端和目标对象中起一个中介和保护的作用</p><p>( 2 )、代理对象可以扩展目标对象的功能</p><p>( 3 )、代理对象分离了客户端和目标对象之间的直接访问，在一定程度上降低了系统的耦合度</p><p><strong>缺点：</strong>增加了系统的复杂度</p><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p><strong>定义：</strong>将一个类的接口转换成用户所期望的接口，使得原本不兼容的接口能在一起工作。</p><p><strong>分类：</strong>适配器模式分为【对象适配器】和【类适配器】，类适配器需要程序员了解类内部组件且耦合度较高，一般使用【对象适配器】</p><p><strong>适配器模式(Adapter）包含以下主要角色</strong></p><p>( 1 )、目标(Target)接口：当前系统业务所期待的接口，它可以是抽象类或接口</p><p>( 2 )、适配者(Adaptee)类：它是被访问和适配的现存组件库中的组件接口。</p><p>( 3 )、适配器(Adapter)类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问活配者。</p><h3 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a>类适配器</h3><p><strong>【例】读卡器</strong></p><p>现有一台计算机只能读取SD卡中的内容，那么需要读取TF卡中的内容就需要使用到适配器模式，通过适配器将TF接口转化为SD接口兼容工作。类图如下</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230213212659143.png" alt="image-20230213212659143"></p><p><strong>注意：</strong>类适配器模式违背了【合成复用原则】。类适配器是客户类有一个接口规范的情况下可用，反之不可用</p><h3 id="对象适配器"><a href="#对象适配器" class="headerlink" title="对象适配器"></a>对象适配器</h3><p>对<strong>【例】读卡器</strong>进行了一个改造，将TFCard接口聚合到适配器类中，这样一来就符合了【合成复用原则】</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230213215059035.png" alt="image-20230213215059035"></p><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>( 1 )、以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。</p><p>( 2 )、使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。</p><h3 id="JDK中的适配器应用"><a href="#JDK中的适配器应用" class="headerlink" title="JDK中的适配器应用"></a>JDK中的适配器应用</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;设计原则&quot;&gt;&lt;a href=&quot;#设计原则&quot; class=&quot;headerlink&quot; title=&quot;设计原则&quot;&gt;&lt;/a&gt;设计原则&lt;/h1&gt;&lt;p&gt;在软件开发中，为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性，程序员要尽量根据6条原则来开发程序，从而提高</summary>
      
    
    
    
    
    <category term="java;设计模式;" scheme="http://example.com/tags/java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>java实现二维码</title>
    <link href="http://example.com/2023/01/26/java%E5%AE%9E%E7%8E%B0%E4%BA%8C%E7%BB%B4%E7%A0%81/"/>
    <id>http://example.com/2023/01/26/java%E5%AE%9E%E7%8E%B0%E4%BA%8C%E7%BB%B4%E7%A0%81/</id>
    <published>2023-01-26T12:34:00.000Z</published>
    <updated>2023-02-25T09:54:39.231Z</updated>
    
    <content type="html"><![CDATA[<p>本文章中会介绍如何使用Hutool开源工具包进行二维码的生成，在业务需求中也经常看到需要用到二维码，可以用二维码进行手机扫码登入、扫码支付、扫码加好友等等一系列的需求，但人们知道使用二维码，那二维码到底是一个什么样的实现过程呢？更多详情请看下文</p><p><strong>实现步骤如下</strong></p><p>( 1 ) 首先需要创建一个SpringBoot的项目工程。</p><p>( 2 )  在pom.xml文件中引入以下三个坐标，这三个包中已经实现了二维码的底层，我们只需要调用其所提供的API接口进行一些参数的调整即可。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- zxing生成二维码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.zxing<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.zxing<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javase<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--开发工具集--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.6.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>( 3 )  创建一个配置类，用来配置二维码的长宽或背景色等等属性，然后将二维码的配置方法注入成Bean对象即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QrcConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  将二维码生成器注入为Bean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> QrConfig <span class="title function_">qrConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 设置长和宽，若没有设置则默认300 300</span></span><br><span class="line">        <span class="comment">// QrConfig qrConfig = new QrConfig(300,300);</span></span><br><span class="line">        <span class="type">QrConfig</span> <span class="variable">qrConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QrConfig</span>();</span><br><span class="line">        <span class="comment">// 设置二维码和边框的距离px</span></span><br><span class="line">        qrConfig.setMargin(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 设置背景色</span></span><br><span class="line">        qrConfig.setBackColor(Color.WHITE.getRGB()).setForeColor(Color.BLACK.getRGB());</span><br><span class="line">        <span class="keyword">return</span> qrConfig;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>( 4 ) 生成二维码返回给前端页面和将生成的二维码保存到本地磁盘的业务实现过程如下，以下是业务方法的实现过程，这是在service层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  二维码服务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QrServiceImpl</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> QrConfig qrConfig;</span><br><span class="line">   </span><br><span class="line"><span class="comment">// 保存到本地磁盘上</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveQrToLocalFile</span><span class="params">(String content, String filePath)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isEmpty(content) || StringUtils.isEmpty(filePath)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> FileUtil.file(filePath);</span><br><span class="line">        <span class="comment">// 判断是否是一个目录</span></span><br><span class="line">        <span class="keyword">if</span>(!file.isDirectory()) &#123;</span><br><span class="line">            <span class="comment">// 不是目录，则默认放到桌面上</span></span><br><span class="line">            file = FileSystemView.getFileSystemView().getHomeDirectory();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断该路径是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(!file.exists()) &#123;</span><br><span class="line">            <span class="comment">// 说明不存在</span></span><br><span class="line">            file.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取图片，使用Hutool提供的QrCodeUtil工具类生成</span></span><br><span class="line">        <span class="type">BufferedImage</span> <span class="variable">bufferedImage</span> <span class="operator">=</span> QrCodeUtil.generate(content, qrConfig);</span><br><span class="line">        <span class="comment">// 定义文件名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>) + <span class="string">&quot;.png&quot;</span>;</span><br><span class="line">        <span class="comment">// 创建文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">qrFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(file,fileName);</span><br><span class="line">        <span class="comment">// 输出到磁盘中</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ImageIO.write(bufferedImage,<span class="string">&quot;png&quot;</span>,qrFile);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// 将二维码输出到页面上</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transferToWebpage</span><span class="params">(String content, HttpServletResponse response)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            QrCodeUtil.generate(content,qrConfig,<span class="string">&quot;png&quot;</span>,response.getOutputStream());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>( 5 ) 以下是controller层的代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  二维码前端控制器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/qr&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QrcController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> QrService qrService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/message&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">getQrcode</span><span class="params">(HttpServletResponse response)</span> &#123;</span><br><span class="line">        qrService.transferToWebpage(<span class="string">&quot;https://www.baidu.com&quot;</span>,response);</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PostMapping(&quot;/save&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">save</span><span class="params">(<span class="meta">@RequestBody</span> SaveQrcodeVo qrcodeVo)</span> &#123;</span><br><span class="line">        qrService.saveQrToLocalFile(qrcodeVo.getContent(),qrcodeVo.getFilePath());</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SaveQrcodeVo类是接收来自页面上的请求json参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SaveQrcodeVo</span> &#123;</span><br><span class="line">   <span class="comment">// 二维码的内容</span></span><br><span class="line">    <span class="keyword">private</span> String  content;</span><br><span class="line">   <span class="comment">// 二维码的保存路径</span></span><br><span class="line">    <span class="keyword">private</span> String filePath;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getContent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContent</span><span class="params">(String content)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getFilePath</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> filePath;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFilePath</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.filePath = filePath;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230126211248883.png" alt="image-20230126211248883"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文章中会介绍如何使用Hutool开源工具包进行二维码的生成，在业务需求中也经常看到需要用到二维码，可以用二维码进行手机扫码登入、扫码支付、扫码加好友等等一系列的需求，但人们知道使用二维码，那二维码到底是一个什么样的实现过程呢？更多详情请看下文&lt;/p&gt;
&lt;p&gt;&lt;strong</summary>
      
    
    
    
    
    <category term="java;二维码" scheme="http://example.com/tags/java-%E4%BA%8C%E7%BB%B4%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>java相关知识笔记</title>
    <link href="http://example.com/2023/01/17/java%E9%9D%A2%E8%AF%95%E7%AF%87%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2023/01/17/java%E9%9D%A2%E8%AF%95%E7%AF%87%E7%AC%94%E8%AE%B0/</id>
    <published>2023-01-17T11:20:00.000Z</published>
    <updated>2023-03-02T03:06:13.065Z</updated>
    
    <content type="html"><![CDATA[<h1 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h1><p>概述：最常见的查找算法有两种，一种是顺序查找，另一种是二分查找。</p><p>（ 1 ）顺序查找的特点：适用范围广，可以查找像数组（随机存储）和链表（顺序存储）这两种数据结构并且数据元素可以是无序的，但查询效率低，时间复杂度O(n)</p><p>（ 2 ）二分查找的特点：适用范围相对顺序查找小，只能查找像数组（随机存储）这样的数据结构并且要求数据必须是有序，查询效率高，时间复杂度O(logn)，那么以下代码是这两种算法的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  顺序查找算法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderSearch</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        System.out.println(orderSortMulti(arr,<span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 只要查找到第一个目标元素就返回</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 从该数组中查找目标元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target 目标元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 目标元素所在的下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">orderSort</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">// 顺序遍历查找即可</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 查询不到返回-1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  若目标元素在数组中有多个，例如&#123;5,1,4,5,6,7,2,0&#125; 在这一数组中要找目标为5，那要如何实现呢？</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">orderSortMulti</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(target == arr[i]) &#123;</span><br><span class="line">                result.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  二分查找</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinarySearch</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] array = &#123;<span class="number">1</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>,<span class="number">26</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> binarySearch(array, <span class="number">19</span>,<span class="number">0</span>,array.length);</span><br><span class="line">        System.out.println(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//二分查找实现方法 -- 迭代方式  前提:有已排序数组A（假设已经做好)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">//1. 定义左边界和右边界</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="comment">//2.获取中间索引mid = Floor((L+R)/2)</span></span><br><span class="line">        <span class="type">int</span> mid;</span><br><span class="line">        <span class="comment">//循环</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123; <span class="comment">//4.当left&gt;right时，表示没有找到，应结束循环</span></span><br><span class="line">            mid = left + (right - left) / <span class="number">2</span>; <span class="comment">//解决整数溢出问题</span></span><br><span class="line">            <span class="comment">//5.中间索引的值 A[M]与待搜索的值T进行比较</span></span><br><span class="line">            <span class="keyword">if</span>(arr[mid] &gt; target) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 未找到目标值的下标</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//二分查找方法 -- 递归方式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> target,<span class="type">int</span> left,<span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="comment">//判断是否已经结束</span></span><br><span class="line">        <span class="keyword">if</span>(left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//1. 判断中间值是否大于目标值</span></span><br><span class="line">        <span class="keyword">if</span>(arr[mid] &gt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span> binarySearch(arr,target,left,mid - <span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[mid] &lt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span> binarySearch(arr,target,mid + <span class="number">1</span>,right);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//2. 相等直接返回下标即可</span></span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的代码有一个毛病，就是二分查找若数组中有多个目标数据，例如在{1,2,4,5,6,6,6,6,7,8,9}中查找6这个目标数据所在的下标，那应该如何实现呢？</p><h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="冒泡排序算法"><a href="#冒泡排序算法" class="headerlink" title="冒泡排序算法"></a>冒泡排序算法</h2><p>概述：冒泡排序是比较排序，<strong>以升序为主</strong>，即给定一个无序的数组，每轮排序所有相邻的元素都会进行一个比较，若前一个数与后一个数大则进行数交换位置的操作，每轮比较都最后将最大的那个数排到数组最后一个位置，这就是冒泡排序，以下是冒泡排序的实现代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  冒泡排序算法的实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BubbleSort</span> &#123;</span><br><span class="line">    <span class="comment">// 记录循环的次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">24</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        bubbleSort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="comment">// 因为是每次两个数进行比较，所以总的排序次数是arr.length - 1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">           <span class="comment">// 注意arr.length - 1 - i这里的-i是将冒泡的最后有序部分剔除掉，避免重复无效的排序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="comment">// 说明两个相邻的数，左边的数比右边的大就进行交换操作</span></span><br><span class="line">                    swap(arr,j,j+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                count ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;总的循环次数为：&quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数交换</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 无序数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i 相邻两个数的左边下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j 相邻两个数的右边下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230117195938657.png" alt="image-20230117195938657"></p><p>在以上的冒泡排序算法中还存在一个问题，那就是若本来就有序的数组还是会重复无效的进行比较排序，这样就显得多此一举，故我们可以定义一个标志位进行一个判断，若一个数组已经是处于一个有序状态，则就可以提前结束循环，从而避免无效的排序循环。具体实现如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  冒泡排序算法的实现--优化version1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BubbleSort</span> &#123;</span><br><span class="line">    <span class="comment">// 记录循环的次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        bubbleSort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="comment">// 标志位</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 因为是每次两个数进行比较，所以总的排序次数是arr.length - 1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 改变标志位，说明该轮循环有进行交换操作</span></span><br><span class="line">                  flag = <span class="literal">true</span>;</span><br><span class="line">                   <span class="comment">// 说明两个相邻的数，左边的数比右边的大就进行交换操作</span></span><br><span class="line">                    swap(arr,j,j+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                count ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!flag) &#123;</span><br><span class="line">                <span class="comment">// 在某一轮未进行比较操作，则可以说明该数组已经处于有序状态了</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;总的循环次数为：&quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数交换</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 无序数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i 相邻两个数的左边下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j 相邻两个数的右边下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>冒泡排序总结</strong></p><p>主要核心思想是：依次比较数组中相邻的两个元素，若前面的元素比后面的元素大，则需要进行交换，最后会将最大的数放到数组的最后位置。重复此操作最后数组就会变成有序的。时间复杂度是O(n^2)，空间复杂度是O(n)，并且是稳定排序。</p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p><strong>概述：</strong>在选择排序中数组分为有序部分和无序部分，每轮的排序都会将无序部分中最小的值排到有序部分上，例如，数组[8,2,1,4,5]，会先假定第一个值8为最小值，然后跟8后面的部分（无序部分）进行比较，若发现有比8还小的值（无序部分中最小的值），则将最小的值和8的位置进行交换，第二轮会假定2为最小值，以此类推，最终都会变得有序，以下是具体代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  选择排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">8</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        selectionSort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selectionSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 先假定数组的第一个为最小的值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="comment">// 在遍历寻找minIndex后边的值，是否存在比当前的值还小，若存在，则需要进行交换</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> minIndex + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[minIndex] &gt; arr[j]) &#123;</span><br><span class="line">                    minIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(minIndex != i) &#123;</span><br><span class="line">                <span class="comment">//说明在minIndex后边存在比当前的值还小，进行交换</span></span><br><span class="line">                swap(arr,minIndex,i);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Arrays.toString(arr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 数据元素交换，将i所在位置和j所在位置进行交换</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230117220509754.png" alt="image-20230117220509754"></p><p><strong>选择排序的总结</strong></p><p>选择排序的时间复杂度是O(n^2)，空间复杂度O(n)，是属于不稳定排序算法。</p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>概述：插入排序也分为有序部分和无序部分，有序部分会不断扩大，最终都将变成有序的数组，具体代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsertSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">9</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">        insertSort(arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 插入排序的实现方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="comment">// 首先从无序部分开始遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i]; <span class="comment">// 先暂时保存无序部分的第一个值，为后续的插入做准备</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - <span class="number">1</span>; <span class="comment">//有序部分的最后一个元素的索引</span></span><br><span class="line">            <span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; j--) &#123; <span class="comment">// temp依次比较有序部分的值，找到自己的合适位置</span></span><br><span class="line">                <span class="keyword">if</span>(temp &lt; arr[j]) &#123;</span><br><span class="line">                    <span class="comment">// 说明temp的值与当前的值小，当前的值需要往后移一位</span></span><br><span class="line">                    arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 说明temp值已经找到了合适的位置，结束循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前面的循环出来后，j + 1所在的索引就是temp值所在的位置</span></span><br><span class="line">            arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            System.out.println(Arrays.toString(arr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>插入排序的总结</strong></p><p>插入排序分为有序区域和无序区域，每轮排序都会从无序区域的第一个元素插入到有序区域的合适位置上（在有序部分碰到比temp值小的就可以确定temp的值所插入的位置），需要保证有序区域的有序性，重复以上步骤最终可以得到整体有序的数组。时间复杂度为O(n^2)，是稳定排序。<strong>执行的效率：插入排序 &gt; 选择排序 &gt; 冒泡排序</strong></p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>概述：快速排序是需要选择一个基准点pivot，然后进行每轮的排序，基准点的左边的值都比基准点本身的值小，右边的值都比基准点本身的值大，每次都会进行一个分区比较，每个区中都有一个基准点，最终分区的元素为0时，说明数组已经是基于有序了。这里体现的是分而治之的思想。以下代码是快速排序的实现过程（两种方式）</p><ul><li>单边循环快排</li></ul><p>在单边循环中一般选择数组最右边的元素作为基准点，这里实现的代码有两个指针<strong>i和j</strong>，<strong>i</strong>代表的是维护比基准点值小的左边界和每次交换的目标索引，<strong>j</strong>代表的是寻找比基准点还小的值与<strong>i</strong>所在的位置进行交换，最后<strong>i</strong>会和基准点进行交换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  快速排序--单边</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">5</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        quickSort(arr,<span class="number">0</span>,arr.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> left,<span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right) &#123;</span><br><span class="line">            <span class="comment">// 没有元素可以再进行分区，结束递归分区</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1. 进行一个分区并返回分区后基准点所在的索引位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivotIndex</span> <span class="operator">=</span> portion(arr, left, right);</span><br><span class="line">        <span class="comment">// 2. 根据基准点所在的位置对基准点左边在进行分区</span></span><br><span class="line">        quickSort(arr, left, pivotIndex - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 3. 根据基准点所在的位置对基准点右边进行分区</span></span><br><span class="line">        quickSort(arr, pivotIndex + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 待排序的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left 数组左边的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right 数组右边的所有</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 经过分区后i指针所在的位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">portion</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="comment">// 最右边的元素作为基准点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[right];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="comment">// j指针寻找比pivot小的值所在的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> left; j &lt; right; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &lt; pivot) &#123;</span><br><span class="line">                <span class="comment">// 说明找到了，就与i进行交换</span></span><br><span class="line">                swap(arr,i,j);</span><br><span class="line">                i ++; <span class="comment">// i需要右移一位</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后将i与基准点所在位置进行交换</span></span><br><span class="line">        swap(arr,i,right);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数交换</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 无序数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i 相邻两个数的左边下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j 相邻两个数的右边下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230118150315998.png" alt="image-20230118150315998"></p><ul><li>双边循环快排</li></ul><p>概述：双边循环也称为双指针循环，一般数组的最左边元素是作为基准点，在双指针中假设是i和j，i的职责是从左往右寻找比级基准点大的元素，j的职责是从右往左寻找比基准点小的元素，若ij分别找到各自的元素则进行交换，最后i和j相交时则结束寻找，此时的i就是分区的位置，最后i和基准点需要进行一次交换。</p><p><strong>细节问题</strong>：在i和j指针寻找的顺序，必须先寻找小的值，然后再寻找大的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  快速排序--双边循环</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">5</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">        quickSort(arr,<span class="number">0</span>,arr.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> left,<span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right) &#123;</span><br><span class="line">            <span class="comment">// 没有元素可以再进行分区，结束递归分区</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1. 进行一个分区并返回分区后基准点所在的索引位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivotIndex</span> <span class="operator">=</span> portion(arr, left, right);</span><br><span class="line">        <span class="comment">// 2. 根据基准点所在的位置对基准点左边在进行分区</span></span><br><span class="line">        quickSort(arr, left, pivotIndex - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 3. 根据基准点所在的位置对基准点右边进行分区</span></span><br><span class="line">        quickSort(arr, pivotIndex + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">portion</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> left,<span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="comment">// 选择最左边的作为基准点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[left];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; <span class="comment">// 负责找比基准点大的元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> right;<span class="comment">// 负责找比基准点小的元素</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">           <span class="comment">// 先找小的值</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt; pivot) &#123;</span><br><span class="line">                j --;</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="comment">// 再找大的值</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt;= pivot ) &#123;</span><br><span class="line">                i ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// i 和 j 进行交换</span></span><br><span class="line">            swap(arr,i,j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后i和基准点进行交换</span></span><br><span class="line">        swap(arr,i,left);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数交换</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 无序数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i 相邻两个数的左边下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j 相邻两个数的右边下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>快速排序的总结</strong></p><p>平均时间复杂度O(nlog2n)，最坏的时间复杂度O(n^2)，对于数据量比较大时使用该算法会有比较明显的优势，是不稳定排序</p><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><h2 id="ArrayList的扩容机制"><a href="#ArrayList的扩容机制" class="headerlink" title="ArrayList的扩容机制"></a>ArrayList的扩容机制</h2><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230118160852310.png" alt="image-20230118160852310"></p><h2 id="LinkedList和ArrayList的比对"><a href="#LinkedList和ArrayList的比对" class="headerlink" title="LinkedList和ArrayList的比对"></a>LinkedList和ArrayList的比对</h2><p><strong>LinkedList</strong></p><p>​LinkedList底层是双向链表实现，无需连续内存空间，随机访问慢，头尾插入和删除操作的效率高（因为链表的插入和删除操作不用移动元素），但在插入和删除中间的元素时性能较低（若只考虑插入和删除的操作，则效率高，若考虑定位查找到目标数据或目标位置然后再进行增删操作，则总体的效率低），占用内存大。</p><p><strong>ArrayList</strong></p><p>​ArrayList底层是基于数组实现的，需要连续的内存空间来存储数据，可以通过计算来确定数组的下标，从而确定需要访问的目标数据，故随机访问速度快。在一定长度的数组头部和中间数据进行增删操作效率比LinkedList低，但在尾部进行插入和删除的效率比LinkedList高。可以利用CPU缓存和局部性原理（CPU每次读取数据进行计算时都会读取目标数据的相邻元素一起读到缓存中）。占用内存小</p><h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><p>HashMap的底层数据结构JDK1.7和JDK1.8版本有什么区别？</p><ul><li><strong>在JDK1.7版本中HashMap是采用数组+链表，在JDK1.8是数组 +（链表 | 红黑树）</strong></li></ul><p>如何解决HashMap底层的链表过长问题？</p><ul><li><strong>通过给HashMap的数组扩容，但在某个特殊的情况下并不能有效的解决。</strong></li><li><strong>通过树化链表可以有效解决，前提条件是在HashMap的数组长度达到（&gt;&#x3D;64）才能触发树化效果并且在某个数组下的节点大到8个节点</strong></li></ul><p>为何需要使用红黑树？为什么不是一上来就树化？</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230119150749106.png" alt="image-20230119150749106"></p><p>HashMap的索引计算？</p><ul><li><strong>通过调用hash的方法来计算对象的HashCode，然后再模于数组的长度 - 1，&gt;&gt; 公式：hash值 mod 数组长度 - 1</strong></li></ul><p>为何需要进行二次的hashCode的计算？</p><ul><li><strong>二次hashCode的计算是为了综合高位数据，使得哈希分布更为均匀。</strong></li></ul><p>数组容量为何是2的n次幂？</p><ul><li><strong>因为2的n次幂可以通过位与运算得到取模运算同样的结果，并且位与运算效率更高，扩容时若 hash &amp; 旧容量长度 &#x3D;&#x3D; 0，则元素的位置不变，否则新位置&#x3D;旧位置+旧容量的长度。</strong></li></ul><p>HashMap_put()的流程？</p><ul><li><strong>HashMap是懒惰创建数组的，首次使用才创建数组计算索引（桶下标)</strong></li><li><strong>如果桶下标还没人占用，创建Node占位返回</strong></li><li><strong>如果桶下标已经有人占用</strong><ul><li><strong>已经是TreeNode走红黑树的添加或更新逻辑</strong></li><li><strong>是普通Node，走链表的添加或更新逻辑，如果链表长度超过树化阈值，走树化逻辑</strong></li></ul></li><li><strong>返回前检查容量是否超过阈值，一旦超过进行扩容不同</strong></li></ul><p>HashMap_put()在JDK1.7和JDK1.8的不同？</p><ol><li><strong>链表插入节点时，1.7是头插法，1.8是尾插法。</strong></li><li><strong>1.7是大于阈值（数组长度 * 负载因子(0.75)）且没有空位才进行扩容，1.8是大于阈值就进行扩容。</strong></li><li><strong>1.8比1.7的效率更高。</strong></li></ol><p>加载（负载）因子为何是0.75？</p><ul><li><strong>在空间占用与查询时间之间取得较好的权衡</strong></li><li><strong>大于这个值，空间节省了，但链表就会比较长影响性能</strong></li><li><strong>小于这个值，冲突减少了，但扩容就会更频繁，空间占用多</strong></li></ul><p>多线程下HashMap会出现什么问题（在JDK1.7版本下发生）？</p><ol><li><p><strong>并发丢失数据。</strong></p></li><li><p><strong>由于头插法导致并发下扩容死链问题。</strong></p></li></ol><p>HashMap中的key是否可以为null，作为key的对象有和要求？</p><ol><li><strong>HashMap中的key是可以为null的，但在其它的map集合中是不可以为null的，例如HashTable。</strong></li><li><strong>作为key的对象，必须实现hashCode和equals的方法，并且key对象是不可修改的。</strong></li></ol><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230119203801278.png" alt="image-20230119203801278"></p><h1 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h1><p>以下是单例模式的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> a_based_item1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  饿汉式单例--在该类初始化的时候就创建实例对象，线程是安全的。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 预防反射破坏单例</span></span><br><span class="line">        <span class="keyword">if</span>(INSTANCE != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;单例不可重复创建&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Singleton单例模式初始化。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">otherMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;otherMethod其它方法执行。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>单例被破坏的三最种情况</strong></p><ol><li>反射破坏单例，这是可以预防的，如上代码。</li><li>反序列化破坏单例（可解决）</li><li>unsafe破坏单例（不可解决）</li></ol><p>以下是懒汉式单例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  懒汉式单例--类在加载时不实例化对象，只有等到第一次用的时候才去实例化。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;懒汉式单例初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton2</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 创建实例</span></span><br><span class="line">            INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton2</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在多线程序会破坏单例的证明如下测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  多线程下破坏懒汉式单例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonTest2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建10个线程</span></span><br><span class="line">        creatThreadByNum(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">creatThreadByNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="type">Singleton2</span> <span class="variable">instance</span> <span class="operator">=</span> Singleton2.getInstance();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;&gt;&gt;&quot;</span> + instance);</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.setName(<span class="string">&quot;线程&quot;</span> + (i + <span class="number">1</span>));</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230120144155537.png" alt="image-20230120144155537"></p><p><strong>以下代码是解决多线程下破坏懒汉式单例的方案DCL（Double Check Lock）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  懒汉式单例--DCL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;懒汉式单例初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 需要加volatile，可以解决共享变量的可见性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">Singleton2</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 加锁，防止多线程同时满足条件，同时进行创建实例的代码块</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton2.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton2</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230120144624401.png" alt="image-20230120144624401"></p><h1 id="并发篇"><a href="#并发篇" class="headerlink" title="并发篇"></a>并发篇</h1><h2 id="Java线程的六种状态"><a href="#Java线程的六种状态" class="headerlink" title="Java线程的六种状态"></a>Java线程的六种状态</h2><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230120150100666.png" alt="image-20230120150100666"></p><p><strong>下图是操作系统中的线程状态</strong></p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230121140706806.png" alt="image-20230121140706806"></p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p><strong>java.util.concurrent.ThreadPoolExecutor</strong></p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230121142617613.png" alt="image-20230121142617613"></p><h2 id="Wait-VS-Sleep"><a href="#Wait-VS-Sleep" class="headerlink" title="Wait VS Sleep"></a>Wait VS Sleep</h2><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230121150713734.png" alt="image-20230121150713734"></p><h2 id="Lock-VS-Synchronized"><a href="#Lock-VS-Synchronized" class="headerlink" title="Lock VS Synchronized"></a>Lock VS Synchronized</h2><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230121152148928.png" alt="image-20230121152148928"></p><p><strong>公平锁与非公平锁的区别？</strong></p><p>（ 1 ）公平锁是在阻塞队列中的线程分别以先进先出的形式依次执行线程</p><p>（ 2 ）非公平锁不是以先进先出的形式出现，有可能出现其他线程插队的情况。</p><h2 id="Volatile关键字"><a href="#Volatile关键字" class="headerlink" title="Volatile关键字"></a>Volatile关键字</h2><p><strong>线程安全包括三个方面：可见性、有序性、原子性</strong></p><p>（ 1 ）可见性：是一个线程对某个变量进行修改，其它线程是能看到最新的结果</p><p>（ 2 ）有序性：一个线程中的代码是按照编码顺序执行的</p><p>（ 3 ）原子性：一个线程中的代码是以一个整体运行的，在运行期间不可以有其它线程代码插队</p><p><strong>Volatile关键字可以保证可见性和有序性，不能保证原子性</strong></p><h2 id="乐观锁VS悲观锁"><a href="#乐观锁VS悲观锁" class="headerlink" title="乐观锁VS悲观锁"></a>乐观锁VS悲观锁</h2><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230124144738446.png" alt="image-20230124144738446"></p><h2 id="HashTable-VS-ConcrrentHashMap"><a href="#HashTable-VS-ConcrrentHashMap" class="headerlink" title="HashTable VS ConcrrentHashMap"></a>HashTable VS ConcrrentHashMap</h2><p>（ 1 ）HashTable和ConcrrentHashMap都是线程安全的（相同点）。</p><p>（ 2 ）HashTable由于底层是用同一把锁，则每次只能有一个线程操作，则并发度较低。</p><p>（ 3 ）ConcrrentHashMap在JDK1.8版本之前采用segment+数组+链表，每个segment对应一把锁，多个线程访问时都会获取不同的锁，则不会冲突。</p><p>（ 4 ）在JDK1.8之后ConcrrentHashMap采用头节点作为锁，若多个线程访问不同的头节点，则不会冲突。</p><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>（ 1 ）ThreadLocal是可以实现【资源对象】的线程隔离，让每个线程都用自己的【资源对象】，从而避免线程安全的问题。</p><p>（ 2 ）ThreadLocal可以实现同个线程间资源共享。</p><p>以下代码是证明以上ThreadLocal的特点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> Integer age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  ThreadLocal证明测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalTest</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  ThreadLocal是底层是基于map实现的，是key-value结构</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;User&gt; tl = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        testOne();</span><br><span class="line">        testTwo(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  测试一：【同个线程间】在从ThreadLocal获取资源对象是否相同？</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testOne</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            tl.set(<span class="keyword">new</span> <span class="title class_">User</span>());</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：&quot;</span> + tl.get());</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：&quot;</span> + tl.get());</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：&quot;</span> + tl.get());</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  测试二：【不同线程间】从ThreadLocal获取资源对象是否相同？</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testTwo</span><span class="params">(<span class="type">int</span> threadNum)</span> &#123;</span><br><span class="line">        <span class="comment">// 根据threadNum创建线程数量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadNum; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                tl.set(<span class="keyword">new</span> <span class="title class_">User</span>());</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：&quot;</span> + tl.get());</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230126135721217.png" alt="image-20230126135721217"></p><p><strong>ThreadLocal的原理</strong></p><p>ThreadLocal类中存在成员变量ThreadLocalMap，ThreadLocalMap类似key-value结构，用于存储资源对象</p><p>（ 1 ）当调用set方法是需要存储两个值的，ThreadLocal本身是作为key，资源对象是作为value存储的。</p><p>（ 2 ）当调用get方法是根据ThreadLocal本身去寻找value值。</p><p>（ 3 ）调用remove方法，是以ThreadLocal本身作为key去移除相关的资源值。</p><p><strong>为什么ThreadLocalMap的key（即ThreadLocal）是弱引用？</strong></p><p>（ 1 ）因为ThreadLocal可能会长时间存在线程中，若key不需要再使用，则会在内存不足时将该key释掉。</p><p>（ 2 ）第一步只是让key释放掉，但其value未被释放，还需要进一步的根据key是否为null来释放值的内存，释放的时机有如下</p><table><thead><tr><th align="center">释放的时机</th></tr></thead><tbody><tr><td align="center">获取key时发现为null</td></tr><tr><td align="center">set key时，会使用启发式扫描，清除临近的null key，启发次数与元素个数，是否发现 null key有关</td></tr><tr><td align="center">remove时(推荐)，因为一般使用ThreadLocal时都把它作为静态变量，因此GC（jvm的垃圾回收机制）无法回收</td></tr></tbody></table><h1 id="JVM虚拟机"><a href="#JVM虚拟机" class="headerlink" title="JVM虚拟机"></a>JVM虚拟机</h1><ul><li>程序私有：程序计数器（记录CPU已经执行到哪行代码）、虚拟机栈</li><li>程序共有：堆、方法区</li></ul><p><em><strong>下图是JVM虚拟机执行java程序代码的整体概况</strong></em></p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230126142916151.png" alt="image-20230126142916151"></p><p>不会出现内存溢出的区域：程序计数器</p><p><strong>出现OutOfMemoryError（OOM）的情况</strong></p><ul><li>堆内存耗尽：对象越来越多且一直在使用，无法被垃圾回收</li><li>方法区内存耗尽：加载的类越来越多，很多框架在启动时会动态的加载所需要的类</li><li>虚拟机栈积累：每个线程最多占用1M的内存，线程个数越来越多，而又长时间不销毁</li></ul><p><strong>出现OutOverflowError的情况</strong></p><ul><li>虚拟机栈内部：方法调用次数过多</li></ul><h2 id="JVM中的内存参数"><a href="#JVM中的内存参数" class="headerlink" title="JVM中的内存参数"></a>JVM中的内存参数</h2><p>对于JVM内存参数有：-Xmx10240m、-Xms10240m、-Xmn5120m、-XX:SurvivoRatio&#x3D;3、其最小内存值和Survivo区总大小分别是？</p><ul><li>-Xmx10240m是代表最大内存10G，-Xms10240m是代表最小内存10G</li><li>-Xmn5120m代表新生代的内存是5G，那么老年代是占用5G</li><li>-XX:SurvivoRatio&#x3D;3代表在新生代内存的比例</li></ul><h2 id="JVM中的垃圾回收算法"><a href="#JVM中的垃圾回收算法" class="headerlink" title="JVM中的垃圾回收算法"></a>JVM中的垃圾回收算法</h2><p><strong>标记清理、标记整理、标记复制这三种垃圾回收算法</strong></p><p>下图是标记清理，清理未标记的类对象，该垃圾回收算法是有缺点的，在白色区域是代表已清理的类对象所遗留下的内存空间，有些内存空间被可用的类对象所隔离开来，就产生了内存碎片。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230126201031183.png" alt="image-20230126201031183"></p><p><strong>标记整理</strong>是为了解决标记清理算法缺点，每次清理完成后都会对可用的类对象进行一个整理，这样就避免了产生内存碎片，但多了一步整理的操作，故效率就会降低。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230126201517144.png" alt="image-20230126201517144"></p><p><strong>标记复制</strong>是需要两个存储空间A和B，假如A需要进行对象清理操作，就可以把在A区域标记的对象复制到B的空闲区域中，然后将A区域的所有空间都清理掉即可，缺点是需要额外的空间。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230126201758602.png" alt="image-20230126201758602"></p><h2 id="GC和分代回收算法"><a href="#GC和分代回收算法" class="headerlink" title="GC和分代回收算法"></a>GC和分代回收算法</h2><p>GC存在的目标是无用对象自动释放、减少内存碎片、加快分配速度。以下是GC的要点</p><p>（ 1 ）回收区域是堆内存，不包括虚拟机栈，在方法调用结束会自动释放方法</p><p>（ 2 ）占用内存判断无用对象，使用<strong>可达性分析算法</strong>，<strong>三色标记法</strong>标记存活对象，回收未标记对象</p><p>（ 3 ）GC具体的实现称为<strong>垃圾回收器</strong></p><p>（ 4 ）GC大都采用了分代回收思想，理论依据是大部分对象朝生夕灭，用完立刻就可以回收，另有少部分对象会长时间存活，每次很难回收，根据这两类对象的特性将回收区域分为新生代和老年代，不同区域应用不同的回收策略</p><p>（ 5 ）根据GC的规模可以分成 Minor GC，Mixed GC,Full Gc</p><h2 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h2><p><strong>伊甸园(eden)：</strong>最初的对象分配在此区域，与幸存区合成称为新生代。</p><p><strong>幸存区(survivor)：</strong>当伊甸园的内存不足时，触发垃圾回收后的幸存对象分配到此区域，分为from和to区域，采用标记复制法</p><p><strong>老年代(old)：</strong>但幸存区对象熬过几次的垃圾回收（最多15次）后就会晋升为老年代</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230127135449616.png" alt="image-20230127135449616"></p><p><strong>GC的规模</strong></p><p>​Minor GC发生在新生代的垃圾回收，暂停时间短</p><p>​Mixed GC新生代＋老年代部分区域的垃圾回收，G1收集器特有</p><p>​Full GC新生代＋老年代完整垃圾回收，暂停时间长，应尽力避免</p><p><strong>三色标记</strong></p><ol><li>黑色：已标记</li><li>灰色：标记中</li><li>白色：还未标记</li></ol><h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><p>介绍三种垃圾回收器的特点？</p><p><strong>Parallel GC(并行垃圾回收器)</strong></p><p>（ 1 ）eden内存不足发生Minor GC，标记复制STW</p><p>（ 2 ）old内存不足发生Full GC，标记整理STW</p><p>（ 3 ）注重吞吐量</p><p><strong>ConcurrentMarkSweep GC(并发垃圾回收器)</strong></p><p>（ 1 ）old并发标记，重新标记时需要STW，并发清除</p><p>（ 2 ）Failback Full GC（当总内存不足时会触发回退机制）</p><p>（ 3 ）注重响应时间</p><p><strong>G1 GC</strong></p><p>（ 1 ）响应时间与吞吐量兼顾</p><p>（ 2 ）划分成多个区域，每个区域都可以充当eden,survivor, old,humongous</p><p>（ 3 ）新生代回收：eden内存不足，标记复制STW(Stop The Word 是GC事件发生过程中，会产生应用程序的停顿)</p><p>（ 4 ）并发标记：old并发标记，重新标记时需要STW</p><p>（ 5 ）混合收集：并发标记完成，开始混合收集，参与复制的有eden、survivor、old，其中old会根据暂停时间目标，选择部分回收价值高的区域，复制时STW</p><p>（ 6 ）Failback ull GC(回退)</p><h2 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h2><p>概述：大部分的内存溢出是出现在误用了错误的线程池而出现的OutOfMemoryError保错，那么以下是误用线程池的例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  内存溢出测试</span></span><br><span class="line"><span class="comment"> *  -Xmx64m</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OutOfMemoryTest</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个线程池，初始化线程数2</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        generousCreateThread();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  测试线程数创建过多而导致的内存溢出问题</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">generousCreateThread</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 死循环</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            threadPool.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">30</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">                count ++;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230127145448373.png" alt="image-20230127145448373"></p><p><strong>线程创建过多：</strong>造成以上错误的原因是使用了 Executors.newFixedThreadPool()创建线程池，而这种方式创建最大的线程数是Integer.MAX_VALUE的最大值，但线程数超过了最大值必然会出现内存溢出的错误，那么如何解决这种错误呢？根据alibaba的开发手册，在开发中尽量不使用Executors.newFixedThreadPool()创建线程池，一般使用ThreadPoolExecutor创建，自己定义线程池的配置参数。在此文章的并发篇有说到ThreadPoolExecutor创建线程池的配置参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  使用ThreadPoolExecutor创建线程池，看是否会出现内存溢出错误？</span></span><br><span class="line"><span class="comment"> *  -Xmx64m</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OutOfMemoryTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化容量为5的堵塞队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ArrayBlockingQueue&lt;Runnable&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">2</span>,<span class="number">4</span>,<span class="number">0</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">            queue);</span><br><span class="line">    <span class="comment">// 记录线程的名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; records = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        generousCreateThread();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  测试线程数创建过多而导致的内存溢出问题</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">generousCreateThread</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 死循环</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                threadPool.submit(() -&gt; &#123;</span><br><span class="line">                    records.add(Thread.currentThread().getName());</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String name: records) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程名称：&quot;</span> + name);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;提交线程任务的次数：&quot;</span> +  records.size() );</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230127151428616.png" alt="image-20230127151428616"></p><p><strong>每次从数据库查询的数据量过多也会导致内存溢出问题，所以说在查询数据库时需要加上limit条件，避免数据查询过多</strong></p><p><strong>加载的类太多也会导致内存溢出，溢出的是元空间的区域</strong></p><h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><p><strong>加载阶段</strong></p><ol><li>将类的字节码载入方法区，并创建类.class对象</li><li>如果此类的父类还未加载，则先加载父类</li><li>加载是懒惰执行方式（真正用到此类才进行初始化）</li></ol><p><strong>链接阶段</strong></p><ol><li>验证：验证加载的Class对象是否规范、合法性和安全检查</li><li>准备：为static变量分配空间和设置默认值</li><li>解析：将常量池的符号引用解析为直接引用</li></ol><p><strong>初始化</strong></p><ol><li>执行静态代码块和非final的变量赋值</li><li>初始化为懒惰执行</li></ol><h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><p>双亲委派：类加载是优先委派上级类加载器加载，存在以下两种情况</p><ul><li>若在上级加载器中能找到目标类，则由上级类加载器加载，加载的类对下级类加载器可见。</li><li>若上级加载器未找到目标类，则下级加载器才有资格执行加载。</li></ul><h2 id="对象的引用类型有几种"><a href="#对象的引用类型有几种" class="headerlink" title="对象的引用类型有几种"></a>对象的引用类型有几种</h2><p><strong>强引用</strong></p><ol><li><p>普通变量赋值即为强引用，例如：A a &#x3D; new A();</p></li><li><p>通过GC root 引用链的强引用用不到该对象，则会被垃圾回收，若该对象还再被使用，则不能被回收</p></li></ol><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230128142606197.png" alt="image-20230128142606197"></p><p><strong>软引用</strong></p><ol><li>例如：SoftReference s &#x3D; new SoftReference (new A());</li><li>如果仅有软引用该对象时，首次垃圾回收不会回收该对象，当内存不足时垃圾回收会将该对象回收</li><li>在垃圾回收时需要配合引用队列来释放</li><li>典型例子是反射数据</li></ol><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230128142908493.png" alt="image-20230128142908493"></p><p><strong>弱引用</strong></p><ol><li>例如：WeakReference w &#x3D; new WeakReference (new A());</li><li>只要发生垃圾回收，就会将弱引用的对象回收</li><li>在垃圾回收时需要配合引用队列来释放</li><li>典型例子是ThreadLocalMap中的Entry对象</li></ol><p><strong>虚引用</strong></p><ol><li><p>例如：PhantomReference p &#x3D;  new PhantomReference (new A());</p></li><li><p>必须配合引用队列一起使用，当虚引用引用的对象被回收时，会将虚引用对象入队，由Reference Handler线程释放其关联的外部资源</p></li></ol><h2 id="ThreadLocalMap的弱引用"><a href="#ThreadLocalMap的弱引用" class="headerlink" title="ThreadLocalMap的弱引用"></a>ThreadLocalMap的弱引用</h2><p>在文章的并发篇有写到ThreadLocal的特点，在日常开发中也经常用到ThreadLocal来存储用户的信息并且保证了每个线程中都有自己所属的用户信息，保证了线程安全，但ThreadLocal的ThreadLocalMap中的Entry是弱引用，一旦发生垃圾回收就会将其的key给回收掉，而值value并未被回收，这样就造成了内存泄露，以前是主动调用ThreadLocal类提供的remove方法删除掉value数据来解决，那么以下例子是从另一种方法解决的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  ThreadLocalMap，使用引用队列解决内存泄露问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalMapTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">MyWeakReference</span> <span class="variable">wr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyWeakReference</span>();</span><br><span class="line">        <span class="comment">// 存键值new String是引用</span></span><br><span class="line">        wr.put(<span class="number">0</span>,<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>),<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="comment">// 第二个的数据是强引用</span></span><br><span class="line">        wr.put(<span class="number">1</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        wr.put(<span class="number">2</span>,<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;c&quot;</span>),<span class="string">&quot;hi~~&quot;</span>);</span><br><span class="line">        wr.put(<span class="number">3</span>,<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;d&quot;</span>),<span class="string">&quot;hehehe&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;还未进行垃圾回收的结果：&quot;</span> + wr);</span><br><span class="line">        <span class="comment">// 启用垃圾回收机制</span></span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;垃圾回收后的结果：&quot;</span> + wr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用clean方法将值处理掉</span></span><br><span class="line">        wr.clean();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;清除key为null数据后的结果：&quot;</span> + wr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyWeakReference</span> &#123;</span><br><span class="line">        <span class="comment">// 创建引用队列，当若引用被回收是，会放到引用队列中</span></span><br><span class="line">        <span class="keyword">static</span> ReferenceQueue&lt;Object&gt; queue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 创建一个Entry继承弱引用</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;String&gt; &#123;</span><br><span class="line">            String value;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="title function_">Entry</span><span class="params">(String key,String value)</span> &#123;</span><br><span class="line">               <span class="built_in">super</span>(key,queue);</span><br><span class="line">               <span class="built_in">this</span>.value = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 定义一个数组长度为4</span></span><br><span class="line">        Entry[] table = <span class="keyword">new</span> <span class="title class_">Entry</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  该方法的作用是在垃圾回收时，将回收的key对应的value清除掉</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clean</span><span class="params">()</span> &#123;</span><br><span class="line">            Object temp;</span><br><span class="line">            <span class="keyword">while</span> ((temp = queue.poll()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 说明有弱引用的对象被回收，则从该队列中取出对象置为null即可</span></span><br><span class="line">               <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; table.length; i++) &#123;</span><br><span class="line">                   <span class="keyword">if</span>(table[i] == temp) &#123;</span><br><span class="line">                       <span class="comment">// 说明两个是同个对象，且key已经被回收了</span></span><br><span class="line">                       table[i] = <span class="literal">null</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 编写存入数据的方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> index,String key,String value)</span> &#123;</span><br><span class="line">            table[index] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key,value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Entry entry : table) &#123;</span><br><span class="line">                <span class="keyword">if</span> (entry != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">k</span> <span class="operator">=</span> entry.get();</span><br><span class="line">                    <span class="keyword">if</span> (k != <span class="literal">null</span> &amp;&amp; k.equals(key)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> entry.value;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            str.append(<span class="string">&quot;[  &quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (Entry e: table) &#123;</span><br><span class="line">                <span class="keyword">if</span>(e != <span class="literal">null</span>) &#123;</span><br><span class="line">                    str.append(<span class="string">&quot;key:&quot;</span>).append(e.get()).append(<span class="string">&quot; value:&quot;</span>).append(e.value).append(<span class="string">&quot; | &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            str.deleteCharAt(str.lastIndexOf(<span class="string">&quot;|&quot;</span>));</span><br><span class="line">            str.append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> str.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230128160434391.png" alt="image-20230128160434391"></p><h1 id="框架篇"><a href="#框架篇" class="headerlink" title="框架篇"></a>框架篇</h1><h2 id="Refresh的工作流程"><a href="#Refresh的工作流程" class="headerlink" title="Refresh的工作流程"></a>Refresh的工作流程</h2><p>概述：本篇文章是针对spring的加载过程的核心方法refresh各个功能进行梳理，refresh方法是初始化ioc容器的核心方法，<strong>Spring</strong>容器创建之后，会调用它的refresh<strong>方法刷新</strong>Spring应用的上下文。</p><p><strong>Refresh方法下的其它12个方法的名称如下</strong></p><ol><li><p>prepareRefresh（刷新前的准备工作）</p></li><li><p>prepareBeanFactory（Bean工厂的准备）</p></li><li><p>obtainFreshBeanFactory（获得新Bean工厂）</p></li><li><p>postProcessBeanFactory（处理后的Bean工厂）</p></li><li><p>invokeBeanFactoryPostProcessors（执行BeanFactory后置处理器）</p></li><li><p>registerBeanPostProcessors（注册bean后置处理器）</p></li><li><p>initMessageSource（初始化信息资源、国际化）</p></li><li><p>initApplicationEventMulticaster（初始化app事件发布器）</p></li><li><p>onRefresh（空方法，留给子类扩展，在容器刷新时重写可以进行一些操作）</p></li><li><p>registerListeners（注册监听器，接收来自app事件发布器发布的事件）</p></li><li><p>finishBeanFactoryInitialization（完成bean工厂的初始化）</p></li><li><p>finishRefresh（完成bean创建和初始化过程，通知生命周期处理器 lifecycleProcessor 刷新过程，同时发出 ContextRefreshEvent 通知。）</p></li></ol><h3 id="prepareRefresh"><a href="#prepareRefresh" class="headerlink" title="prepareRefresh"></a>prepareRefresh</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">prepareRefresh</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//记录时间</span></span><br><span class="line">    <span class="built_in">this</span>.startupDate = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">//设置当前容器未关闭</span></span><br><span class="line">    <span class="built_in">this</span>.closed.set(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//设置当前容器已激活</span></span><br><span class="line">    <span class="built_in">this</span>.active.set(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.logger.isInfoEnabled()) &#123;</span><br><span class="line">    <span class="comment">//打印容器刷新日志</span></span><br><span class="line">        <span class="built_in">this</span>.logger.info(<span class="string">&quot;Refreshing &quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//初始化一下属性(该方法默认是空的,是提供给子类来实现的,</span></span><br><span class="line"><span class="comment">//假设我们有些工作需要在初始化bean以前就要加载设置等,可以通过重写这个方法来完成)</span></span><br><span class="line">    <span class="built_in">this</span>.initPropertySources();</span><br><span class="line">    <span class="comment">//校验设置的属性是否合法</span></span><br><span class="line">    <span class="built_in">this</span>.getEnvironment().validateRequiredProperties();</span><br><span class="line">    <span class="comment">//初始化一个集合属性,提供用来保存后面创建的事件,如果有事件发生会放入这个集合中</span></span><br><span class="line">    <span class="built_in">this</span>.earlyApplicationEvents = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="obtainFreshBeanFactory（获取Bean工厂）"><a href="#obtainFreshBeanFactory（获取Bean工厂）" class="headerlink" title="obtainFreshBeanFactory（获取Bean工厂）"></a>obtainFreshBeanFactory（获取Bean工厂）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title function_">obtainFreshBeanFactory</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//刷新bean工厂,创建一个 DefaultListableBeanFactory类型的 bean工厂</span></span><br><span class="line"><span class="comment">//赋值给 beanFactory 属性,对创建的这个 beanFactory 设置一个序列号</span></span><br><span class="line">        <span class="built_in">this</span>.refreshBeanFactory();</span><br><span class="line">        <span class="comment">//获取beanFactory,就上将上一步设置好序列号的的beanFactory返回回来</span></span><br><span class="line">        <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="built_in">this</span>.getBeanFactory();</span><br><span class="line">        <span class="comment">//打印日志</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.logger.debug(<span class="string">&quot;Bean factory for &quot;</span> + <span class="built_in">this</span>.getDisplayName() + <span class="string">&quot;: &quot;</span> + beanFactory);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//将创建好的 beanFactory 返回</span></span><br><span class="line">        <span class="keyword">return</span> beanFactory;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ol><li>BeanFactory是负责将Bean创建、依赖注入和初始化工作</li><li>BeanDefinition是Bean的设计蓝图，其规定了Bean的单例多例、依赖关系和创建销毁</li><li>BeanDefinition所获取的Bean来源有xml、配置类、组件扫描等等</li></ol><h3 id="prepareBeanFactory（Bean工厂的准备）"><a href="#prepareBeanFactory（Bean工厂的准备）" class="headerlink" title="prepareBeanFactory（Bean工厂的准备）"></a>prepareBeanFactory（Bean工厂的准备）</h3><p>因为上一步获取Bean工厂是空的工厂，还未进行设置，那么这一步是为了上一步获取的工厂进行预处理设置，由于源码很多，以下的代码是简化的代码，整体思路是跟源码一样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">   <span class="comment">// 设置类加载器</span></span><br><span class="line">    beanFactory.setBeanClassLoader(<span class="built_in">this</span>.getClassLoader());</span><br><span class="line">   <span class="comment">// 设置语言解析器，例如解析#、&amp;等</span></span><br><span class="line">    beanFactory.setBeanExpressionResolver(<span class="keyword">new</span> <span class="title class_">StandardBeanExpressionResolver</span>(beanFactory.getBeanClassLoader()));</span><br><span class="line">    beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> <span class="title class_">ResourceEditorRegistrar</span>(<span class="built_in">this</span>, <span class="built_in">this</span>.getEnvironment()));</span><br><span class="line">   <span class="comment">// 添加Bean的后置处理器 </span></span><br><span class="line">   beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">ApplicationContextAwareProcessor</span>(<span class="built_in">this</span>));</span><br><span class="line">   <span class="comment">// 忽略自动装配的接口，就是在实现这些接口中不能自动注入</span></span><br><span class="line">    beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class="line">   <span class="comment">//注册解析依赖，可以自动解析</span></span><br><span class="line">    beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line">    beanFactory.registerResolvableDependency(ResourceLoader.class, <span class="built_in">this</span>);</span><br><span class="line">   <span class="comment">// 添加一个ApplicationListenerDetector后置处理器</span></span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">ApplicationListenerDetector</span>(<span class="built_in">this</span>));</span><br><span class="line">   <span class="comment">// 根据beanFactory中是否符合以下名称的Bean，根据是否存在进行注册或者添加</span></span><br><span class="line">    <span class="keyword">if</span> (beanFactory.containsBean(<span class="string">&quot;loadTimeWeaver&quot;</span>)) &#123;</span><br><span class="line">        beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">LoadTimeWeaverAwareProcessor</span>(beanFactory));</span><br><span class="line">        beanFactory.setTempClassLoader(<span class="keyword">new</span> <span class="title class_">ContextTypeMatchClassLoader</span>(beanFactory.getBeanClassLoader()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.containsLocalBean(<span class="string">&quot;environment&quot;</span>)) &#123;</span><br><span class="line">        beanFactory.registerSingleton(<span class="string">&quot;environment&quot;</span>, <span class="built_in">this</span>.getEnvironment());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="postProcessBeanFactory（处理后的Bean工厂）"><a href="#postProcessBeanFactory（处理后的Bean工厂）" class="headerlink" title="postProcessBeanFactory（处理后的Bean工厂）"></a>postProcessBeanFactory（处理后的Bean工厂）</h3><p>这步是空方法，留给子类进行实现的<strong>（体现了设计模式的模板方法）</strong>，是作为BeanFactory的扩展点，以上的步骤可以看成是BeanFactory的创建及预准备阶段。</p><h3 id="invokeBeanFactoryPostProcessors（执行BeanFactory后置处理器）"><a href="#invokeBeanFactoryPostProcessors（执行BeanFactory后置处理器）" class="headerlink" title="invokeBeanFactoryPostProcessors（执行BeanFactory后置处理器）"></a>invokeBeanFactoryPostProcessors（执行BeanFactory后置处理器）</h3><p>在原始的BeanFactory中的功能并不是很多，很多的功能都要靠此方法进行一个扩展，像@Configuration、@Bean 等注解是无法解析的，那需要调用此方法进行一个扩展，执行ConfigurationClassPostProcessor即可解析像@Configuration、@Bean、@lmport、@PropertySource的注解进行解析。</p><h3 id="registerBeanPostProcessors（注册bean后置处理器）"><a href="#registerBeanPostProcessors（注册bean后置处理器）" class="headerlink" title="registerBeanPostProcessors（注册bean后置处理器）"></a>registerBeanPostProcessors（注册bean后置处理器）</h3><p>registerBeanPostProcessors是往BeanFactory中注册后置处理器，例如往BeanFactory中注册一下的后置处理器可以解析对应的注解。</p><ul><li><p>AutowiredAnnotationBeanPostProcessor功能有：解析@Autowired，@Value注解</p></li><li><p>CommonAnnotationBeanPostProcessor功能有：解析@Resource，@PostConstruct，@preDestroy</p></li><li><p>AnnotationAwareAspectJAutoProxyCreator功能有：为符合切点的目标bean自动创建代理</p></li></ul><h2 id="Spring-Bean的生命周期"><a href="#Spring-Bean的生命周期" class="headerlink" title="Spring Bean的生命周期"></a>Spring Bean的生命周期</h2><p><strong>阶段1：处理别名，检查缓存</strong></p><ul><li>先把Bean的别名解析实际的名称</li><li>若要BeanFactory本身需要加&amp;符号进行获取</li><li>singletonObjects（一级缓存）：放单例成品对象</li><li>earlySingletonObjects（二级缓存）：放单例工厂的产品</li><li>singletonFactories（三级缓存）：放单例工厂</li></ul><p><strong>阶段2：处理父子容器</strong></p><ul><li>父子容器中的bean名称可以一样</li><li>优先从子容器中找找bean，找到了直接返回，找不到再继续从父容器找</li></ul><p><strong>阶段3：dependOn</strong></p><ul><li>dependOn可以控制Bean的创建次顺</li></ul><p><strong>阶段4：按照scope创建</strong></p><ul><li>singleton Scope从单例池中获取bean对象，若没有，则新创建bean对象放到单例池中</li><li>prototype Scope表示从不缓存bean对象，每次都创建新的bean</li></ul><p><strong>阶段5-1：创建bean（创建阶段）</strong></p><p>AutowiredAnnotationBeanPostProcessor选择构造</p><ul><li>优先选择带@Autowired注解的构造</li><li>若有唯一的带参构造，也会入选</li></ul><p>采用默认构造</p><ul><li>若上面未找到符合条件的，则会采用默认构造器，即使是私有的构造方法也会进行暴力反射进行构造</li></ul><p><strong>阶段5-2：依赖注入</strong></p><ul><li>注解匹配注入：会根据@Autowired、@Value和@Resource进行注入</li><li>根据bean名字和成员方法名称（就是setXxx后面的Xxx进行匹配）进行注入</li><li>根据bean类型进行注入</li></ul><p><strong>阶段5-3：初始化</strong></p><p><strong>阶段5-4：注册可销毁的bean</strong></p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230129165105425.png" alt="image-20230129165105425"></p><p><strong>阶段6：类型转换</strong></p><ul><li>bean会根据实际类型进行转换</li></ul><p><strong>阶段7：销毁Bean</strong></p><h2 id="Spring事务失效场景"><a href="#Spring事务失效场景" class="headerlink" title="Spring事务失效场景"></a>Spring事务失效场景</h2><p><strong>场景一：</strong>抛出检查异常，导致事务不能回滚</p><ul><li>原因：spring的事务默认回滚非检查异常</li><li>解决：配置@Transactional注解的属性rollbackFor</li></ul><p><strong>场景二：</strong>在业务方法内部使用try-catch处理掉异常</p><ul><li>原因：事务通知只有捉到目标所抛出的异常，才会进行回滚，但你使用try-catch处理异常且并未抛出异常，那么事务通知无法悉知</li><li>解决1：当捕捉到异常时再抛出原异常。</li><li>解决2：在catch代码块中手动设置TransactionStatus.setRollbackOnly();</li></ul><p><strong>场景三：</strong>aop切面顺序导致事务不能正确回滚</p><ul><li>原因：事务切面优先级最低，但如果自定义的切面方法优先级高于事务切面且在此切面中有异常产生而并未抛出导致的</li><li>解决：同场景二的解决方一样，在自定义切面方法中将异常原样抛出</li></ul><p><strong>场景四：</strong>在加上注解@Transactional的方法不是public修饰的</p><ul><li><p>原因：spring创建事务代理、添加事务通知的前提条件方法是public</p></li><li><p>解决：将方法改为public修饰的</p></li></ul><p><strong>场景五：</strong>父子容器导致的事务失效</p><ul><li>原因：子容器的组件扫描范围过大，导致未加事务配置的service被扫描进来</li><li>解决：将所有的bean放在同一个容器中</li></ul><p><strong>场景六：</strong>调用本类的方法导致的事务失效</p><ul><li>原因：本类方法调用不经过代理，因此spring框架无法完成事务增强操作</li><li>解决1：通过@Autowird注入本类的代理对象，通过代理对象调用本类的方法</li><li>解决2：使用AopContext.currentProxy拿到本类的代理对象进行调用</li></ul><p><strong>场景七：</strong>@Transactional注解不能保证业务操作的原子性</p><ul><li>原因：事务的原子性仅涵盖insert update delete select … for update这种的SQL语句中</li></ul><p><strong>场景八：</strong>在并发情况下@Transactional会导致的Synchronized锁失效</p><ul><li>原因：若Synchronized仅能保证目标方法的原子性，加上@Transactional的方法会经过代理增强进行事务的控制，而代理方法并未在Syn范围内。</li><li>解决1：Synchronized锁范围应扩大到代理方法调用</li><li>解决2：使用insert update delete select … for update语句进行数据库CRUD操作</li></ul><h2 id="Spring-MVC的执行流程"><a href="#Spring-MVC的执行流程" class="headerlink" title="Spring MVC的执行流程"></a>Spring MVC的执行流程</h2><p><strong>初始化阶段</strong></p><ol><li>当Web容器第一次用的DispatcherServlet会创建其对象并调用init方法</li><li>init方法内部会创建Spring Web容器，并调用容器的refresh方法</li><li>refresh方法会初始化Spring Mvc的重要组件，例如：HandlerMapping、MultipartResolver、HandlerAdapter等</li><li>容器初始化成功后会将上一步初始化好的重要组件赋值给DispatcherServlet的成员变量，以待后用</li></ol><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230201100033499.png" alt="image-20230201100033499"></p><p><strong>匹配阶段</strong></p><ol><li><p>用户发送的请求统一到达前端控制器 DispatcherServlet</p></li><li><p>DispatcherServlet遍历所有HandlerMapping，找到与路径匹配的处理器</p></li><li><p>将HandlerMethod 连同匹配到的拦截器，生成调用链对象HandlerExecutionChain返回</p></li><li><p>遍历HandlerAdapter 处理器适配器，找到能处理HandlerMethod的适配器对象，开始调用</p></li></ol><p> <strong>执行阶段</strong></p><ol><li>执行拦截器preHandle</li><li>由HandlerAdapter 调用HandlerMethod</li><li>若没有异常，则返回ModeAndView对象，执行拦截器的preHandle方法，解析视图得到view对象，进行视图渲染</li><li>若有异常，进入HandlerExceptionResolve异常处理逻辑</li><li>最后执行拦截器afterCompletion方法</li><li>如果控制器方法标注了@ResponseBody，则在第二步生成json对象，不会进行视图渲染</li></ol><p><strong>整体流程如下</strong></p><ol><li>用户点击某个请求路径，发起一个 HTTP request 请求，该请求会被提交到 DispatcherServlet（前端控制器）；</li><li>由 DispatcherServlet 请求一个或多个 HandlerMapping（处理器映射器），并返回一个执行链（HandlerExecutionChain）。</li><li>DispatcherServlet 将执行链返回的 Handler 信息发送给 HandlerAdapter（处理器适配器）；</li><li>HandlerAdapter 根据 Handler 信息找到并执行相应的 Handler（常称为 Controller）；</li><li>Handler 执行完毕后会返回给 HandlerAdapter 一个 ModelAndView 对象（Spring MVC的底层对象，包括 Model 数据模型和 View 视图信息）；</li><li>HandlerAdapter 接收到 ModelAndView 对象后，将其返回给 DispatcherServlet ；</li><li>DispatcherServlet 接收到 ModelAndView 对象后，会请求 ViewResolver（视图解析器）对视图进行解析；</li><li>ViewResolver 根据 View 信息匹配到相应的视图结果，并返回给 DispatcherServlet；</li><li>DispatcherServlet 接收到具体的 View 视图后，进行视图渲染，将 Model 中的模型数据填充到 View 视图中的 request 域，生成最终的 View（视图）；</li><li>视图负责将结果显示到浏览器（客户端）。</li></ol><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/1139441444-0.png" alt="Spring MVC执行流程"></p><h2 id="SpringBoot的自动装配"><a href="#SpringBoot的自动装配" class="headerlink" title="SpringBoot的自动装配"></a>SpringBoot的自动装配</h2><p>自动装配是由核心注解是@SpringBootApplication，而@SpringBootApplication<strong>主要</strong>是由@SpringBootConfiguration、@ComponentScan、@EnableAutoConfiguration这三个注解组成的，下面就依次介绍这三个注解的作用。</p><p><strong>@SpringBootConfiguration：</strong>该注解内部包含@Configuration，可以作为配置类，同时也标记着SpringBoot的启动入口。</p><p><strong>@ComponentScan：</strong>是用于扫描子包下的或者指定包下的组件，类上有加@Component、@Service、@Mapper等注解都会被其扫描到并加载成Bean。</p><p><strong>@EnableAutoConfiguration：</strong>有以下两个注解组成</p><ul><li>@AutoConfigurationPackage：用来记住扫描的起始包</li><li>@lmport(AutoConfigurationImportSelector.class)：用来加载META-INF&#x2F;spring.factories中的自动配置类</li></ul><h2 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h2><p>概述：Bean的循环依赖有三个发生场景，分别是自己依赖注入自己的Bean实例、两个类互相依赖对方的Bean对象、三个类依赖对方的Bean对象，下图是对以上叙述的场景图</p><p><strong>BeanA和BeanB的相互依赖图如下</strong></p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230204130449677.png" alt="image-20230204130449677"></p><p><strong>自己依赖自己</strong></p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230204131401160.png" alt="image-20230204131401160"></p><p><strong>三个类依赖对方的Bean对象</strong></p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230204132206960.png" alt="image-20230204132206960"></p><p>那么如何解决以上所展示的问题呢？在Spring中使用三级缓存来解决循环依赖的问题，以下是三级缓存的详情介绍。</p><p><em><strong>一级缓存的作用：限制每个Bean实例在BeanFactory中只存在一份（单例）</strong></em></p><p>​下图是一级缓存的原理图：singletonObjects是一级缓存池，getBean的流程是第一次在singletonObjects池中获取目标Bean，获取不到目标Bean则表示池中还未存在该Bean，需要建立目标Bean存入singletonObjects池中，当第二次从singletonObjects池中获取时就会存在目标Bean，就直接返回即可，这样就避免了重复创建相同的Bean了。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230204132758724.png" alt="image-20230204132758724"></p><p><strong>一级缓存不能解决循环依赖问题，下图可以证明这一点</strong></p><p>​A和B相互依赖时，但A第一次从缓存池中获取自身Bean时，由于第一次缓存中未存在A的Bean所以需要创建A的Bean放入缓存池中，当走到a.setB(?)时，需要调用B的getBean()方法，B也是从缓存池中第一次获取自己的Bean，也获取不到需要创建B的Bean放入到缓存池中，当走到b.setA(?)时又调用了A的getBean()方法，由于创建的A还未放入到缓存池中这样就会导致一直重复以上操作，1红线的箭头和2红线箭头就是一个死循环。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230204133755849.png" alt="image-20230204133755849"></p><p><em><strong>二级缓存（在Spring中是三级缓存）作用：解决两个类相互依赖问题</strong></em></p><p>​三级缓存执行流程：其中singtonFactories是三级级缓存池，A先从singletonObjects池中获取目标Bean，第一次获取不到目标则需要创建A的Bean先放入到三级级缓存池（singtonFactories）中，执行到a.setB(?)时进行B的getBean操作，首先将B的Bean放入singtonFactories池中，当Bean的执行到b.setA(?)时是从三级缓存池（singtonFactories）中获取到a，然后就可以执行b的初始化和singletons.put(b)放入一级缓存池中，最后在执行A的a.setB(?)操作也是先从singtonFactories池中获取到b，将b赋值给A就可以执行a.init和singletons.put(a)的操作了。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230204135810407.png" alt="image-20230204135810407"></p><p><strong>二级缓存不能解决循环依赖中有代理的情况</strong></p><p>​执行流程和上面的一样，唯一不同的是b.setA(?)操作是从singtonFactories中获取的原始对象复值给B的，而我们是需要使用代理对象来进行操作的，这样就造成了两个类相互依赖其中的一方会拿不到目标代理对象。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230204141057848.png" alt="image-20230204141057848"></p><p><em><strong>三级缓存（Spring中叫它二级缓存）解决循环依赖中代理创建过晚问题</strong></em></p><p>​其中ealySingletonObjects是二级缓存，执行流流跟以上的流程差不多，关键的点在于singletonFactories池中是存储创建Bean的工厂对象，在工厂对象中会创建出代理对象。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230204142740445.png" alt="image-20230204142740445"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;查找算法&quot;&gt;&lt;a href=&quot;#查找算法&quot; class=&quot;headerlink&quot; title=&quot;查找算法&quot;&gt;&lt;/a&gt;查找算法&lt;/h1&gt;&lt;p&gt;概述：最常见的查找算法有两种，一种是顺序查找，另一种是二分查找。&lt;/p&gt;
&lt;p&gt;（ 1 ）顺序查找的特点：适用范围广，可以查</summary>
      
    
    
    
    
    <category term="面试" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Rabbitmq技术学习</title>
    <link href="http://example.com/2023/01/03/RibbonMq/"/>
    <id>http://example.com/2023/01/03/RibbonMq/</id>
    <published>2023-01-02T16:00:00.000Z</published>
    <updated>2023-04-25T10:07:59.558Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MQ的基本概念"><a href="#MQ的基本概念" class="headerlink" title="MQ的基本概念"></a>MQ的基本概念</h1><h2 id="MQ的概述"><a href="#MQ的概述" class="headerlink" title="MQ的概述"></a>MQ的概述</h2><p><strong>MQ全称</strong>Message Queue（消息队列），是在消息的传输过程中保存消息的容器多用于分布式系统之间进行通信。</p><p>在分布式系统中两个模块可以通过以下两种方式进行通信</p><p>（ 1 ）通过openfeign远程调用（直接调用）</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230422110352447.png" alt="直接调用"></p><p>（ 2 ）通过第三方的消息队列进行通知调用（生成者与消费者模式）</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230422110624842.png" alt="image-20230422110624842"></p><p><strong>总结：</strong></p><p>（ 1 ）MQ，消息队列，存储消息的中间件</p><p>（ 2 ）分布式系统通信两种方式：直接远程调用和借助第三方完成间接通信</p><p>（ 3 ）发送方称为生产者，接收方称为消费者</p><h2 id="MQ的优势和劣势"><a href="#MQ的优势和劣势" class="headerlink" title="MQ的优势和劣势"></a>MQ的优势和劣势</h2><p>（ 1 ）优势：</p><ul><li>应用解耦</li><li>异步提速</li><li>削峰填谷</li></ul><p>（ 2 ）劣势：</p><ul><li>系统可用性降低</li><li>系统复杂度提高</li><li>—致性问题</li></ul><h2 id="MQ优势的详解"><a href="#MQ优势的详解" class="headerlink" title="MQ优势的详解"></a>MQ优势的详解</h2><p>（ 1 ）应用解耦</p><p>下图是<strong>直接调用模块</strong>的服务功能，这种方式调用如果订单系统挂掉了，则其它的模块模块也不会被执行到，这样就会导致数据的不一致，而且可扩展性也非常的差，每次扩展都需要在订单系统中添加新的远程调用方法。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230422114703855.png" alt="直接调用远程模块的图解"></p><p>采用MQ方式远程调用模块的功能就可以解决以上所提到的问题，扩展性好，在扩展时不用修改订单系统中的代码，新扩展的X系统可以直接从MQ队列中取消息，再进行消费消息即可</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230422115207762.png" alt="MQ的远程调用"></p><p>（ 2 ）异步提速</p><p>下图是没有采用MQ进行调用，则每个系统的执行时间假设为300ms，则一个订单系统的总执行时间是 300 + 300 + 300 + 20 &#x3D; 920ms</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230422115442794.png" alt="为采用MQ的系统执行时间图"></p><p>下图是采用MQ的调用方式，订单系统只需要将用户下单的消息发送到MQ队列中，让MQ去异步的 调用其他模块即可，那么这样的一个总执行时间是：20 + 5 &#x3D; 25ms，响应时间大大的缩减了</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230422115721315.png" alt="采用MQ方式"></p><p>（ 3 ）流量削峰</p><p>在流量请求非常大的业务上有大概率会导致系统的挂掉，这样的系统稳定性是非常差的。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230422120126330.png" alt="不采用MQ的方式"> </p><p>MQ是一个高可用、高可靠性的一个中间件，所有A系统每次可以从MQ中取出自己能承受的请求量进行处理，这样就达到了一个流量削峰的目的</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230422120221403.png" alt="采用MQ"></p><p>总结：</p><ul><li>应用解耦：提高系统容错性和可维护性</li><li>异步提速：提升用户体验和系统吞吐量</li><li>削峰填谷：提高系统稳定性</li></ul><h2 id="MQ的劣势的详解"><a href="#MQ的劣势的详解" class="headerlink" title="MQ的劣势的详解"></a>MQ的劣势的详解</h2><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230422120849390.png" alt="采用MQ的系统变化"></p><p>（ 1 ）系统可用性降低：系统引入的外部依赖越多，系统稳定性越差。一旦MQ宕机，就会对业务造成影响。如何保证MQ的高可用?</p><p>（ 2 ）系统复杂度提高：MQ的加入大大增加了系统的复杂度，以前系统间是同步的远程调用，现在是通过MQ进行异步调用。如何保证消息没有被重复消费?怎么处理消息丢失情况?那么保证消息传递的顺序性</p><p>（ 3）一致性问题：A系统处理完业务，通过MQ给B、C、D三个系统发消息数据，如果B系统、C系统处理成功，D系统处理失败。如何保证消息数据处理的一致性?</p><p><strong>总结：</strong></p><p>MQ的使用条件</p><p>（ 1 ）生产者不需要从消费者处获得反馈。引入消息队列之前的直接调用，其接口的返回值应该为空，这才让明明下层的动作还没做，上层却当成动作做完了继续往后走，即所谓异步成为了可能。</p><p>（ 2 ）容许短暂的不一致性。</p><p>（ 3 ）确实是用了有效果。即解耦、提速、削峰这些方面的收益，超过加入MQ，管理MQ这些成本。</p><h2 id="常用的MQ"><a href="#常用的MQ" class="headerlink" title="常用的MQ"></a>常用的MQ</h2><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230422121520179.png" alt="表"></p><h1 id="RabbitMQ的简介"><a href="#RabbitMQ的简介" class="headerlink" title="RabbitMQ的简介"></a>RabbitMQ的简介</h1><p>​AMQP，即 Advanced Message Queuing Protocol(高级消息队列协议)，是一个网络协议，是应用层协议的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端&#x2F;中间件不同产品，不同的开发语言等条件的限制。2006年AMQP规范发布。类比HTTP。</p><p>早期的MQ架构图</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230422122406482.png" alt="早期的MQ架构图"></p><p>2007年，Rabbit 技术公司基于AMQP标准开发的RabbitMQ 1.0发布。RabbitMQ采用Erlang语言开发。Erlang语言由Ericson 设计，专门为开发高并发和分布式系统的一种语言，在电信领域使用广泛。</p><p>RabbitMQ的基础架构图</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230422122505635.png" alt="RabbitMQ的基础架构图"></p><p>（ 1 ）Broker：接收和分发消息的应用，RabbitMQ Server就是 Message Broker</p><p>（ 2 ）Virtual host：出于多租户和安全因素设计的，把AMQP的基本组件划分到一个虚拟的分组中，类似于网络中的namespace概念。当多个不同的用户使用同一个RabbitMQ server 提供的服务时，可以划分出多个vhost，每个用户在自己的 vhost创建exchange &#x2F; queue 等</p><p>（ 3 ）Connection:：publisher &#x2F; consumer和broker之间的TCP连接</p><p>（ 4 ）Channel：如果每一次访问RabbitMQ都建立一个Connection，在消息量大的时候建立TCP Connection的开销将是巨大的，效率也较低。Channel是在</p><p>（ 5 ）connection：内部建立的逻辑连接，如果应用程序支持多线程，通常每个thread创建单独的channel进行通讯，AMQP method包含了channel id帮助客户端和message broker识别channel，所以channel之间是完全隔离的。Channel作为轻量级的Connection极大减少了操作系统建立TCP connection 的开销</p><h2 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h2><p>JMS 即Java消息服务(JavaMessage Service)应用程序接口，是一个Java平台中关于面向消息中间件的API</p><p>JMS是JavaEE规范中的一种，类比JDBC</p><p>很多消息中间件都实现了JMS规范，例如: ActiveMQ。RabbitMQ官方没有提供JMS的实现包，但是开源社区有</p><p>总结：</p><p>（ 1 ）RabbitMQ是基于AMQP协议使用Erlang语言开发的一款消息队列产品。RabbitMQ提供了6种工作模式（重点）。</p><p>（ 2 ）AMQP是协议，类比HTTP。</p><p>（ 3 ）JMS是API规范接口，类比JDBC。</p><h1 id="RabbitMQ的安装"><a href="#RabbitMQ的安装" class="headerlink" title="RabbitMQ的安装"></a>RabbitMQ的安装</h1><p>官网：<a href="https://www.rabbitmq.com/">https://www.rabbitmq.com/</a></p><p>安装教程可以看此文章：<a href="https://blog.csdn.net/qq_39915083/article/details/107034747">https://blog.csdn.net/qq_39915083/article/details/107034747</a></p><h1 id="RabbitMQ的快速入门"><a href="#RabbitMQ的快速入门" class="headerlink" title="RabbitMQ的快速入门"></a>RabbitMQ的快速入门</h1><h2 id="前提知识"><a href="#前提知识" class="headerlink" title="前提知识"></a>前提知识</h2><p>在快速入门前需要知道 RabbitMQ 的五种工作模式</p><p><strong>（ 1 ）简单模式：</strong>生产者生产消息放到队列中，消费者从队列中取出消息并且消费</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230422164051896.png" alt="简单模式"></p><p><strong>（ 2 ）工作模式(WorkQueue)：</strong>可以有多个消费者消费同一个队列中的消息</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230422164412850.png" alt="工作模式(WorkQueue)"></p><p><strong>（ 3 ）发布与订阅模式(Pub&#x2F;Sub)：</strong>生产者生产消息给交换机，再由交换机根据策略分配给不同的队列，最后由消费者消费</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230422165055451.png" alt="image-20230422165055451"></p><p><strong>（ 4 ）路由模式模式(Routine)：</strong>可以指定生产者的生产消息放入哪个队列中，通过routingKey指定</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230422165759394.png" alt="路由模式模式(Routine)"></p><p><strong>（ 5 ）通配符模式(Topic)：</strong>可以通过通配符的方式指定生产者生产的消息放入哪个队列中</p><ul><li>*代表多部分组成，#代表是只有一部分组成，如下图</li></ul><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230422170401399.png" alt="image-20230422170401399"></p><h2 id="依赖坐标的引入"><a href="#依赖坐标的引入" class="headerlink" title="依赖坐标的引入"></a>依赖坐标的引入</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="生产者的创建流程"><a href="#生产者的创建流程" class="headerlink" title="生产者的创建流程"></a>生产者的创建流程</h2><p>硬编码的方式定义生产者的流程图如下：</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230422201840523.png" alt="硬编码流程1"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  连接rabbitmq的基础配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConnectRabbitmq</span> &#123;</span><br><span class="line"><span class="comment">// 连接的基础设置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 设置基础连接参数</span></span><br><span class="line">            <span class="comment">// 1.创建连接工厂对象</span></span><br><span class="line">            <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">            <span class="comment">// 2.通过工厂创建连接对象</span></span><br><span class="line">            <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">            <span class="comment">// 3.设置连接到rabbit服务的参数</span></span><br><span class="line">            factory.setHost(<span class="string">&quot;127.0.0.1&quot;</span>); <span class="comment">// 设置主机 默认为 localhost</span></span><br><span class="line">            factory.setPort(<span class="number">5672</span>); <span class="comment">// 设置端口</span></span><br><span class="line">            factory.setVirtualHost(<span class="string">&quot;/test&quot;</span>);</span><br><span class="line">            factory.setUsername(<span class="string">&quot;yexuanglong&quot;</span>);</span><br><span class="line">            factory.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> connection;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.producer.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.producer.common.ConnectRabbitmq;</span><br><span class="line"><span class="keyword">import</span> com.producer.service.ProducerService;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.BuiltinExchangeType;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.rmi.RemoteException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">ProducerService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  生产者【简单消息模式】</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">productSimpleMessage</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">// 创建连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ConnectRabbitmq.getConnection();</span><br><span class="line">        <span class="keyword">if</span>(connection == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RemoteException</span>(<span class="string">&quot;connect is null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创键channel对象</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">          String queue, boolean durable, boolean exclusive, boolean autoDelete, Map&lt;String, Object&gt; arguments</span></span><br><span class="line"><span class="comment">          参数说明：</span></span><br><span class="line"><span class="comment">            （1）queue：队列的名称，生产者生产的消息放在哪个队列里</span></span><br><span class="line"><span class="comment">            （2）durable：是否持久化</span></span><br><span class="line"><span class="comment">            （3）exclusive：* 是否独占。只能有一个消费者监听这队列</span></span><br><span class="line"><span class="comment">                           * 当connection关闭时,是否删除队列</span></span><br><span class="line"><span class="comment">            （4）autoDelete：是否自动删除。当没有Consumer时，自动删除掉</span></span><br><span class="line"><span class="comment">            （5）arguments：参数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 5.创建队列 Queue 设置的参数比较多</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;hello&quot;</span>,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 6.发送消息</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            String exchange, String routingKey, AMQP.BasicProperties props, byte[] body</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            参数说明：</span></span><br><span class="line"><span class="comment">                （1）exchange：交换机名称</span></span><br><span class="line"><span class="comment">                （2）routingKey：路由名称</span></span><br><span class="line"><span class="comment">                （3）props：配置消息</span></span><br><span class="line"><span class="comment">                （4）body：消息数据</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> <span class="string">&quot;Hello World~~~&quot;</span>;</span><br><span class="line">        channel.basicPublish(<span class="string">&quot;&quot;</span>,<span class="string">&quot;hello&quot;</span>,<span class="literal">null</span>,body.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        <span class="comment">// 7.关闭资源</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  【发布与订阅模式】</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">productPubSubMessage</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">// 创建连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ConnectRabbitmq.getConnection();</span><br><span class="line">        <span class="keyword">if</span>(connection == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RemoteException</span>(<span class="string">&quot;connect is null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创键channel对象</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建交换机对象</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">          String exchange, BuiltinExchangeType type, boolean durable, boolean autoDelete, Map&lt;String, Object&gt; arguments</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">          参数说明：</span></span><br><span class="line"><span class="comment">            （1）exchange：交换机名称</span></span><br><span class="line"><span class="comment">            （2）type：类型分为以下几种</span></span><br><span class="line"><span class="comment">                    * DIRECT(&quot;direct&quot;), 定向，指定一个路由器</span></span><br><span class="line"><span class="comment">                    * FANOUT(&quot;fanout&quot;), 广播分发消息</span></span><br><span class="line"><span class="comment">                    * TOPIC(&quot;topic&quot;), 通配符</span></span><br><span class="line"><span class="comment">                    * HEADERS(&quot;headers&quot;);</span></span><br><span class="line"><span class="comment">             （3）durable：是否持久化</span></span><br><span class="line"><span class="comment">             （4）autoDelete：是否自动删除</span></span><br><span class="line"><span class="comment">             （5）arguments：参数列表</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;test_fount_exchange&quot;</span>;</span><br><span class="line">        <span class="comment">// 以广播的形式进行发送消息</span></span><br><span class="line">        channel.exchangeDeclare(exchangeName, BuiltinExchangeType.FANOUT,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 创建队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queue1Name</span> <span class="operator">=</span> <span class="string">&quot;test_fount_queue1&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">queue2Name</span> <span class="operator">=</span> <span class="string">&quot;test_fount_queue2&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queue1Name,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        channel.queueDeclare(queue2Name,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 交换机和队列进行绑定</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            String queue, String exchange, String routingKey</span></span><br><span class="line"><span class="comment">            参数说明：</span></span><br><span class="line"><span class="comment">                queue：队列名称</span></span><br><span class="line"><span class="comment">                exchange：交换机名称</span></span><br><span class="line"><span class="comment">                routingKey：路由器</span></span><br><span class="line"><span class="comment">                    若为广播模式，则为空</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.queueBind(queue1Name,exchangeName,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        channel.queueBind(queue2Name,exchangeName,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> <span class="string">&quot;【系统日志】，系统中发生了重大错误，请及时修复~~&quot;</span>;</span><br><span class="line">        channel.basicPublish(exchangeName,<span class="string">&quot;&quot;</span>,<span class="literal">null</span>, body.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">productRoutineMessage</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="comment">// 创建连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ConnectRabbitmq.getConnection();</span><br><span class="line">        <span class="keyword">if</span>(connection == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RemoteException</span>(<span class="string">&quot;connect is null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创键channel对象</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建交换机对象</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">          String exchange, BuiltinExchangeType type, boolean durable, boolean autoDelete, Map&lt;String, Object&gt; arguments</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">          参数说明：</span></span><br><span class="line"><span class="comment">            （1）exchange：交换机名称</span></span><br><span class="line"><span class="comment">            （2）type：类型分为以下几种</span></span><br><span class="line"><span class="comment">                    * DIRECT(&quot;direct&quot;), 定向，指定一个路由器</span></span><br><span class="line"><span class="comment">                    * FANOUT(&quot;fanout&quot;), 广播分发消息</span></span><br><span class="line"><span class="comment">                    * TOPIC(&quot;topic&quot;), 通配符</span></span><br><span class="line"><span class="comment">                    * HEADERS(&quot;headers&quot;);</span></span><br><span class="line"><span class="comment">             （3）durable：是否持久化</span></span><br><span class="line"><span class="comment">             （4）autoDelete：是否自动删除</span></span><br><span class="line"><span class="comment">             （5）arguments：参数列表</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;test_direct_exchange&quot;</span>;</span><br><span class="line">        <span class="comment">// 以广播的形式进行发送消息</span></span><br><span class="line">        channel.exchangeDeclare(exchangeName, BuiltinExchangeType.DIRECT,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 创建队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queue1Name</span> <span class="operator">=</span> <span class="string">&quot;test_direct_queue1&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">queue2Name</span> <span class="operator">=</span> <span class="string">&quot;test_direct_queue2&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queue1Name,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        channel.queueDeclare(queue2Name,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 交换机和队列进行绑定</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            String queue, String exchange, String routingKey</span></span><br><span class="line"><span class="comment">            参数说明：</span></span><br><span class="line"><span class="comment">                queue：队列名称</span></span><br><span class="line"><span class="comment">                exchange：交换机名称</span></span><br><span class="line"><span class="comment">                routingKey：路由器</span></span><br><span class="line"><span class="comment">                    若为广播模式，则为空</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        channel.queueBind(queue1Name,exchangeName,<span class="string">&quot;error&quot;</span>);</span><br><span class="line">        channel.queueBind(queue2Name,exchangeName,<span class="string">&quot;info&quot;</span>);</span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> <span class="string">&quot;【系统日志】，系统中发生了重大错误，请及时修复~~&quot;</span>;</span><br><span class="line">        channel.basicPublish(exchangeName,<span class="string">&quot;error&quot;</span>,<span class="literal">null</span>, body.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Topic模式</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">productTopicMessage</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ConnectRabbitmq.getConnection();</span><br><span class="line">        <span class="keyword">if</span>(connection == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RemoteException</span>(<span class="string">&quot;connect is null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建channel</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建交换机</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">exchangeName</span> <span class="operator">=</span> <span class="string">&quot;test_topic_exchange&quot;</span>;</span><br><span class="line">        channel.exchangeDeclare(exchangeName,BuiltinExchangeType.TOPIC,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建队列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName1</span> <span class="operator">=</span> <span class="string">&quot;test_topic_queue1&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">queueName2</span> <span class="operator">=</span> <span class="string">&quot;test_topic_queue2&quot;</span>;</span><br><span class="line">        channel.queueDeclare(queueName1,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        channel.queueDeclare(queueName2,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定队列和交换机</span></span><br><span class="line">        channel.queueBind(queueName1,exchangeName,<span class="string">&quot;*.error&quot;</span>);</span><br><span class="line">        channel.queueBind(queueName2,exchangeName,<span class="string">&quot;*.*&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送消息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> <span class="string">&quot;系统发送错误&quot;</span>;</span><br><span class="line">        channel.basicPublish(exchangeName,<span class="string">&quot;system.error&quot;</span>,<span class="literal">null</span>,body.getBytes(StandardCharsets.UTF_8));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭资源</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="消费者的消费流程"><a href="#消费者的消费流程" class="headerlink" title="消费者的消费流程"></a>消费者的消费流程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  连接rabbitmq的基础配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConnectRabbitmq</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 设置基础连接参数</span></span><br><span class="line">            <span class="comment">// 1.创建生产者的工厂对象</span></span><br><span class="line">            <span class="type">ConnectionFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConnectionFactory</span>();</span><br><span class="line">            <span class="comment">// 2.通过工厂创建连接对象</span></span><br><span class="line">            <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> factory.newConnection();</span><br><span class="line">            <span class="comment">// 3.设置连接到rabbit服务的参数</span></span><br><span class="line">            factory.setHost(<span class="string">&quot;127.0.0.1&quot;</span>); <span class="comment">// 设置主机 默认为 localhost</span></span><br><span class="line">            factory.setPort(<span class="number">5672</span>); <span class="comment">// 设置端口</span></span><br><span class="line">            factory.setVirtualHost(<span class="string">&quot;/test&quot;</span>);</span><br><span class="line">            factory.setUsername(<span class="string">&quot;yexuanglong&quot;</span>);</span><br><span class="line">            factory.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> connection;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">CustomerService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> ConnectRabbitmq.getConnection();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">customSimpleMessage</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException &#123;</span><br><span class="line">        <span class="keyword">if</span>(connection == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RemoteException</span>(<span class="string">&quot;connection is null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.通过连接对象创建channel对象</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.创建队列 Queue 设置的参数比较多</span></span><br><span class="line">        channel.queueDeclare(<span class="string">&quot;hello&quot;</span>,<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// 6. 接收消息</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            String queue, boolean autoAck, Consumer callback</span></span><br><span class="line"><span class="comment">            参数：</span></span><br><span class="line"><span class="comment">                （1）queue：队列名称</span></span><br><span class="line"><span class="comment">                （2）autoAck：是否自动确认</span></span><br><span class="line"><span class="comment">                （3）callback：回调函数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="comment">// 消费者ID</span></span><br><span class="line">                System.out.println(<span class="string">&quot;consumerTag：&quot;</span> + consumerTag);</span><br><span class="line">                <span class="comment">// 获取一些信息 例如：交换机 路由等等</span></span><br><span class="line">                System.out.println(<span class="string">&quot;RoutingKey：&quot;</span>+envelope.getRoutingKey());</span><br><span class="line">                <span class="comment">// 配置信息</span></span><br><span class="line">                System.out.println(<span class="string">&quot;properties：&quot;</span> + properties);</span><br><span class="line">                <span class="comment">// 消息数据</span></span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(<span class="string">&quot;hello&quot;</span>,<span class="literal">true</span>,consumer);</span><br><span class="line">        <span class="comment">// 注意不要关闭资源</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">customPubSubMessage</span><span class="params">(String queueName,String msg)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span>(connection == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RemoteException</span>(<span class="string">&quot;connection is null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4.通过连接对象创建channel对象</span></span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 接收消息</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            String queue, boolean autoAck, Consumer callback</span></span><br><span class="line"><span class="comment">            参数：</span></span><br><span class="line"><span class="comment">                （1）queue：队列名称</span></span><br><span class="line"><span class="comment">                （2）autoAck：是否自动确认</span></span><br><span class="line"><span class="comment">                （3）callback：回调函数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Consumer</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultConsumer</span>(channel)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                <span class="comment">// 消息数据</span></span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(body));</span><br><span class="line"></span><br><span class="line">                System.out.println(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        channel.basicConsume(queueName,<span class="literal">true</span>,consumer);</span><br><span class="line">        <span class="comment">// 注意不要关闭资源</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">customPubSubMessage1</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.customPubSubMessage(<span class="string">&quot;test_topic_queue1&quot;</span>,<span class="string">&quot;【用户查询数据库】&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">customPubSubMessage2</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.customPubSubMessage(<span class="string">&quot;test_topic_queue2&quot;</span>, <span class="string">&quot;【用户修改数据】&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h1><h2 id="消息可靠传递"><a href="#消息可靠传递" class="headerlink" title="消息可靠传递"></a>消息可靠传递</h2><p>在使用RabbitMQ的时候，作为消息发送方希望杜绝任何消息丢失或者投递失败场景。RabbitMQ为我们提供了两种方式用来控制消息的投递可靠性模式。</p><ul><li>confirm确认模式</li><li>return退回模式</li></ul><p>rabbitmq消息的传递路径如下图</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230423122115211.png" alt="rabbitmq消息的传递路径"></p><p>（ 1 ）消息从 producer 到exchange 则会返回一个confirmcallback 。</p><p>（ 2 ）消息从 exchange 到 queue 投递失败则会返回一个returnCallback。</p><p>我们将利用这两个callback 控制消息的可靠性投递</p><p><strong>小结：</strong></p><p>​（ 1 ）设置ConnectionFactory的publisher-confirms&#x3D;”true”开启确认模式。</p><p>​（ 2 ）使用rabbitTemplate.setConfirmCallback设置回调函数。当消息发送到exchange后回调confirm方法。在方法中判断ack，如果为true，则发送成功，如果为false，则发送失败，需要处理。</p><p>​（ 3 ）设置ConnectionFactory的publisher-returns&#x3D;”true”开启退回模式。</p><p>​（ 4 ）使用rabbitTemplate.setReturnCallback设置退回函数，当消息从exchange路由到queue失败后，如果设置rabbitTemplate.setMandatory(true)参数，则会将消息退回给producer。并执行回调函数returnedMessage。</p><h2 id="Consumer-ACK"><a href="#Consumer-ACK" class="headerlink" title="Consumer ACK"></a>Consumer ACK</h2><p>ack指Acknowledge，确认。表示消费端收到消息后的确认方式。有三种确认方式：</p><p>（ 1 ）自动确认：acknowledge&#x3D;”none”</p><p>（ 2 ）手动确认： acknowledge&#x3D;”manual”</p><p>（ 3 ）根据异常情况确认：acknowledge&#x3D;”auto”</p><p>其中自动确认是指，当消息一旦被Consumer接收到，则自动确认收到，并将相应message 从 RabbitMQ的消息缓存中移除。但是在实际业务处理中，很可能消息接收到，业务处理出现异常，那么该消息就会丢失。如果设置了手动确认方式，则需要在业务处理成功后，调用channel.basicAck()，手动签收，如果出现异常，则调用channel.basicNack()方法，让其自动重新发送消息。</p><p><strong>小结：</strong></p><p>（ 1 ）持久化：exchange要持久化，queue要持久化，message要持久化</p><p>（ 2 ）生产方确认Confirm</p><p>（ 3 ）消费方确认AckBroker高可用</p><h2 id="消费端限流"><a href="#消费端限流" class="headerlink" title="消费端限流"></a>消费端限流</h2><p>。。。</p><h2 id="TTL"><a href="#TTL" class="headerlink" title="TTL"></a>TTL</h2><p>（ 1 ）TTL全称Time To Live(存活时间&#x2F;过期时间)。</p><p>（ 2 ）当消息到达存活时间后，还没有被消费，会被自动清除。</p><p>（ 3 ）RabbitMQ可以对消息设置过期时间，也可以对整个队列(Queue)设置过期时间。</p><p><strong>ttl 小结：</strong></p><p>（ 1 ）设置队列过期时间使用参数: x-message-ttl，单位:ms(毫秒)，会对整个队列消息统一过期。</p><p>（ 2 ）设置消息过期时间使用参数: expiration。单位: ms(毫秒)，当该消息在队列头部时（消费时)，会单独判断这—消息是否过期。</p><p>（ 3 ）如果两者都进行了设置，以时间短的为准。</p><h2 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h2><p>死信队列，英文缩写：DLX 。Dead Letter Exchange(死信交换机)，当消息成为Dead message后，可以被重新发送到另一个交换机，这个交换机就是DLX。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230423144230870.png" alt="死信队列"></p><p><strong>消息成为死信的三种情况：</strong></p><p>（ 1 ）队列消息长度到达限制</p><p>（ 2 ）消费者拒接消费消息，basicNack&#x2F;basicReject，并且不把消息重新放入原目标队列,requeue&#x3D;false</p><p>（ 3 ）原队列存在消息过期设置，消息到达超时时间未被消费</p><p><strong>小结：</strong></p><p>（ 1 ）死信队列和普通队列是一样的，只是名称不一样</p><p>（ 2 ）先创建往死信队列完成之后，在普通队列中通过头参数绑定死信队列和死信交换机</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  设置死信队列和死信交换机</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean(&quot;dlxExchange&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Exchange <span class="title function_">dlxExchange</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ExchangeBuilder</span><br><span class="line">            .topicExchange(<span class="string">&quot;dlx_exchange&quot;</span>)</span><br><span class="line">            .durable(<span class="literal">true</span>)</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean(&quot;dlxQueue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">dlxQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder</span><br><span class="line">            .durable(<span class="string">&quot;dlx_queue&quot;</span>)</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean(&quot;Binding3&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Binding <span class="title function_">bindingDlxQueueExchange</span><span class="params">(<span class="meta">@Qualifier(&quot;dlxQueue&quot;)</span>Queue queue,<span class="meta">@Qualifier(&quot;dlxExchange&quot;)</span>Exchange exchange )</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder</span><br><span class="line">            .bind(queue)</span><br><span class="line">            .to(exchange)</span><br><span class="line">            .with(<span class="string">&quot;dlx.#&quot;</span>)</span><br><span class="line">            .noargs();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  测试 ttl 的交换机和队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean(&quot;ttlExchange&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Exchange <span class="title function_">ttlExchange</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ExchangeBuilder</span><br><span class="line">            .topicExchange(<span class="string">&quot;ttl_exchange&quot;</span>)</span><br><span class="line">            .durable(<span class="literal">true</span>)</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 10 s后所有的消息若还未被处理，则进入死信队列中等待下一轮的消费</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean(&quot;ttlQueue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Queue <span class="title function_">ttlQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder</span><br><span class="line">            .durable(<span class="string">&quot;ttl_queue&quot;</span>)</span><br><span class="line">            .ttl(<span class="number">10000</span>) <span class="comment">// 设置过期时间 ms</span></span><br><span class="line">            .withArgument(<span class="string">&quot;x-dead-letter-exchange&quot;</span>,<span class="string">&quot;dlx_exchange&quot;</span>) <span class="comment">// 绑定死信交换机</span></span><br><span class="line">            .withArgument(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>,<span class="string">&quot;dlx.hello&quot;</span>) <span class="comment">// 绑定死新名称</span></span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h2><p>延迟队列，即消息进入队列后不会立即被消费，只有到达指定时间后，才会被消费。</p><p>需求：</p><p>（ 1 ）下单后，30分钟未支付，取消订单，回滚库存。</p><p>（ 2 ）新用户注册成功7天后，发送短信问候。</p><p>实现方式：</p><p>（ 1 ）定时器</p><p>（ 2 ）延迟队列</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230423151255940.png" alt="延迟队列"></p><p>很可惜，在RabbitMQ中并未提供延迟队列功能。</p><p>但是可以使用：TTL+死信队列 组合实现延迟队列的效果。</p><h2 id="消息的补偿机制"><a href="#消息的补偿机制" class="headerlink" title="消息的补偿机制"></a>消息的补偿机制</h2><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230423164251684.png" alt="消息的补偿机制原理图"></p><p>（ 1 ）当生产者生产消息给指定队列后会将业务数据存入到Producer的数据库中</p><p>（ 2 ）在由消费端进行消息的消费，若消费完成之后会将该条消息记录到Consumer的数据库并发送确认该条消息已完成给指定队列，再由该队列发送给回调检查服务模块，再将此条消息存入数据库</p><p>（ 3 ）若消息消费失败，则会有延迟队列的会将失败的消息发送给回调检查服务进行检查，若其数据库中不存在此条消息，则说明该条消息消费失败，回调服务会远程电影Producer在进行发送一次消息</p><p>（ 4 ）最后的保障，定时检查服务，可以设置固定时间去检查回调服务和Producer的数据库，若该两个数据库的记录数不等，则说明有消息消费失败</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MQ的基本概念&quot;&gt;&lt;a href=&quot;#MQ的基本概念&quot; class=&quot;headerlink&quot; title=&quot;MQ的基本概念&quot;&gt;&lt;/a&gt;MQ的基本概念&lt;/h1&gt;&lt;h2 id=&quot;MQ的概述&quot;&gt;&lt;a href=&quot;#MQ的概述&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    
    <category term="消息队列" scheme="http://example.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>线上商城开发</title>
    <link href="http://example.com/2023/01/01/%E5%A4%A7%E5%9E%8B%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"/>
    <id>http://example.com/2023/01/01/%E5%A4%A7%E5%9E%8B%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/</id>
    <published>2023-01-01T07:05:00.000Z</published>
    <updated>2023-03-12T07:32:05.333Z</updated>
    
    <content type="html"><![CDATA[<h1 id="商品服务业务开发"><a href="#商品服务业务开发" class="headerlink" title="商品服务业务开发"></a>商品服务业务开发</h1><h2 id="三级分类查询"><a href="#三级分类查询" class="headerlink" title="三级分类查询"></a>三级分类查询</h2><ol><li>需求：更具数据id查询出所有的商品分类名称并以树型结构返回，原因是每个分类都有自己的子分类，所以需要递归算法进行划分，具体代码如下，根据数据库的字段parent_cid和cat_id进行筛选。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 所有的分类标签</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;CategoryEntity&gt; <span class="title function_">listWithTree</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//1. 查找出所有的分类</span></span><br><span class="line">    List&lt;CategoryEntity&gt; categorys = <span class="built_in">this</span>.getBaseMapper().selectList(<span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//2. 根据ParentCid进行筛选分类</span></span><br><span class="line">    <span class="comment">//2.1 先筛选出父类分类</span></span><br><span class="line">    List&lt;CategoryEntity&gt; parents = categorys.stream().</span><br><span class="line">            filter(category -&gt; category.getParentCid() == <span class="number">0</span>).</span><br><span class="line">            collect(Collectors.toList());</span><br><span class="line">    <span class="comment">//2.2 筛选各父类对应子分类</span></span><br><span class="line">    List&lt;CategoryEntity&gt; level1Menu = parents.stream()</span><br><span class="line">            .map(parent -&gt; &#123;</span><br><span class="line">                <span class="comment">//通过递归的方式查询出每个父类的孩子</span></span><br><span class="line">                parent.setChildren(findChildren(parent,categorys));</span><br><span class="line">                <span class="keyword">return</span> parent;</span><br><span class="line">            &#125;).sorted((m1,m2) -&gt; &#123;</span><br><span class="line">                <span class="comment">//排序，三目运算符是为避免空指针异常</span></span><br><span class="line">                <span class="keyword">return</span> (m1.getSort()==<span class="literal">null</span>?<span class="number">0</span>:m1.getSort()) - (m2.getSort()==<span class="literal">null</span>?<span class="number">0</span>:m2.getSort());</span><br><span class="line">            &#125;)</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    <span class="keyword">return</span> level1Menu;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> List&lt;CategoryEntity&gt; <span class="title function_">findChildren</span><span class="params">(CategoryEntity root,List&lt;CategoryEntity&gt; all)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> all.stream().filter(child -&gt; Objects.equals(root.getCatId(), child.getParentCid()))</span><br><span class="line">            .map(child -&gt; &#123;</span><br><span class="line">                <span class="comment">//给该孩子找自己的孩子分类</span></span><br><span class="line">                child.setChildren(findChildren(child,all));</span><br><span class="line">                <span class="keyword">return</span> child;</span><br><span class="line">            &#125;).sorted((m1,m2) -&gt; &#123;</span><br><span class="line">                <span class="comment">//排序，三目运算符是为避免空指针异常</span></span><br><span class="line">                <span class="keyword">return</span> (m1.getSort()==<span class="literal">null</span>?<span class="number">0</span>:m1.getSort()) - (m2.getSort()==<span class="literal">null</span>?<span class="number">0</span>:m2.getSort());</span><br><span class="line">            &#125;)</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>前后端接口的对接，将后端查询的数据返回给前端。</li></ol><h2 id="品牌管理"><a href="#品牌管理" class="headerlink" title="品牌管理"></a>品牌管理</h2><p>文件上传至oss服务业务</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230106162733180.png" alt="image-20230106162733180"></p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230106162807740.png" alt="image-20230106162807740"></p><p>将图片上传到aliyun的oss中，步骤如下</p><ol><li>导入alicloud的坐标</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- oss上传接口 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alicloud-oss<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>在aliyun中创建一个子用户，用于文件上传</p></li><li><p>配置上传的参数</p></li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="comment"># 配置oss的上传服务</span></span><br><span class="line">    <span class="attr">alicloud:</span></span><br><span class="line">      <span class="attr">access-key:</span> <span class="string">LTAI5tNB6qQmFB8MpUfdf4K7</span> <span class="comment"># 创建子用户时这里都会有显示</span></span><br><span class="line">      <span class="attr">secret-key:</span> <span class="string">UDYX1WJttRuBLKf4qYRWHLxAMNS6xa</span></span><br><span class="line">      <span class="attr">oss:</span></span><br><span class="line">        <span class="attr">endpoint:</span> <span class="string">oss-cn-hangzhou.aliyuncs.com</span> <span class="comment"># 选择一个oss的Bucket名称即可</span></span><br></pre></td></tr></table></figure><ol start="4"><li>编写第三方的模块服务，用户上传图片时会请求该服务模块获取上传到aliyun的资格，获取成功后可以直接上传到aliyun，不用在经过服务器，以上是获取资格的aliyun官方代码对其进行修改即可</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Endpoint以华东1（杭州）为例，其它Region请按实际情况填写。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">endpoint</span> <span class="operator">=</span> <span class="string">&quot;https://oss-cn-hangzhou.aliyuncs.com&quot;</span>;</span><br><span class="line"><span class="comment">// 阿里云账号AccessKey拥有所有API的访问权限，风险很高。强烈建议您创建并使用RAM用户进行API访问或日常运维，请登录RAM控制台创建RAM用户。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">accessKeyId</span> <span class="operator">=</span> <span class="string">&quot;yourAccessKeyId&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">accessKeySecret</span> <span class="operator">=</span> <span class="string">&quot;yourAccessKeySecret&quot;</span>;</span><br><span class="line"><span class="comment">// 填写Bucket名称，例如examplebucket。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">bucketName</span> <span class="operator">=</span> <span class="string">&quot;examplebucket&quot;</span>;</span><br><span class="line"><span class="comment">// 填写Object完整路径，完整路径中不能包含Bucket名称，例如exampledir/exampleobject.txt。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">objectName</span> <span class="operator">=</span> <span class="string">&quot;exampledir/exampleobject.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建OSSClient实例。</span></span><br><span class="line"><span class="type">OSS</span> <span class="variable">ossClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OSSClientBuilder</span>().build(endpoint, accessKeyId, accessKeySecret);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 填写Byte数组。</span></span><br><span class="line">    <span class="type">byte</span>[] content = <span class="string">&quot;Hello OSS, 你好世界&quot;</span>.getBytes();</span><br><span class="line">    <span class="comment">// 创建PutObjectRequest对象。</span></span><br><span class="line">    <span class="type">PutObjectRequest</span> <span class="variable">putObjectRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PutObjectRequest</span>(bucketName, objectName, <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(content));</span><br><span class="line">    <span class="comment">// 设置该属性可以返回response。如果不设置，则返回的response为空。</span></span><br><span class="line">    putObjectRequest.setProcess(<span class="string">&quot;true&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建PutObject请求。</span></span><br><span class="line">    <span class="type">PutObjectResult</span> <span class="variable">result</span> <span class="operator">=</span> ossClient.putObject(putObjectRequest);</span><br><span class="line">    <span class="comment">// 如果上传成功，则返回200。</span></span><br><span class="line">    System.out.println(result.getResponse().getStatusCode());</span><br><span class="line">&#125; <span class="keyword">catch</span> (OSSException oe) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Caught an OSSException, which means your request made it to OSS, &quot;</span></span><br><span class="line">            + <span class="string">&quot;but was rejected with an error response for some reason.&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;Error Message:&quot;</span> + oe.getErrorMessage());</span><br><span class="line">    System.out.println(<span class="string">&quot;Error Code:&quot;</span> + oe.getErrorCode());</span><br><span class="line">    System.out.println(<span class="string">&quot;Request ID:&quot;</span> + oe.getRequestId());</span><br><span class="line">    System.out.println(<span class="string">&quot;Host ID:&quot;</span> + oe.getHostId());</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClientException ce) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Caught an ClientException, which means the client encountered &quot;</span></span><br><span class="line">            + <span class="string">&quot;a serious internal problem while trying to communicate with OSS, &quot;</span></span><br><span class="line">            + <span class="string">&quot;such as not being able to access the network.&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;Error Message:&quot;</span> + ce.getMessage());</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ossClient != <span class="literal">null</span>) &#123;</span><br><span class="line">        ossClient.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SKU-amp-SPU的属性分组"><a href="#SKU-amp-SPU的属性分组" class="headerlink" title="SKU&amp;SPU的属性分组"></a>SKU&amp;SPU的属性分组</h2><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230108115618524.png" alt="image-20230108115618524"></p><h2 id="商品管理–SKU检索"><a href="#商品管理–SKU检索" class="headerlink" title="商品管理–SKU检索"></a>商品管理–SKU检索</h2><h2 id="仓储管理"><a href="#仓储管理" class="headerlink" title="仓储管理"></a>仓储管理</h2><p><strong>合并采购单业务流程</strong></p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230114162049536.png" alt="image-20230114162049536"></p><p><strong>采购单领取业务开发</strong></p><p>采购单通常有5种状态分别是：创建、已分配、已领取、已完成、有异常。而领取采购单只能是从创建、已分配这两种状态中是可以领取的，其它状态是不可被领取的。所以在业务中需要将其它状态的采购单给过滤掉。</p><h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><h2 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h2><p>官方英文：[Elasticsearch Guide <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html">8.6] | Elastic</a></p><p>官方中文：<a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/foreword_id.html">序言 | Elasticsearch: 权威指南 | Elastic</a></p><p>ElasticSearch的基本概念：</p><ol><li>Index（索引）：用于存储表，相当于Mysql中的Database</li><li>Type（类型）：相当于Mysql中的Table，用于存储数据</li><li>Document（文档）：某个Type下的一个数据，是以Json格式存贮的，相当于Mysql中的Table下的数据</li></ol><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230117125025796.png" alt="image-20230117125025796"></p><p>ElasticSearch的强大搜索功能是基于倒排索引机制的。</p><p><strong>使用docker下载ElasticSearch的镜像命令</strong></p><ol><li>docker pull elasticsearch:版本号  &gt;&gt;  用于存储和检索数据</li><li>docker pull kibana:版本号 &gt;&gt; 可视化界面</li></ol><p><strong>创建一个docker运行镜像</strong></p><ol><li>自行创建两个挂载文件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p 文件目录/文件名称</span><br><span class="line">mkdir -p /root/mydata/elasticsearch/data </span><br><span class="line">mkdir -p /root/mydata/elasticsearch/config</span><br></pre></td></tr></table></figure><ol start="2"><li>做好一个小配置</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo echo &quot;http.host: 0.0.0.0&quot; &gt;&gt; /mydata/elasticsearch/config/elasticsearch.yml</span><br></pre></td></tr></table></figure><ol start="3"><li>提升挂载文件的权限</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod -R 777 /root/mydata/elasticsearch</span><br></pre></td></tr></table></figure><ol start="4"><li>使用docker的运行命令</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run --name elasticsearch -p 9200:9200 -p 9300:9300 \</span><br><span class="line">-e discovery.type=&quot;single-node&quot; \</span><br><span class="line">-e ES_JAVA_OPTS=&quot;-Xms64m -Xmx128m&quot; \</span><br><span class="line">-v /root/mydata/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml \</span><br><span class="line">-v /root/mydata/elasticsearch/data:/usr/share/elasticsearch/data \</span><br><span class="line">-v /root/mydata/elasticsearch/plugins:/usr/share/elasticsearch/plugins \</span><br><span class="line">-d elasticsearch:7.4.2</span><br></pre></td></tr></table></figure><p><strong>运行可视化界面Kibana</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name kibana -e ELASTICSEARCH_HOSTS=http://192.168.177.130:9200 -p 5601:5601 -d kibana:7.4.2</span><br></pre></td></tr></table></figure><h3 id="初步检索"><a href="#初步检索" class="headerlink" title="初步检索"></a>初步检索</h3><p><strong>查看_cat</strong></p><p>利用postman发送http请求即可对其检索</p><ol><li><p><a href="http://192.168.177.130:9200/_cat/nodes%EF%BC%9A%E6%9F%A5%E7%9C%8B%E6%89%80%E6%9C%89%E8%8A%82%E7%82%B9GET">http://192.168.177.130:9200/_cat/nodes：查看所有节点GET</a></p></li><li><p><a href="http://192.168.177.130:9200/_cat/health%EF%BC%9A%E6%9F%A5%E7%9C%8Bes%E5%81%A5%E5%BA%B7%E7%8A%B6%E5%86%B5GET">http://192.168.177.130:9200/_cat/health：查看es健康状况GET</a></p></li><li><p><a href="http://192.168.177.130:9200/_cat/master%EF%BC%9A%E6%9F%A5%E7%9C%8B%E4%B8%BB%E8%8A%82%E7%82%B9GET">http://192.168.177.130:9200/_cat/master：查看主节点GET</a></p></li><li><p><a href="http://192.168.177.130:9200/_cat/indices%EF%BC%9A%E6%9F%A5%E7%9C%8B%E6%89%80%E6%9C%89%E7%B4%A2%E5%BC%95GET">http://192.168.177.130:9200/_cat/indices：查看所有索引GET</a></p></li></ol><p><strong>新增操作</strong></p><p>REST_API的格式：<a href="http://192.168.177.130:9200/index%E5%90%8D%E7%A7%B0/type%E5%90%8D%E7%A7%B0/ID">http://192.168.177.130:9200/index名称/type名称/ID</a></p><ul><li>Post请求：指定ID，若存在该数据则修改操作，否则是新增操作，不指定ID，则都是新增操作</li><li>Put请求：必须指定ID，否则会保错，一般是用于修改操作</li></ul><h2 id="利用Docker创建ES"><a href="#利用Docker创建ES" class="headerlink" title="利用Docker创建ES"></a>利用Docker创建ES</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 9200:9200 -p 9300:9300 --name es \</span><br><span class="line">-e &quot;discovery.type=single-node&quot; \</span><br><span class="line">-e ES_JAVA_OPTS=&quot;-Xms64m -Xmx512m&quot; \</span><br><span class="line">-v /root/mydata/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/conf/elasticsearch.yml \</span><br><span class="line">-v /root/mydata/elasticsearch/data:/usr/share/elasticsearch/data \</span><br><span class="line">-v /root/mydata/elasticsearch/plugins/:/usr/share/elasticsearch/plugins \</span><br><span class="line">-d elasticsearch:7.4.2</span><br></pre></td></tr></table></figure><h1 id="SpringBoot整合Elasticsearch"><a href="#SpringBoot整合Elasticsearch" class="headerlink" title="SpringBoot整合Elasticsearch"></a>SpringBoot整合Elasticsearch</h1><p>（ 1 ）导入ES的客户端依赖坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（ 2 ）编写配置类，将操作的ES客户端注入到IOC容器中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ESConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 向IOC容器中注入操作ES的客户端 -- 主要操作ES服务器中的检索服务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RestHighLevelClient <span class="title function_">restHighLevelClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 构建一个RestClient的连接</span></span><br><span class="line">        <span class="type">RestClientBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> RestClient</span><br><span class="line">                .builder(<span class="keyword">new</span> <span class="title class_">HttpHost</span>(<span class="string">&quot;192.168.177.130&quot;</span>, <span class="number">9200</span>, <span class="string">&quot;http&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestHighLevelClient</span>(builder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（ 3 ）还可以在配置类中对客户端请求ES服务器进行一些操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> RequestOptions COMMON_OPTIONS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        RequestOptions.<span class="type">Builder</span> <span class="variable">builder</span> <span class="operator">=</span> RequestOptions.DEFAULT.toBuilder();</span><br><span class="line">        <span class="comment">// 对ES的请求添加请求头</span></span><br><span class="line"><span class="comment">//        builder.addHeader(&quot;Authorization&quot;,&quot;taken&quot;);</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 建立公共配置</span></span><br><span class="line">        COMMON_OPTIONS = builder.build();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="测试保存数据"><a href="#测试保存数据" class="headerlink" title="测试保存数据"></a>测试保存数据</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  测试存储数据到ES服务器中，也可以更新数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">IndexData</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 创建一个Index</span></span><br><span class="line">    <span class="type">IndexRequest</span> <span class="variable">indexRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IndexRequest</span>(<span class="string">&quot;users&quot;</span>);</span><br><span class="line">    <span class="comment">// 创建索引ID，若不创建则默认会自动生成一个ID</span></span><br><span class="line">    indexRequest.id(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="comment">// 设置需要保存的数据</span></span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setId(<span class="number">2L</span>);</span><br><span class="line">    user.setUsername(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">    user.setNickname(<span class="string">&quot;INUK&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> JSON.toJSONString(user);</span><br><span class="line">    <span class="comment">// 注意需要指定保持数据的类型</span></span><br><span class="line">    indexRequest.source(json, XContentType.JSON);</span><br><span class="line"> <span class="comment">// response相当于回调函数后的结果</span></span><br><span class="line">    <span class="type">IndexResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.index(indexRequest, ESConfig.COMMON_OPTIONS);</span><br><span class="line"></span><br><span class="line">    System.out.println(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;商品服务业务开发&quot;&gt;&lt;a href=&quot;#商品服务业务开发&quot; class=&quot;headerlink&quot; title=&quot;商品服务业务开发&quot;&gt;&lt;/a&gt;商品服务业务开发&lt;/h1&gt;&lt;h2 id=&quot;三级分类查询&quot;&gt;&lt;a href=&quot;#三级分类查询&quot; class=&quot;headerli</summary>
      
    
    
    
    
    <category term="springcloud" scheme="http://example.com/tags/springcloud/"/>
    
  </entry>
  
  <entry>
    <title>java反射机制</title>
    <link href="http://example.com/2022/12/16/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
    <id>http://example.com/2022/12/16/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</id>
    <published>2022-12-15T16:00:00.000Z</published>
    <updated>2022-12-17T08:54:32.540Z</updated>
    
    <content type="html"><![CDATA[<p>概述：反射是jvm中非常重要的机制，在spring系列所有的框架中底层都有涉及到反射机制，若java没有反射的话，那么也就没有如今的spring系列的框架，而且反射可以实现在不修改源码情况下来控制程序，符合了设计模式中的ocp原则（开闭原则），同时也是实现动态代理的前提。</p><p><strong>传统方式创建对象VS反射机制创建对象</strong> </p><p>在java中传统的创建对象是new 类()，而反射中是从堆中取出Class对象并通过Class来反射到具体的类中，对具体的类成员方法、成员属性、成员变量等类中的所有成员进行创建、调用等操作。单单看文字很难理解，以下是反射的原理图（来自B站韩孙平的反射讲解）。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221216211655077.png" alt="image-20221216211655077"></p><p>对上图的理解：java程序有三个阶段，第一是编译阶段，在这一阶段是通过jvm虚拟机进行java代码进行编译，形成了class的字节码文件，在jvm中在通过ClassLoader（类加载器）将class的字节码文件读取到第二阶段（加载阶段）并在堆中创建Class对象，在运行阶段是可以通过new 类() 方式从堆中将Class对象创建出来，便可以对此类的成员进行操作，而反射的方式创建对象并不是如此，反射是通过具体的对象去获取具体类的结构，然后再去进行操作。</p><p><strong>代码演示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反射演示过程--&gt;传统方式创建对象VS反射机制创建对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mysticBoy</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * 反射常用的API有：</span></span><br><span class="line"><span class="comment"> *      java.lang.Class:代表一个类,Class对象表示某个类加载后在堆T</span></span><br><span class="line"><span class="comment"> *      java.lang.reflect.Method:代表类的方法,Method对象表示某个类的方法</span></span><br><span class="line"><span class="comment"> *      java.lang.reflect.Field:代表类的成员变量, Field对象表示某个类的成员变量</span></span><br><span class="line"><span class="comment"> *      java.lang.reflect.Constructor:代表类的构造方法, Constructor对象表示构造器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectionTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, InstantiationException &#123;</span><br><span class="line">        <span class="comment">//方式一：传统的方式调用Dog类中的成员方法</span></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        dog.hi();</span><br><span class="line">        <span class="comment">//需求：现在我需要根据配置文件去操作Dog中的成员，该如何做？</span></span><br><span class="line">        <span class="comment">//1. 用传统的方法是否可行?</span></span><br><span class="line">        <span class="comment">//(1) 首先需要从配置文件中获取到信息，可以使用Properties类获取</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="comment">//(2) 通过字符输入流读取文件并加载出信息</span></span><br><span class="line">        properties.load(Files.newInputStream(Paths.get(<span class="string">&quot;c_reflection\\profile\\reflection.properties&quot;</span>)));</span><br><span class="line">        <span class="comment">//(3) 获取出类具体和具体的方法</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">allPath</span> <span class="operator">=</span> (String) properties.get(<span class="string">&quot;allPath&quot;</span>); <span class="comment">//c_reflection.Dog 类的引用路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> (String) properties.get(<span class="string">&quot;methodName&quot;</span>);</span><br><span class="line">        <span class="comment">//(4) 现需要调用方hi方法，那么需要先创建对象，那要如何创建呢？</span></span><br><span class="line">        <span class="comment">//new allPath()这样创建是不行的，因为allPath是一个字符串，无法创建对象，故传统的方式是不能满足此需求的</span></span><br><span class="line">        System.out.println(<span class="string">&quot;==========反射机制===========&quot;</span>);</span><br><span class="line">        <span class="comment">//方式二：通过反射创建对象</span></span><br><span class="line">        <span class="comment">//1. 从配置文件读取的类</span></span><br><span class="line">        Class&lt;?&gt; cls = Class.forName(allPath);</span><br><span class="line">        <span class="comment">//2. 实例化类</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> cls.newInstance();</span><br><span class="line">        <span class="comment">//3. 从Class类对象中获取出方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> cls.getMethod(methodName);</span><br><span class="line">        <span class="comment">//4. 调用方法 反射的形式：对象.实体类</span></span><br><span class="line">        method.invoke(instance);</span><br><span class="line">       <span class="comment">//  获取成员变量</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> cls.getField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        <span class="comment">// 通过字段获取变量</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">i</span> <span class="operator">=</span> field.get(instance);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        <span class="comment">// 获取构造器</span></span><br><span class="line">        Constructor&lt;?&gt; cts = cls.getConstructor();</span><br><span class="line">        System.out.println(cts);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;哈士奇&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;System.out.println(<span class="string">&quot;hello &quot;</span> + name);&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span> &#123;System.out.println(<span class="string">&quot;汪汪汪&quot;</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>反射的优缺点</strong></p><ul><li><p>优点：可以动态的创建和使用对象(也是框架底层核心)，使用灵活，没有反射机制，框架技术就失去底层支撑。</p></li><li><p>缺点：使用反射基本是解释执行，对执行速度有影响.</p></li></ul><p><strong>Class类的特点</strong></p><ul><li>Class也是类，因此也继承Object类</li><li>Class类对象不是new出来的，而是系统创建的</li><li>对于某个类的Class类对象，在内存中只有一份，因为类只加载一次</li><li>每个类的实例都会记得自己是由哪个Class 实例所生成</li><li>通过Class可以完整地得到一个类的完整结构,通过一系列API</li><li>Class对象是存放在堆的</li></ul><p><strong>静态加载VS动态加载</strong></p><p>反射机制是java实现动态语言的关键，也就是通过反射实现类动态加载</p><ol><li>静态加载：编译时加载相关的类，如果没有则报错，依赖性太强</li><li>动态加载：运行时加载需要的类，如果运行时不用该类，即使不存在该类，则不报错，降低了依赖性</li></ol><p><strong>类加载时机</strong></p><ol><li>当创建对象时（静态加载）</li><li>当子类被加载时，父类也加载</li><li>调用类中的静态成员时</li><li>通过反射（动态加载）</li></ol><p><strong>类加载过程图</strong></p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221217161305473.png" alt="image-20221217161305473"></p><p><strong>类加载三阶段的具体流程</strong></p><p>在加载过程和连接过程是由jvm机控制的，而初始化是可以由程序员进行控制，注意这里的初始化是类中的初始静态代码块，而不是创建一个对象。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221217161441058.png" alt="image-20221217161441058"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;概述：反射是jvm中非常重要的机制，在spring系列所有的框架中底层都有涉及到反射机制，若java没有反射的话，那么也就没有如今的spring系列的框架，而且反射可以实现在不修改源码情况下来控制程序，符合了设计模式中的ocp原则（开闭原则），同时也是实现动态代理的前提。&lt;</summary>
      
    
    
    
    
    <category term="java基础" scheme="http://example.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>微服务</title>
    <link href="http://example.com/2022/12/02/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    <id>http://example.com/2022/12/02/%E5%BE%AE%E6%9C%8D%E5%8A%A1/</id>
    <published>2022-12-02T04:31:48.000Z</published>
    <updated>2023-02-06T05:13:32.209Z</updated>
    
    <content type="html"><![CDATA[<h1 id="认识微服务"><a href="#认识微服务" class="headerlink" title="认识微服务"></a>认识微服务</h1><ul><li><p>单体架构：将业务的所有功能集中在一个项目中开发，打成一个包部署。</p><ul><li>优点：架构简单、部署成本低</li><li>缺点：耦合度高、当有一个模块出现BUG，可能会导致整个系统崩溃。</li></ul></li><li><p>分布式架构：根据业务功能对系统进行拆分，每个业务模块作为独立项目开发，称为一个服务。</p><ul><li>优点：降低耦合度、有利于服务的升级和扩展。</li><li>缺点：研发成本高</li></ul></li><li><p>微服务是一种经过良好架构设计的分布式架构方案，微服务架构特征</p><ul><li>单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责，避免重复业务开友</li><li>面向服务：微服务对外暴露业务接口</li><li>自治：团队独立、技术独立、数据独立、部署独立</li><li>隔离性强：服务调用做好隔离、容错、降级、避免出现级联问题</li></ul></li></ul><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221204133958073.png" alt="image-20221204133958073"></p><h2 id="微服务结构"><a href="#微服务结构" class="headerlink" title="微服务结构"></a>微服务结构</h2><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221204134435078.png" alt="image-20221204134435078"></p><h2 id="微服务技术对比"><a href="#微服务技术对比" class="headerlink" title="微服务技术对比"></a>微服务技术对比</h2><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221204135049357.png" alt="image-20221204135049357"></p><h1 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h1><ul><li>SpringCloud集成了各种微服务功能组件，并基于SpringBoot实现了这些组件的自动装配，从而提供了良好的开箱即用体验:</li></ul><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221204135842628.png" alt="image-20221204135842628"></p><h1 id="服务拆分"><a href="#服务拆分" class="headerlink" title="服务拆分"></a>服务拆分</h1><ol><li>不同微服务，不要重复开发相同业务</li><li>微服务数据独立，不要访问其它微服务的数据库</li><li>微服务可以将自己的业务暴露为接口，供其它微服务调用</li></ol><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221204140506901.png" alt="image-20221204140506901"></p><h2 id="微服务远程调用"><a href="#微服务远程调用" class="headerlink" title="微服务远程调用"></a>微服务远程调用</h2><p>概述：在微服务体系架构中，每个业务服务都是一个独立的服务模块，每个模块都有属于自己的数据库，所以要联表查询数据是不能像单体项目一样可以直接进行多表查询，而是要通过每个服务模块暴露出部分接口供给其它服务模块调用。</p><ul><li><p>远程调用的实质：就是给目标服务模块发送一个HTTP的请求，让目标服务进行一个响应并返回数据即可。</p></li><li><p>远程调用的API是RestTemplate，该API应交给Spring的IOC容器管理。</p></li><li><p>服务调用关系（两者身份是相对的）</p><ul><li>服务提供者：暴露接口给其它服务调用。</li><li>服务消费者：调用来自其它服务模块的提供的接口。</li></ul></li></ul><h1 id="Eureka注册中心"><a href="#Eureka注册中心" class="headerlink" title="Eureka注册中心"></a>Eureka注册中心</h1><p>服务调用出现的问题</p><ul><li>服务消费者该如何获取服务提供者的地址信息？</li><li>如果有多个服务提供者，消费者该如何选择？</li><li>消费者如何得知服务提供者的健康状态？</li></ul><p>Eureka介绍：主要作用是记录每个服务提供者的地址信息</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221204153807427.png" alt="image-20221204153807427"></p><p>Eureka架构</p><ol><li><p>EurekaService：服务端，注册中心——专门记录服务信息和服务接口的健康监测。</p></li><li><p>EurekaClient：客户端</p><ul><li>服务提供者：注册服务提供者的信息，并每隔30秒会进行一个监测，保证接口是否可以正常供应</li><li>服务消费者：根据服务名称从EurekaServer拉取服务列表，基于服务列表做负载均衡，选中一个微服务后发起远程调用</li></ul></li></ol><h2 id="搭建EurekaServer"><a href="#搭建EurekaServer" class="headerlink" title="搭建EurekaServer"></a>搭建EurekaServer</h2><p>搭建EurekaServer服务步骤如下</p><ol><li>创建项目，引入spring-cloud-starter-netflix-eureka-server的依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>编写启动类，添加@EnableEurekaServer注解</li><li>添加application.yml文件，编写下面的配置</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8888</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eurekaServer</span></span><br><span class="line"><span class="comment"># 注册信息</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:8888/eureka</span></span><br></pre></td></tr></table></figure><h2 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h2><ol><li>在目标项目中引入坐标spring-cloud-starter-netflix-eureka-client</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--  引入eureka的客户端--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>在application.yml的配置参数如下</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置服务的名称</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">userService</span></span><br><span class="line"><span class="comment"># 注册信息</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:8888/eureka</span></span><br></pre></td></tr></table></figure><h2 id="使用Eureka实现负载均衡"><a href="#使用Eureka实现负载均衡" class="headerlink" title="使用Eureka实现负载均衡"></a>使用Eureka实现负载均衡</h2><ol><li>在RestTemplate加载Bean的方法上加注解@LoadBalanced即可实现。</li><li>在RestTemplate远程调用时可以使用已在eureka服务器中注册的服务名称进行调用，RestTemplate会在eureka服务发现指定的端口并进行远程连接。</li></ol><h1 id="Ribbon负载均衡原理"><a href="#Ribbon负载均衡原理" class="headerlink" title="Ribbon负载均衡原理"></a>Ribbon负载均衡原理</h1><p>​在order-service服务发出了一个请求，若在order-service中加载Bean的RestTemplate方法上有@LoadBalanced时，其发出的请求会被LoadBalancerInterceptor类（负载均衡拦截器）拦截下来，然后到enreka-server（服务中心）根据别名（userservice）查找已注册的服务列表，若存在该服务名称则就返回相关的服务列表到Ribbon中，该返回的列表是真实的ip地址号，在Ribbon中进一步的进行负载均衡的算法。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221210152342658.png" alt="image-20221210152342658"></p><ul><li>Ribbon内部结构图</li></ul><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221210153437529.png" alt="image-20221210153437529"></p><h2 id="负载均衡的策略"><a href="#负载均衡的策略" class="headerlink" title="负载均衡的策略"></a>负载均衡的策略</h2><p>下图是Ribbon负载均衡策略继承关系</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221210153849904.png" alt="image-20221210153849904"></p><p><strong>每个类的含义如下图</strong></p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221210154712521.png" alt="image-20221210154712521"></p><p>调整负载均衡的规则，默认是轮询的方式作为负载均衡</p><ul><li>将需要目标策略加载成Bean即可（作用范围：全局）</li><li>在application.yml配置文件中配置如下参数即可（作用范围：局部，在哪个微服务中配置就作用在其微服务）</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 微服务名称</span></span><br><span class="line"><span class="attr">userService:</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.RandomRule</span> <span class="comment">#负载均衡规则</span></span><br></pre></td></tr></table></figure><p>Ribbon默认是采用懒加载，即第一次访问时才会去创建LoadBalanceClient，请求时间会很长。而饥饿加载则会在项目启动时创建，降低第一次访问的耗时，通过下面配置开启饥饿加载。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="attr">eager-load:</span></span><br><span class="line">    <span class="attr">clients:</span> <span class="string">userService</span>  <span class="comment">#指定对哪个服务进行饥饿加载</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment">#开启饥饿加载</span></span><br></pre></td></tr></table></figure><h1 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h1><p>概述：Nacos是阿里巴巴的产品，现在是SpringCloud中的一个组件。相比Eureka功能更加丰富，在国内受欢迎程度较高。安装自行百度</p><p>在Windows系统下启动Nacos命令：startup.cmd -m standalone</p><p>整合Nacos步骤如下</p><ol><li>在父工程引入所有的阿里巴巴的版本控制</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>在目标服务包下引入nacos的客户端</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- nacos客户端依赖包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>在目标服务包下修改配置</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#配置nacos服务器的地址</span></span><br></pre></td></tr></table></figure><ol start="4"><li>以上配置完成后，不用加任何的代码即可实现微服务间的请求负载均衡。</li></ol><h2 id="nacos的设置"><a href="#nacos的设置" class="headerlink" title="nacos的设置"></a>nacos的设置</h2><p>分级存储模型：分级模型就是将同种实例服务分布在不同地区的服务器中，避免一个服务器挂掉了使该实例服务不能提供服务的情况发生，所以一个服务实例通常会部署在不同的服务器上，每个地区的服务实例会进行一个集群，当本地的服务实例不能用时，会搜索其它地区的服务实例。</p><ol><li>集群配置</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"> <span class="attr">naocs:</span></span><br><span class="line"><span class="attr">discovery:</span></span><br><span class="line">   <span class="attr">cluster-name:</span> <span class="string">HZ</span> <span class="comment">#配置集群名称，以地名命名</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>NaocsRule负载均衡策略</p><ol><li>优先选择同集群服务实例列表</li><li>本地集群找不到提供者，才去其它集群寻找，并且会报警告</li><li>确定了可用实例列表后，再采用随机负载均衡挑选实例</li></ol></li><li><p>Naocs的实例权重设置</p><ol><li>Nacos控制台可以设置实例的权重值0~1之间</li><li>同集群内的多个实例，权重越高被访问的频率越高</li><li>权重设置为0则完全不会被访问</li></ol></li><li><p>Naocs的环境隔离</p><ol><li>namespace用来做环境隔离</li><li>每个namespace都有唯一id</li><li>不同namespace下的服务不可见（不同环境中的服务访问的话会报错，No instances available for userService）</li></ol></li></ol><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>nacos与eureka的整体原理差不多，服务提供者都要在注册中心进行一个注册，每隔一段时间注册中心都会进行一次服务的健康检测来检测一下服务提供者提供的服务是否可用，但nacos比eureka功能更完善，<strong>nacos和eureka的细节区别：</strong>nacos中存在临时实例和非临时实例，临时实例是存在服务列表缓存中，而服务消费者先从服务列表查找是否有自己需要的服务（读取缓存，速度更快）。服务消费者会定时从注册中心拉取服务，从而更新服务列表缓存，临时服务需要主动将自己的健康情况推送到注册中心中，若注册中心一定时间未检测到临时实例服务的健康情况，注册中心会将其服务去除掉，但非临时实例是相反的，注册中心会主动的询问非临时实例是否处于健康状态，就算是非健康状态注册中心也不会将其剔除，那以上的说法会产生一个新的问题，那就是当注册中心有一个临时实例挂掉了，但服务列表缓存未及时的更新，那么针对该问题，当有一个临时实例或非临时实例挂掉了，注册中心会主动将更新好的服务列表发送给服务消费者。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221211133647023.png" alt="image-20221211133647023"></p><h2 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h2><p>当nacos注册中心若存在很多的微服务，若需要进行系统升级，那每个微服务的配置都给重新配置，这样就会变得非常的麻烦，nacos提供了配置管理服务将所有的微服务同一配置管理，只要在配置管理修改配置参数，各个微服务再进行读取配置管理中的配置参数即可完成修改。那么如何实现呢？</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221211141202582.png" alt="image-20221211141202582"></p><p><strong>配置管理的实现步骤如下</strong></p><ol><li>第一步需要在nocas注册中心新建一个配置管理文件，步骤如下（最后点击发布即可）</li></ol><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221211143706538.png" alt="image-20221211143706538"></p><p>文件类型选择yaml类型</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221211144015549.png" alt="image-20221211144015549"></p><ol start="2"><li>如何让微服务读取到nacos中的配置文件呢？首先在目标服务实例中引入nacos的配置管理坐标</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入nacos的配置管理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其次在resource目录下新建一个bootsrap.yml文件，注意，该文件名称一定是这样命名的，因为bootsrap.yml配置文件加载的优先级比application.yml高，然后再文件中加上以下参数即可，当配置完成后可以用@Value注解读取配置文件中的信息。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">userService</span> <span class="comment">#服务名称</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span> <span class="comment"># 配置环境，这里的环境一定要与你在nacos注册中心文件命名的那个环境一样</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment"># 配置nacos的注册中心地址</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment"># 文件的后缀名</span></span><br></pre></td></tr></table></figure><p>从nacos中获取配置文件的信息整体流程如下</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221211150233950.png" alt="image-20221211150233950"></p><h3 id="nacos的配置自动更新（热更新）"><a href="#nacos的配置自动更新（热更新）" class="headerlink" title="nacos的配置自动更新（热更新）"></a>nacos的配置自动更新（热更新）</h3><p>概述：自动更新是不需要重启服务器就可以完成配置文件信息的更新</p><ul><li>方式一：使用注解@RefreshScope配合@value使用即可完成。@RefreshScope放在类上</li><li>方式二：使用注解@ConfigurationProperties完成自动更新。</li></ul><h3 id="nacos的文件加载优先级"><a href="#nacos的文件加载优先级" class="headerlink" title="nacos的文件加载优先级"></a>nacos的文件加载优先级</h3><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221211153109271.png" alt="image-20221211153109271"></p><h1 id="HTTP客户端Feign"><a href="#HTTP客户端Feign" class="headerlink" title="HTTP客户端Feign"></a>HTTP客户端Feign</h1><p>RestTemplate远程调用的问题：</p><ol><li>代码可读性差，编程体验不统一</li><li>参数复杂URL难以维护</li></ol><p>Feign的介绍：Feign是一个声明式的http客户端，其内部已经整合了ribbon，不用自己配置即可做到负载均衡，其作用就是帮助我们优雅的实现http请求的发送，解决上面提到的问题。官方地址: <a href="https://github.com/OpenFeign/feign">https://github.com/OpenFeign/feign</a></p><p><strong>Feigh的使用步骤如下</strong></p><ol><li>引入依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入fright依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>在启动类上开启feigh客户端驱动@EnableFeignClients</p></li><li><p>定义一个包专门来请求别的微服务模块，并编写接口如下图（注意@FeignClient()参数中不要加&#x2F;）</p></li></ol><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221215140003411.png" alt="image-20221215140003411"></p><ol start="4"><li>在业务层注入客户端的接口，如上的UserClient的bean即可直接调用接口中的方法完成微服务间的调用。</li></ol><p><strong>Fign的自定义配置</strong></p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221215141415617.png" alt="image-20221215141415617"></p><p><strong>Feign的日志配置</strong></p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221215141232182.png" alt="image-20221215141232182"></p><h2 id="Feign的性能优化"><a href="#Feign的性能优化" class="headerlink" title="Feign的性能优化"></a>Feign的性能优化</h2><p>Feign优化分为两个方面，第一Feign的日志级别不要开的太高，最好在BASIC级别即可，在日志这方面只有优化这个，第二在请求连接方面的优化。因为Feign默认的请求调用是不支持连接池的使用，每次都要创建请求和销毁请求，比较消耗性能，可以自己配置Feign的连接池，将请求连接交给连接池管理这样就不用每次请求都要进行创建和销毁，从而提高了性能，步骤如下</p><ol><li>引入依赖（使用HttpClient连接池）</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入fright的httpClient连接池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>修改配置文件，配置参数如下</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">httpclient:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment">#开启连接池的使用</span></span><br><span class="line">    <span class="attr">max-connections-per-route:</span> <span class="number">50</span> <span class="comment">#单个服务接口的最大连接数</span></span><br><span class="line">    <span class="attr">max-connections:</span> <span class="number">200</span> <span class="comment">#最大连接数</span></span><br><span class="line">    <span class="attr">time-to-live:</span> <span class="number">90</span> <span class="comment">#连接存活的时间，若超过90S未使用会自动取消连接</span></span><br></pre></td></tr></table></figure><h2 id="Feign的最佳实践"><a href="#Feign的最佳实践" class="headerlink" title="Feign的最佳实践"></a>Feign的最佳实践</h2><p>概述：Feign的远程调用中，服务消费者接口定义和服务提供者的接口定义必须一致，例如，参数个数等等，这样的用法修改起来比较麻烦，所有提供了以下两种思路</p><ol><li>继承：给消费者的FeignClient和提供者的controller定义统一的父接口作为标准。（耦合度高）</li></ol><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221215145243158.png" alt="image-20221215145243158"></p><ol start="2"><li>抽取：将Feign提供的调用接口抽取成一个微服务模块，然后让这个模块对外提供服务接口，供给服务消费者调用。</li></ol><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221215145213059.png" alt="image-20221215145213059"></p><p><strong>实现Feign的抽取步骤如下</strong></p><ol><li>创建一个新的微服务模块（maven模块）</li><li>将服务提供者和服务消费者所需要的实体类、配置和调用接口放在feign-api的服务模块中</li><li>在服务消费者的模块引入依赖，注意在这一步中需要在@EnableFeignClients中添加一个参数，否则会在Springboot启动时报Bean找不到的错误，该参数是可以让组件扫描到feign-api模块中，从而成功的加载Bean对象，如下</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients(clients = &#123;在feign-api模块中的接口.class&#125;)</span> <span class="comment">//将feign-api的接口加载到此服务模块中</span></span><br></pre></td></tr></table></figure><h1 id="Gateway网关"><a href="#Gateway网关" class="headerlink" title="Gateway网关"></a>Gateway网关</h1><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221215160258517.png" alt="image-20221215160258517"></p><p>在SpringCloud中网关的实现包括两种:</p><ul><li>gateway</li><li>zuul</li></ul><p>Zuul是基于Servlet的实现，属于阻塞式编程。而SpringCloudGateway则是基于Spring5中提供的WebFlux，属于响应式编程的实现，具备更好的性能。</p><h2 id="开发网关的步骤"><a href="#开发网关的步骤" class="headerlink" title="开发网关的步骤"></a>开发网关的步骤</h2><p>先创建一个新的maven模块，引入nacos和注册发现的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注册发现依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 路由 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改配置参数，基本的配置如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10011</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment"># nacos地址</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://userService</span> <span class="comment"># 以lb是LoadBalance 负载均衡</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/user/**</span> <span class="comment"># 只要请求路径中有user，则将该请求引导userService服务中</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">order-service</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://orderService</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/order/**</span></span><br></pre></td></tr></table></figure><p>当上面的步骤做完之后即可直接访问网关的路径，网关会给你的请求进行一个引导访问你需要的资源。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221224150013734.png" alt="image-20221224150013734"></p><h2 id="路由过滤器GatewayFilter的配置"><a href="#路由过滤器GatewayFilter的配置" class="headerlink" title="路由过滤器GatewayFilter的配置"></a>路由过滤器GatewayFilter的配置</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10011</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment"># nacos地址</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://userService</span> <span class="comment"># 以lb是LoadBalance 负载均衡</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/user/**</span> <span class="comment"># 只要请求路径中有user，则将该请求引导userService服务中</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">filters:</span></span><br><span class="line">        <span class="comment"># 局部过滤器</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">order-service</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://orderService</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/order/**</span></span><br><span class="line">      <span class="attr">default-filters:</span> <span class="comment"># 默认路由过滤器，会对所有的请求生效，若需要局部，可以在指定的路由下配置</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">AddRequestHeader=name,zhangsan</span></span><br></pre></td></tr></table></figure><h2 id="网关的全局过滤器"><a href="#网关的全局过滤器" class="headerlink" title="网关的全局过滤器"></a>网关的全局过滤器</h2><p>全局过滤器的作用是什么?</p><ol><li>对所有路由都生效的过滤器，并且可以自定义处理逻辑</li></ol><p>实现全局过滤器的步骤?</p><ol><li>实现GlobalFilter接口</li><li>添加@Order注解或实现Ordered接口</li><li>编写处理逻辑</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 请求访问权限过滤器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Order(-1)</span> <span class="comment">//过滤的优先级</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthorizationFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理用户的请求</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exchange：可以获取到用户的请求头或者是响应头进行处理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> chain：用来放行请求的</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> m</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">        <span class="comment">//1. 获取ServerHttpRequest对象</span></span><br><span class="line">        <span class="type">ServerHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> exchange.getRequest();</span><br><span class="line">        <span class="comment">//2. 获取请求头</span></span><br><span class="line">        MultiValueMap&lt;String, String&gt; queryParams = request.getQueryParams();</span><br><span class="line">        <span class="comment">//3. 从请求头中通过键取出值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">authorization</span> <span class="operator">=</span> queryParams.getFirst(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">        <span class="comment">//4. 判断该请求头是否是admin权限的用户</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;admin&quot;</span>.equals(authorization)) &#123;</span><br><span class="line">            <span class="comment">//是，放行</span></span><br><span class="line">            <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置一下状态码</span></span><br><span class="line">        exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">        <span class="comment">//否，拦截</span></span><br><span class="line">        <span class="keyword">return</span> exchange.getResponse().setComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>路由过滤器、defaultFilter、全局过滤器的执行顺序?</p><ul><li><p>order值越小，优先级越高</p></li><li><p>当order值一样时，顺序是defaultFilter最先，然后是局部的路由过滤器，最后是全局过滤器</p></li></ul><h2 id="跨域请求问题"><a href="#跨域请求问题" class="headerlink" title="跨域请求问题"></a>跨域请求问题</h2><p>引起原因：客户端和服务器的域名不同或者是端口号不同导致的，跨域问题是游览器不允许页面对不同的域进行一个ajax的请求，但在服务端中就不存在该问题了。如下图所示是属于跨域请求</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221229162011088.png" alt="image-20221229162011088"></p><p>解决方案：CORS</p><p>只需要在网关下配置如下参数即可解决</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">globalcors:</span> <span class="comment">#全局的跨域处理</span></span><br><span class="line">        <span class="attr">add-to-simple-url-handler-mapping:</span> <span class="literal">true</span> <span class="comment">#解决options请求被拦截问题corsConfigurations:</span></span><br><span class="line">          <span class="string">&#x27;[/**]&#x27;</span><span class="string">:</span></span><br><span class="line">            <span class="attr">allowedOrigins:</span>  <span class="comment">#允许哪些网站的跨域请求</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;http://logalhost:8090&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;http://www.leyou.com&quot;</span></span><br><span class="line">            <span class="attr">allowedMethods:</span> <span class="comment">#允许的跨域ajax的请求方式</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;GET&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;POST&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;DELETE&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;PUT&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;OPTIONS&quot;</span></span><br><span class="line">            <span class="attr">allowedHeaders:</span> <span class="string">&quot;*&quot;</span> <span class="comment">#允许在请求中携带的头信息</span></span><br><span class="line">            <span class="attr">allowCredentials:</span> <span class="literal">true</span> <span class="comment">#是否允许携带</span></span><br><span class="line">            <span class="attr">cookiemaxAge:</span> <span class="number">360000</span> <span class="comment">#这次跨域检测的有效期s</span></span><br></pre></td></tr></table></figure><p>还有一种解决方案，添加一个Bean给IOC容器管理即可，让spring框架知道请求可以跨域即可。如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解决跨域请求问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GulimallCorsWebConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CorsWebFilter <span class="title function_">corsWebFilter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">UrlBasedCorsConfigurationSource</span> <span class="variable">source</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlBasedCorsConfigurationSource</span>();</span><br><span class="line">        <span class="comment">//配置跨域参数</span></span><br><span class="line">        <span class="type">CorsConfiguration</span> <span class="variable">configuration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorsConfiguration</span>();</span><br><span class="line">        configuration.setAllowedHeaders(Collections.singletonList(<span class="string">&quot;*&quot;</span>));</span><br><span class="line">        configuration.setAllowedMethods(Collections.singletonList(<span class="string">&quot;*&quot;</span>));</span><br><span class="line">        configuration.setAllowedOrigins(Collections.singlsetonList(<span class="string">&quot;*&quot;</span>));</span><br><span class="line">        <span class="comment">// 设置同意信任的url请求</span></span><br><span class="line">        configuration.setAllowCredentials(<span class="literal">true</span>);</span><br><span class="line">        source.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>,configuration);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CorsWebFilter</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><p><strong>项目部署问题：</strong>大型项目组件较多，运行环境也较为复杂，依赖关系复杂，容易出现兼容性问题。开发、测试、生产环境有差异</p><p><strong>Docker如何解决依赖兼容的问题？</strong></p><ul><li>Docker会将应用的Libs（函数库)、Deps（依赖)、配置与应用一起打包</li><li>将每个应用放到一个隔离容器去运行，避免互相干扰</li></ul><p>Docker是一个快速交付应用、运行应用技术。可以将程序及其依赖、运行环境一起打包为一个镜像，可以迁移到任意Linux操作系统，运行时利用沙箱机制形成隔离容器，各个应用互不干扰。启动、移除都可以通过一行命令完成，方便快捷</p><h2 id="Docker的架构"><a href="#Docker的架构" class="headerlink" title="Docker的架构"></a>Docker的架构</h2><p>Docker是采用C&#x2F;S的结构的程序，由两部分组成</p><ul><li>服务端(server)：Docker守护进程，负责处理Docker指令，管理镜像、容器等，DockerHup是Docker的服务器</li><li>客户端(client)：通过命令或RestAPI向Docker服务端发送指令。可以在本地或远程向服务端发送指令。</li></ul><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221229163742167.png" alt="image-20221229163742167"></p><h2 id="Docker的安装（Linux版本）"><a href="#Docker的安装（Linux版本）" class="headerlink" title="Docker的安装（Linux版本）"></a>Docker的安装（Linux版本）</h2><p>首先需要CentOS7的虚拟机</p><ol><li>安装yum的工具包，在控制台中输入以下命令即可</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils \</span><br><span class="line">          device-mapper-persistent-data \</span><br><span class="line">          lvm2 --skip-broken</span><br></pre></td></tr></table></figure><ol start="2"><li>更新本地镜像源</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager </span><br><span class="line">--add-repo \</span><br><span class="line">https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line">sed -i &#x27;s/down1oad.docker.com/mirrors.aliyun.com\/docker-ce/g&#x27; /etc/yum.repos.d/docker-ce.repo</span><br><span class="line"></span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure><ol start="3"><li>然后输入命令</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y docker-ce</span><br></pre></td></tr></table></figure><ol start="4"><li>安装完成后启动前需要关闭掉linux的防火墙，否则Docker会启动失败，关闭防火墙的命令如下</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭当前防火墙，但下一次开机会自启防火墙</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">永久关闭</span></span><br><span class="line">systemctl disable firewalld</span><br></pre></td></tr></table></figure><ol start="5"><li>启动Docker服务</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><ol start="6"><li>查看是否启动成功</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">若有版本号出现说明启动成功</span></span><br><span class="line">docker -v </span><br></pre></td></tr></table></figure><ol start="7"><li>因为Docker的服务器在国外，故下载速度很慢，可以配置到国内的服务器上（需要自己到阿里云官网去开通镜像服务）</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">先创建一个目录</span></span><br><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一个json文件</span></span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27; </span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://n0dwemtq.mirror.aliyunce.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启</span></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><h2 id="Docker的基本操作"><a href="#Docker的基本操作" class="headerlink" title="Docker的基本操作"></a>Docker的基本操作</h2><p><strong>镜像相关的命令如图所示</strong></p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221230095046053.png" alt="image-20221230095046053"></p><p>Docker的命令可以在控制台上进行查询通过如下命令即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker --help</span><br><span class="line">docker [具体的命令] --help</span><br></pre></td></tr></table></figure><p><strong>容器的相关命令</strong></p><p>docker exec：进入容器执行命令</p><p>docker logs：查看容器运行日志</p><p>docker ps：查看所有运行的容器及状态</p><p>docker rm：删除指定的容器</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221230101316509.png" alt="image-20221230101316509"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令解读</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker run：创建一个容器并运行</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--name containerName：起一个容器名称</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-p 80:80：端口映射，左是用户机的端口，右是服务器端口</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-d nginx：镜像名称</span></span><br><span class="line">docker run --name containerName -p 80:80 -d nginx</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令解读</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker <span class="built_in">exec</span> :进入容器内部，执行一个命令</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">it:给当前进入的容器创建一个标准输入、输出终端，允许我们与容器交互</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">mn :要进入的容器的名称</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">bash:进入容器后执行的命令，bash是一个linux终端交互命令</span></span><br><span class="line">docker exec -it mn bash</span><br></pre></td></tr></table></figure><p><strong>数据卷的相关命令</strong></p><p>数据卷的存在解决了：不便于修改，数据不可复用，升级维护困难</p><p>数据卷就是和容器内部的文件的映射，当数据卷修改时容器内部的文件也会修改。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker volume [comment]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">comment有如下选择</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">create：创建一个volume</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">inspect：显示一个或多个volume的信息</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ls</span>：列出所有的volume</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">prune：删除未使用的volume</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">rm</span>：删除一个或多个指定的volume</span></span><br></pre></td></tr></table></figure><p><strong>挂载数据卷</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在创建并运行容器时加上-v volumeName: /targetContainerPath即可,当volumeName不存在，会自动创建</span></span><br><span class="line">docker run --name containerName -p 80:80 -v volumeName: /targetContainerPath -d nginx</span><br></pre></td></tr></table></figure><h2 id="自定义镜像"><a href="#自定义镜像" class="headerlink" title="自定义镜像"></a>自定义镜像</h2><p><strong>镜像结构是分层的结构，每一层都有自己的配置</strong></p><p>Baselmage层：包含基本的系统函数库、环境变量、文件系统</p><p>Entrypoint：入口，是镜像中应用启动的命令</p><p>其它在Baselmage基础上添加依赖、安装程序、完成整个应用的安装和配置</p><p><strong>自定义镜像的步骤如下</strong></p><ol><li><p>首先定义一个自定义文件，该文件是描述镜像构建的过程</p></li><li><p>该文件的第一行必须是FROM，是从哪一层开始构建的</p></li><li><p>基础镜像可以是ubuntu也可以是别构建好的镜像java:8-alpine</p></li><li><p>准备好项目运行的压缩包并放到同一目录中</p></li><li><p>最后运行如下命令即可构建一个镜像</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t imageName:version .</span><br></pre></td></tr></table></figure><p><strong>自定义文件的构建</strong></p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221230170937335.png" alt="image-20221230170937335"></p><p>自动补全命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -L \</span><br><span class="line">https://raw.githubusercontent.com/docker/compose/1.29.1/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose</span><br></pre></td></tr></table></figure><p>修改域名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;199.232.68.133 raw.githubusercontent.com&quot; &gt;&gt; /etc/hosts</span><br></pre></td></tr></table></figure><h2 id="镜像仓库"><a href="#镜像仓库" class="headerlink" title="镜像仓库"></a>镜像仓库</h2><ul><li><p>公有仓库：DockerHub–&gt;<a href="https://hub.docker.com/">Docker</a></p></li><li><p>私有仓库：需要自己搭建</p></li></ul><p><strong>搭建私有仓库的步骤如下</strong></p><ol><li>首先创建一个文件取名：docker-compose.yml</li><li>在配置一下daemen.json的文件，顺序执行以下命令即可，目的是为了让你创建的仓库被信任</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打开要修改的文件</span></span><br><span class="line">vi /etc/docker/daemon.json</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加内容：端口号是自己电脑或虚拟机的ip</span></span><br><span class="line">&quot;insecure-registries&quot;:[&quot;http://192.168.177.131:8088&quot;] </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重加载</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启docker</span></span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><ol start="3"><li>在docker-compose.yml中的内容如下</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">version: &#x27;3.0&#x27;</span><br><span class="line">services:</span><br><span class="line">  registry:</span><br><span class="line">    image: registry</span><br><span class="line">    volumes:</span><br><span class="line">      - ./registry-data:/var/lib/registry</span><br><span class="line">  ui:</span><br><span class="line">    image: joxit/docker-registry-ui:static</span><br><span class="line">    ports:</span><br><span class="line">      - 8088:80 # 左边的端口号是为了让外界访问此仓库的，可以修改</span><br><span class="line">    environment: </span><br><span class="line">      - REGISTRY_TITLE=RegistryOfMysties # 可以顺便起个仓库名称</span><br><span class="line">      - REGISTRY_URL=http://registry:5000</span><br><span class="line">    depends_on:</span><br><span class="line">      - registry</span><br></pre></td></tr></table></figure><ol start="4"><li>但上面的配置做完之后，再执行以下命令启动</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看启动日志</span></span><br><span class="line">docker-compose logs -f</span><br></pre></td></tr></table></figure><ol start="5"><li>然后在游览器访问</li></ol><p><strong>私有仓库镜像的相关操作</strong></p><p>推送镜像到私有镜像服务必须先tag，步骤如下：</p><ol><li>重新命名镜像名称，名称前缀是私有仓库的ip，例如：192.168.177.131:8088&#x2F;</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag nginx:latest 192.168.177.131:8088/nginx:1.0</span><br></pre></td></tr></table></figure><ol start="2"><li>推送本地镜像到私有仓库</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push 192.168.177.131:8088/nginx:1.0</span><br></pre></td></tr></table></figure><ol start="3"><li>从私有仓库中拉取镜像</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull 192.168.177.131:8088/nginx:1.0</span><br></pre></td></tr></table></figure><h1 id="MQ（MessageQueue）"><a href="#MQ（MessageQueue）" class="headerlink" title="MQ（MessageQueue）"></a>MQ（MessageQueue）</h1><p><strong>同步调用：</strong>就是每增加一个新的业务时，都需要新增一个远程调用到其它的微服务实例上，所以该调用方式存在的问题，耦合度高，性能下降，资源浪费，级联失败。</p><p>异步调用会解决同步调用的问题，单异步也有缺点：依赖于Broker的可靠性、安全性、吞吐能力，架构复杂了，业务没有明显的流程线，不好追踪管理</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221231141749235.png" alt="image-20221231141749235"></p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221231142431990.png" alt="image-20221231142431990"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;认识微服务&quot;&gt;&lt;a href=&quot;#认识微服务&quot; class=&quot;headerlink&quot; title=&quot;认识微服务&quot;&gt;&lt;/a&gt;认识微服务&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;单体架构：将业务的所有功能集中在一个项目中开发，打成一个包部署。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：</summary>
      
    
    
    
    
    <category term="springcloud" scheme="http://example.com/tags/springcloud/"/>
    
  </entry>
  
  <entry>
    <title>java模拟进程运行</title>
    <link href="http://example.com/2022/11/23/java%E6%A8%A1%E6%8B%9F%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C/"/>
    <id>http://example.com/2022/11/23/java%E6%A8%A1%E6%8B%9F%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C/</id>
    <published>2022-11-23T12:09:00.000Z</published>
    <updated>2023-01-30T09:32:37.223Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java模拟进程程序流程图和概述"><a href="#java模拟进程程序流程图和概述" class="headerlink" title="java模拟进程程序流程图和概述"></a>java模拟进程程序流程图和概述</h1><ul><li><p>进程的概述</p><p>​进程是正在执行的程序是动态资源，而程序是静态资源，进程运行需要占用CPU的使用权，进程中有多个线程，进程中的资源可以被多个线程共享。更多详情请看java基础中的并发编程</p></li><li><p>进程并发执行</p><p>​进程并发执行可以从两个角度进行说明：</p><p><strong>宏观角度：</strong> 进程的并发性是指一组进程的执行在时间上是重叠的。所谓执行在时间上是重叠的，是指一个进程执行的第一条指令是在另一个进程执行的最后一条指令完成之前开始的。例如，现有进程A和进程B分别执行（a1，a2，a3）和（b1，b2，b3）这六个资源，在单处理机上这六个资源是交叉顺序执行的，假设进程A执行完a1后，CPU的使用权被进程B占用，进程B就开始执行b1，依次推理，可能的执行顺序是：a1 ，b1，a2，b2，b3，a4 等多种情况，并且程序运行是非常快的，所以给人一种错觉，进程是并发执行的。</p><p><strong>微观角度：</strong> 在单处理机上，处理机只能处理一个进程，反过来看，并发的实质是对一个处理机对多个进程之间的多路复用。</p></li><li><p>进程执行的三种基本状态</p><p>​在进程中有执行、就绪、堵塞这三种基本状态。如下图所示</p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221123212927162.png" alt="image-20221123212927162" style="zoom:50%;" /><p>​在本次模拟只模拟进程的从就绪状态到执行状态。</p></li><li><p>java模拟进程执行流程图</p><p>​思路简要说明：采用优先队列当做就绪队列，假设进程是以优先级高的先执行，优先级相等的采用FIFO法顺序执行，关于进程优先级可以百度了解（dogs）</p></li></ul><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/4BDVW7FQK76GRC~63BEPRXO.png" alt="4BDVW7FQK76GRC~63BEPRXO" style="zoom: 80%;" /><ul><li>java代码实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  模拟多进程运行</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@author</span> mysticBoy</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@creatTime</span> 2022/11/21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PCB_Experiment</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;PCB&gt; pcbs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 创建进程的数量</span></span><br><span class="line">        pcbs.add(<span class="keyword">new</span> <span class="title class_">PCB</span>(<span class="string">&quot;进程1&quot;</span>,<span class="number">10</span>,<span class="number">45</span>,<span class="number">0</span>));</span><br><span class="line">        pcbs.add(<span class="keyword">new</span> <span class="title class_">PCB</span>(<span class="string">&quot;进程2&quot;</span>,<span class="number">5</span>,<span class="number">30</span>,<span class="number">0</span>));</span><br><span class="line">        pcbs.add(<span class="keyword">new</span> <span class="title class_">PCB</span>(<span class="string">&quot;进程3&quot;</span>,<span class="number">7</span>,<span class="number">40</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 创建进程的执行对象并将进程放入到进程执行中</span></span><br><span class="line">        <span class="type">PcbExecute</span> <span class="variable">execute</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PcbExecute</span>(pcbs);</span><br><span class="line">        <span class="comment">// 进程执行</span></span><br><span class="line">        execute.executing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 进程执行类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PcbExecute</span>&#123;</span><br><span class="line">    <span class="comment">//就绪队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;PCB&gt; queue;</span><br><span class="line">    <span class="comment">//初始化队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PcbExecute</span><span class="params">(List&lt;PCB&gt; pcbList)</span> &#123;</span><br><span class="line">        queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;( <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;PCB&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(PCB o1, PCB o2)</span> &#123;</span><br><span class="line">                <span class="comment">//队列以进程优先级数进行排序</span></span><br><span class="line">                <span class="keyword">return</span> o2.getPriority() - o1.getPriority();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 将进程列表中的加入到队列中</span></span><br><span class="line">        queue.addAll(pcbList);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 进程执行方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executing</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 获取队列的迭代器</span></span><br><span class="line">        Iterator&lt;PCB&gt; iterator = queue.iterator();</span><br><span class="line">        <span class="comment">// 通过迭代器遍历队列中的每个进程</span></span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="comment">// 1. 获取出优先级最高的进程</span></span><br><span class="line">            <span class="type">PCB</span> <span class="variable">currPcb</span>  <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">assert</span> currPcb != <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 2. 减少当前进程的优先级</span></span><br><span class="line">            currPcb.setPriority(currPcb.getPriority() - <span class="number">3</span>);</span><br><span class="line">            <span class="comment">// 4. 判断该进程是否执行完毕 即 totalTime 是否执行完</span></span><br><span class="line">            <span class="keyword">if</span>(currPcb.getTotalTime() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 4.1 减少当前进程的所需运行时间片数</span></span><br><span class="line">                currPcb.setTotalTime(currPcb.getTotalTime() - <span class="number">1</span>);</span><br><span class="line">                currPcb.setOccupyTime(currPcb.getOccupyTime() + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 4.2 修改进程的状态</span></span><br><span class="line">                currPcb.setState(<span class="number">3</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 说明当前进程结束</span></span><br><span class="line">                currPcb.setState(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 直接将该进程加回就绪队列中</span></span><br><span class="line">            queue.add(currPcb);</span><br><span class="line">            <span class="comment">// 打印进程的信息</span></span><br><span class="line">            queue.forEach(pcb -&gt; &#123;</span><br><span class="line">                <span class="keyword">switch</span> (pcb.getState()) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                        System.out.println(pcb.getPcbName() + <span class="string">&quot;-&gt;已结束...  &quot;</span> + <span class="string">&quot;  需要时间片：&quot;</span> + pcb.getTotalTime()</span><br><span class="line">                           + <span class="string">&quot;  占用CPU时间片：&quot;</span> + pcb.getOccupyTime() + <span class="string">&quot;  优先级：&quot;</span> + pcb.getPriority());</span><br><span class="line">                        <span class="comment">// 将结束的进程从就绪队列中移除</span></span><br><span class="line">                        queue.remove(pcb);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                        System.out.println(pcb.getPcbName()+<span class="string">&quot;-&gt;就绪中...  &quot;</span> +<span class="string">&quot;  需要时间片：&quot;</span> + pcb.getTotalTime()</span><br><span class="line">                          + <span class="string">&quot;  占用CPU时间片：&quot;</span> + pcb.getOccupyTime() + <span class="string">&quot;  优先级：&quot;</span> + pcb.getPriority());</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                        System.out.println(pcb.getPcbName()+<span class="string">&quot;-&gt;运行中...  &quot;</span> +<span class="string">&quot;  需要时间片：&quot;</span> + pcb.getTotalTime()</span><br><span class="line">                           + <span class="string">&quot;  占用CPU时间片：&quot;</span> + pcb.getOccupyTime() + <span class="string">&quot;  优先级：&quot;</span> + pcb.getPriority());</span><br><span class="line">                        pcb.setState(<span class="number">2</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">      System.out.println(<span class="string">&quot;============================================================&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 进程类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PCB</span>&#123;</span><br><span class="line">    <span class="comment">// 进程名称</span></span><br><span class="line">    <span class="keyword">private</span> String pcbName;</span><br><span class="line">    <span class="comment">// 进程状态：0——结束，1——等待，2——就绪，3——运行</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">state</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 进程执行所需的时间片数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> totalTime;</span><br><span class="line">    <span class="comment">// 优先级：优先级越高，就优先执行</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> priority;</span><br><span class="line">    <span class="comment">// 进程占用CPU总时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> occupyTime;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PCB</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PCB</span><span class="params">(String pcbName, <span class="type">float</span> totalTime, <span class="type">int</span> priority, <span class="type">float</span> occupyTime)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.pcbName = pcbName;</span><br><span class="line">        <span class="built_in">this</span>.totalTime = totalTime;</span><br><span class="line">        <span class="built_in">this</span>.priority = priority;</span><br><span class="line">        <span class="built_in">this</span>.occupyTime = occupyTime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPcbName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pcbName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPcbName</span><span class="params">(String pcbName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.pcbName = pcbName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">getTotalTime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> totalTime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTotalTime</span><span class="params">(<span class="type">float</span> totalTime)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.totalTime = totalTime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getPriority</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> priority;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPriority</span><span class="params">(<span class="type">int</span> priority)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.priority = priority;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">getOccupyTime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> occupyTime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOccupyTime</span><span class="params">(<span class="type">float</span> occupyTime)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.occupyTime = occupyTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行结果如下图（由于运行结果太多只截取一部分）</li></ul><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221123214808069.png" alt="image-20221123214808069"></p><ul><li>总结：在微观角度中进程是逐个交叉运行的方式。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;java模拟进程程序流程图和概述&quot;&gt;&lt;a href=&quot;#java模拟进程程序流程图和概述&quot; class=&quot;headerlink&quot; title=&quot;java模拟进程程序流程图和概述&quot;&gt;&lt;/a&gt;java模拟进程程序流程图和概述&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;进程的概述</summary>
      
    
    
    
    
    <category term="java，进程，多线程" scheme="http://example.com/tags/java%EF%BC%8C%E8%BF%9B%E7%A8%8B%EF%BC%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>java基础（节选）</title>
    <link href="http://example.com/2022/11/23/java%E5%9F%BA%E7%A1%80%EF%BC%88%E8%8A%82%E9%80%89%EF%BC%89/"/>
    <id>http://example.com/2022/11/23/java%E5%9F%BA%E7%A1%80%EF%BC%88%E8%8A%82%E9%80%89%EF%BC%89/</id>
    <published>2022-11-22T16:00:00.000Z</published>
    <updated>2023-02-26T06:19:02.761Z</updated>
    
    <content type="html"><![CDATA[<h1 id="异常的作用"><a href="#异常的作用" class="headerlink" title="异常的作用"></a>异常的作用</h1><ol><li>提高程序的健壮性和安全性。</li><li>可以处理代码问题，防止程序出现问题后的死亡。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 程序校验年龄是否正确</span></span><br><span class="line">                <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">                System.out.print(<span class="string">&quot;请输入年龄：&quot;</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">                <span class="keyword">if</span>(age &lt; <span class="number">0</span> || age &gt; <span class="number">200</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;输入正确：&quot;</span> + age);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;年龄输入错误~~&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221123145110280.png" alt="image-20221123145110280"></p><ol start="3"><li>以上代码就是异常的实用之处，可以让出现异常的代码继续执行。</li></ol><h1 id="多线程和并发编程"><a href="#多线程和并发编程" class="headerlink" title="多线程和并发编程"></a>多线程和并发编程</h1><h2 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程?"></a>什么是进程?</h2><p>程序是静止的，运行中的程序就是进程。并行是 同一个时刻同时有多个在执行。</p><p>进程的三个特征:</p><p>（ 1 ）动态性： 进程是运行中的程序，要动态的占用内存，CPU和网络等资源。</p><p>（ 2 ）独立性： 进程与进程之间是相互独立的，彼此有自己的独立内存区域。</p><p>（ 3 ）并发性： 假如CPU是单核，同一个时刻其实内存中只有一个进程在被执行。CPU会分时轮询切换依次为每个进程服务，因为切换的速度非常快，给我们的感觉这些进程在同时执行，这就是并发性。</p><h2 id="什么是线程？"><a href="#什么是线程？" class="headerlink" title="什么是线程？"></a>什么是线程？</h2><ol><li>线程是属于进程的。</li><li>一个进程可以包含多个线程，这就是多线程。线程是进程中的一个独立执行单元。</li><li>线程创建开销相对于进程来说比较小。线程也支持并发性。</li></ol><p>线程的作用：</p><ol><li>可以提高程序的效率，线程也支持并发性，可以有更多机会得到CPU。多线程可以解决很多业务模型。</li><li>大型高并发技术的核心技术。</li><li>设计到多线程的开发可能都比较难理解。</li></ol><h2 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h2><h3 id="继承Thread类创建（方式一）"><a href="#继承Thread类创建（方式一）" class="headerlink" title="继承Thread类创建（方式一）"></a>继承Thread类创建（方式一）</h3><ol><li><p>定义一个线程类继承并继承Thread类</p></li><li><p>重写run方法，在run方法中可以编写代码业务</p></li><li><p>创建该线程对象</p></li><li><p>调用对象中的start()方法，开启新的线程并执行业务</p><p>继承Thread的缺点：</p><p> 优点：编码简单</p><p> 缺点：线程类已经继承了Thread类无法继承其他类了，功能不能通过继承拓展（单继承）</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="comment">// 1. main是一个主进程，在main中可以运行多个线程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建线程对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">myThread</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="comment">//开启线程：start会给myThread注册进入CPU中，会与主进程竞争CPU的执行权</span></span><br><span class="line">        myThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;主进程：&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建一个线程类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="comment">//重写run方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;分支线程：&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现Runnable接口创建线程（方式二）"><a href="#实现Runnable接口创建线程（方式二）" class="headerlink" title="实现Runnable接口创建线程（方式二）"></a>实现Runnable接口创建线程（方式二）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//3. 创建MyRunnable对象</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">run</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">        <span class="comment">//4. 创建Thread方法执行线程业务</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(run,<span class="string">&quot;run1&quot;</span>);</span><br><span class="line">        <span class="comment">//开启线程任务</span></span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1. 定义一个类实现Runnable接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">//2. 重写run方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>缺点:代码复杂一点。</p></li><li><p>优点：</p></li></ol><p>避免了单继承的局限性</p><p>同一个线程任务对象可以被包装成多个线程对象</p><p>适合多个多个线程去共享同一个资源</p><p>实现解耦操作，线程任务代码可以被多个线程共享，线程任务代码和线程独立。</p><p>线程池可以放入实现Runable或callable线程任务对象。</p><p><strong>注意：其实Thread类本身也是实现了Runnable接口的。</strong></p><h3 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h3><p>线程安全的说明：如下图</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221123155806551.png" alt="image-20221123155806551"></p><p>上图解析：假设小明和小红的账户余额为100000，当小明和小红一起去银行取钱，那么小明和小红取钱的行为可以看成两个进程进行取钱的操作，由于进程的并发性和CPU执行权的随机分配，会导致程序执行判断小明账户是否有余额，这时为true并且账户余额未被取出，这时小红也来取钱，程序的执行权被小红占用，这时判断是否有余额，也是true，然后小明和小红在同一个账户取了两次的钱，导致用户钱为负数，这就发生了线程安全问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  线程安全问题的演示</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 账户类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> cardId;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> money;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="comment">//判断是谁来取钱</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">        <span class="comment">//判断是否还有余额</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.money &gt;= money) &#123;</span><br><span class="line">            <span class="comment">//还有余额</span></span><br><span class="line">            System.out.println(name + <span class="string">&quot;取出 &quot;</span> + money);</span><br><span class="line">            <span class="comment">//扣减余额</span></span><br><span class="line">            <span class="built_in">this</span>.money = <span class="built_in">this</span>.money - money;</span><br><span class="line">            System.out.println(<span class="string">&quot;余额剩余：&quot;</span> + <span class="built_in">this</span>.money);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//余额不足</span></span><br><span class="line">            System.out.println(<span class="string">&quot;余额不足...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(<span class="type">long</span> cardId, <span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cardId = cardId;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getCardId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cardId;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCardId</span><span class="params">(<span class="type">long</span> cardId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cardId = cardId;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//取钱的线程类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DrawingMoney</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Account account;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DrawingMoney</span><span class="params">(Account account,String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.account = account;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//取钱的业务</span></span><br><span class="line">        account.drawMoney(account.getMoney());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PCBSecurity</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//初始化一个账户</span></span><br><span class="line">        <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>(<span class="number">101</span>,<span class="number">10000</span>);</span><br><span class="line">        <span class="comment">//小明来取钱的线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">xiaoming</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DrawingMoney</span>(account,<span class="string">&quot;小明&quot;</span>);</span><br><span class="line">        xiaoming.start();</span><br><span class="line">        <span class="comment">//小红来取钱</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">xiaohong</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DrawingMoney</span>(account,<span class="string">&quot;小红&quot;</span>);</span><br><span class="line">        xiaohong.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​<strong>运行结果如下</strong></p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221123163012728.png"></p><h3 id="解决线程安全问题"><a href="#解决线程安全问题" class="headerlink" title="解决线程安全问题"></a>解决线程安全问题</h3><p>同步代码块锁synchronized(this)：在共享资源加同步锁，以保证小明和小红能逐个从账户中取钱，代码如下，其中this对象必须保证唯一性，来保证锁的唯一</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">    <span class="comment">//判断是谁来取钱</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">    <span class="comment">//账户类就是共享资源，已账户类为加锁的标志，同一个账户只能有一个人进来取钱</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">       <span class="comment">//判断是否还有余额</span></span><br><span class="line">       <span class="keyword">if</span>(<span class="built_in">this</span>.money &gt;= money) &#123;</span><br><span class="line">           <span class="comment">//还有余额</span></span><br><span class="line">           System.out.println(name + <span class="string">&quot;取出 &quot;</span> + money);</span><br><span class="line">           <span class="comment">//扣减余额</span></span><br><span class="line">           <span class="built_in">this</span>.money = <span class="built_in">this</span>.money - money;</span><br><span class="line">           System.out.println(<span class="string">&quot;余额剩余：&quot;</span> + <span class="built_in">this</span>.money);</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//余额不足</span></span><br><span class="line">           System.out.println(<span class="string">&quot;余额不足...&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221123165517823.png" alt="image-20221123165517823"></p><p><strong>同步方法：</strong>在对操作共享资源的方法上加上synchronized即可加锁，在方法执行完毕后，自动释放锁。</p><p>原理： 同步方法的原理和同步代码块的底层原理其实是完全一样的，只是同步方法是把整个方法的代码都锁起来的。同步方法上锁的范围比同步代码块大，而且加锁的范围太大会大大降低执行的性能，故在加锁时可以优先考虑同步代码块，加锁范围越精确，对性能影响就越小<br>        同步方法其实底层也是有锁对象的:<br>            如果方法是实例方法：同步方法默认用this作为的锁对象。<br>            如果方法是静态方法：同步方法默认用类名.class作为的锁对象。</p><p><strong>Lock锁方法：</strong></p><p>​Lock锁的优点：上锁的灵活性更好。</p><p>注意：  使用该方法上锁一定需要把解锁放到finnally的代码块中。因为在finnally中无论是否出现异常都会执行，所以在finnally可以保证解锁的操作，防止死锁的出现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> cardId;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> money;</span><br><span class="line">    <span class="comment">//创建一个lock锁对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="comment">//判断是谁来取钱</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">        <span class="comment">//上锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//判断是否还有余额</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.money &gt;= money) &#123;</span><br><span class="line">                <span class="comment">//还有余额</span></span><br><span class="line">                System.out.println(name + <span class="string">&quot;取出 &quot;</span> + money);</span><br><span class="line">                <span class="comment">//扣减余额</span></span><br><span class="line">                <span class="built_in">this</span>.money = <span class="built_in">this</span>.money - money;</span><br><span class="line">                System.out.println(<span class="string">&quot;余额剩余：&quot;</span> + <span class="built_in">this</span>.money);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//余额不足</span></span><br><span class="line">                System.out.println(<span class="string">&quot;余额不足...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//解锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(<span class="type">long</span> cardId, <span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cardId = cardId;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getCardId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cardId;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCardId</span><span class="params">(<span class="type">long</span> cardId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cardId = cardId;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221124160355767.png" alt="image-20221124160355767"></p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>概述： 线程池是一个可以容纳多个线程的容器，其中的线程可以被反复的使用，从而减少了对线程对象的创建和销毁，提高了系统资源的利用率，防止创建过多的线程而导致系统的僵死。</p><p>核心思想： 线程复用。</p><p>以下代码是最基本的线程池用法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="comment">//创建一个线程池，其中的参数是创建几个线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建线任务对象</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="comment">//将任务加入线程池中，线程池会自动帮我们创建新的线程去执行任务</span></span><br><span class="line">        pool.submit(task);</span><br><span class="line">        pool.submit(task);</span><br><span class="line">        pool.submit(task); <span class="comment">//注意：此时的线程是复用前面创建的线程，因为在pool中只有2个线程</span></span><br><span class="line">         <span class="comment">// 关闭线程池</span></span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义一个线程任务类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//线程任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221124170402567.png" alt="image-20221124170402567"></p><p>在上图的运行结果可以看出线程池中始终只有两个线程在执行，分别是thread-1和thread-2</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>概述： 死锁是程序执行中的一种情况，多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p><p><strong>死锁产生的四个必要条件</strong></p><p>（1）互斥使用，即当资源被一个线程使用(占有)时，别的线程不能使用。</p><p>（2）不可抢占，资源请求者不能强制从资源占有者手中夺取资源，资源只能由资源占有者主动释放。</p><p>（3）请求和保持，即当资源请求者在请求其他的资源的同时保持对原有资源的占有。</p><p>（4）循环等待，即存在一个等待循环队列，p1要p2的资源，p2要p1的资源。这样就形成了一个等待环路</p><p>当上述四个条件都成立的时候，便形成死锁。当然，死锁的情况下如果打破上述任何一个条件，便可让死锁消失，以下是死锁的代码演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 死锁问题：死锁问题常产生在嵌套加锁上</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeathLock</span> &#123;</span><br><span class="line">    <span class="comment">//定义两个资源</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">source1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">source2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//这里使用匿名内部类实现线程的执行</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123; <span class="comment">//第一个线程</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (source1)&#123;</span><br><span class="line">                    <span class="comment">//拿到资源1</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;线程1拿到资源1，请求资源2&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//因为产生死锁是概率问题，故为了100%产生死锁，让该线程休眠1s，让线程2可以执行</span></span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">synchronized</span> (source2) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;线程1拿到资源2，可以释放资源了&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123; <span class="comment">//第二个线程</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (source2)&#123;</span><br><span class="line">                    <span class="comment">//拿到资源1</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;线程2拿到资源2，请求资源1&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//因为产生死锁是概率问题，故为了100%产生死锁，让该线程休眠1s，让线程1可以执行</span></span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">synchronized</span> (source1) &#123; </span><br><span class="line">                        System.out.println(<span class="string">&quot;线程2拿到资源1，可以释放资源了&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221124174017855.png" alt="image-20221124174017855"></p><h2 id="并发环境下，多线程访问变量的不可见性"><a href="#并发环境下，多线程访问变量的不可见性" class="headerlink" title="并发环境下，多线程访问变量的不可见性"></a>并发环境下，多线程访问变量的不可见性</h2><p>概述： 多个线程访问同一个变量，会出现器中一个线程修改变量的值后，其它线程看不到变量的最新值。以下代码可以说明该问题，在以下代码中MyThread子线程是先执行的，理论上应该先将flag &#x3D; true，而主线程会一直打印hello world…，然而结果并非如此。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; <span class="comment">//执行线程任何</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//这里是为了模拟业务代码的执行了一段时间后</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        flag = <span class="literal">true</span>; <span class="comment">//改变flag标志</span></span><br><span class="line">        System.out.println(<span class="string">&quot;flag已经变为true了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFlag</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFlag</span><span class="params">(<span class="type">boolean</span> flag)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.flag = flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnableVision</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个子线程对象并开启线程任务的执行</span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        t.start();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//休眠，保证子线程先执行</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//主线程执行的任务</span></span><br><span class="line">        <span class="keyword">while</span> (t.isFlag()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello world...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码运行结果如下：可以看出在主线程中读取的flag并不为true，但子线程已将flag置为true了，这就是多线程下对共同变量值的不可见性（概率问题）。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221124204337248.png" alt="image-20221124204337248"></p><h3 id="多线程中变量不可见性的原因"><a href="#多线程中变量不可见性的原因" class="headerlink" title="多线程中变量不可见性的原因"></a>多线程中变量不可见性的原因</h3><p>JVM虚拟机对多线程内存作以下规定</p><p>（ 1 ）所有的共享变量都存储于主内存。这里所说的变量指的是实例变量和类变量。不包含局部变量，因为局部变量是线程私有的，因此不存在竞争问题。</p><p>（ 2 ）每一个线程还存在自己的工作内存，线程的工作内存，保留了被线程使用的变量的工作副本。</p><p>（ 3 ）线程对变量的所有的操作(读，取)都必须在工作内存中完成，而不能直接读写主内存中的变量。</p><p>（ 4 ）不同线程之间也不能直接访问对方工作内存中的变量，线程间变量的值的传递需要通过主内存中转来完成。</p><p><strong>下图是本地内存和主内存的关系</strong></p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221124210145669.png" alt="image-20221124210145669" style="zoom:67%;" /><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221124210500313.png" alt="image-20221124210500313" style="zoom:67%;" /><p>个人解读： 在第二张图中，首先变量flag在主内存中默认为false，随后键flag分配到子线程和主线程工作内存中，这时各线程的flag是为false值，其次子线程t执行后将flag改为true，将其返回主内存中，此时主内存flag也是true，但由于JVM的规定，主线程中的工作内存中的flag仍为false，所有在主线程执行时读取的速度非常快，还来不及将flag值更新，主线程就已经读取了旧值，就导致了多线程下变量的不可见性。</p><p><strong>总结：并发编程下，多线程修改变量，会出现线程间变量的不可见性。</strong></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>加锁：因为加锁的操作会清空工作内存中的值，从主内存中读取最新的值，如下代码，给主线程加锁后会清空工作内存，从而使主线程从主内存中读取读取最小的flag值，就可以触发hello world的打印</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主线程执行的任务</span></span><br><span class="line"><span class="keyword">synchronized</span> (UnableVision.class) &#123; </span><br><span class="line">    <span class="keyword">while</span> (t.isFlag()) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221124213059050.png" alt="image-20221124213059050"></p><p>用volatile修饰公共变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>原理图如下</p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221124213834640.png" alt="image-20221124213834640" style="zoom:67%;" /><p>个人解读：volatile关键字并不是将个线程的工作内存清空，而是在某个线程中改变了共同变量值后，有volatile关键字修饰的变量就会通知其它线程该变量更新了，你那个变量是旧值，然后线程会将该变量视为失效的变量值，再从主内存中读取最新值，从而实现各个线程之间变量的可见性。</p><p><strong>volatile与synchronized的区别</strong></p><p>（ 1 ）volatile只能修饰实例变量和类变量，而synchronized可以修饰方法，以及代码块。</p><p>（ 2 ）volatile保证数据的可见性，但是不保证原子性(多线程进行写操作，不保证线程安全);</p><p>（ 3 ）而synchronized是一种排他(互斥)的机制，可以保证线程安全。</p><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>概述：原子性就是一批程序操作看成一个整体，要么执行，要么不执行。</p><p>以下代码是证明volatile不能保证原子性（线程安全问题），以下代码执行的结果理论上count应该为10000，但结果却是不到10000，这是属于线程任务未全执行完成导致的，故volatile并不能保证原子性。该运行结果是概率问题，多运行几次会出现不同的效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建线程对象</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VThread</span>();</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">           <span class="comment">//启动子线程100次</span></span><br><span class="line">           <span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">           count ++;</span><br><span class="line">           System.out.println(<span class="string">&quot;count=&quot;</span> + count);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221125195603121.png" alt="image-20221125195603121"></p><h3 id="保证原子性的方案"><a href="#保证原子性的方案" class="headerlink" title="保证原子性的方案"></a>保证原子性的方案</h3><p>加锁</p><ul><li><p>优点：实现简单</p></li><li><p>缺点：在高并发的环境下性能会变差</p></li></ul><p>如下的代码是再循环加前加上一个同步代码块锁，即可保证原子性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        System.out.println(<span class="string">&quot;count=&quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221126103607905.png" alt="image-20221126103607905"></p><p>使用原子类</p><ul><li><p>Atomiclnteger是JDK1.5版本后提供的原子类，该类的API接口可以查看API文档。</p></li><li><p>优点：性能高效，线程安全</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个原子类，其中参数是默认值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// incrementAndGet()是自动加1 并返回值</span></span><br><span class="line">            System.out.println(<span class="string">&quot;count=&quot;</span> + count.incrementAndGet());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221126104410355.png" alt="image-20221126104410355"></p><p><strong>原子类底层原理：</strong>在原子类源码中并不是以加锁的形式保证原子性，而是利用CSA法保证原子性，那什么是CSA呢？</p><p><strong>CAS的全名是：Compare And Swap(比较再交换)；是现代CPU广泛支持的一种对内存中的共享数据进行操作的一种特殊指令。CAS可以将read-modify-check-write转换为原子操作，这个原子操作直接由处理器保证。</strong></p><p>CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。</p><p><strong>个人理解</strong>：下图中的前提。因为线程执行顺序是有随机性的，假定进程1先执行读取值，再线程2执行读取值操作，在这种情况下若没有采取措施是会破坏原子性的。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221126111827373.png" alt="image-20221126111827373"></p><p>CSA和synchronized</p><ul><li><p>共同点： 都可以保证共享数据的安全性(原子性)</p></li><li><p>区别：CAS是没有加锁的，性能较好。（乐观锁）</p></li><li><p>synchronized是加锁操作，性能较差（悲观锁）</p></li></ul><h2 id="并发包"><a href="#并发包" class="headerlink" title="并发包"></a>并发包</h2><p>并发包是JDK本身自带的包，里面提供了很多的类供我我们使用，以下是比较常用的类。</p><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p><strong>概述：</strong>Map集合中的经典集合:HashMap它是【线程不安全】的，性能好。如果在要求线程安全的业务情况下就不能用这个集合做Map集合，否则业务会崩溃，为了保证线程安全，可以使用Hashtable。Hashtable是线程安全的Map集合，但是性能较差！(已经被淘汰了，虽然安全，但是性能差)，HashTable的底层源码所有方法都有加锁。ConcurrentHashMap集合，是性能较好，线程安全，最新的集合类。</p><ol start="2"><li>下代码是证明HashMap的线程不安全</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * map集合的线程安全测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapTest</span> &#123;</span><br><span class="line">    <span class="comment">//测试HashMap的线程安全</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建两个线程t1 和 t2</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyThread</span>(), <span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyThread</span>(), <span class="string">&quot;线程2&quot;</span>);</span><br><span class="line">        <span class="comment">// 开启线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">// 保证t1和t2执行完成后再打印</span></span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        <span class="comment">// map长度的理论上应为100000</span></span><br><span class="line">        System.out.println(<span class="string">&quot;map的长度&quot;</span> + map.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50000</span>; i++) &#123;</span><br><span class="line">            MapTest.map.put(Thread.currentThread().getName() + i,Thread.currentThread().getName() + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221126124300277.png" alt="image-20221126124300277"></p><p>Hashtable和ConcurrentHashMap集合的效率比较</p><p><strong>测试Hashtable的执行时间为多少</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String,String&gt; map = <span class="keyword">new</span> <span class="title class_">Hashtable</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221126125645268.png" alt="image-20221126125645268"></p><p><strong>测试ConcurrentHashMap测试时间多少</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String,String&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221126125801439.png" alt="image-20221126125801439"></p><p>如上图结果所示ConcurrentHashMap性能较好，那为何ConcurrentHashMap性能比Hashtable好呢？</p><p><strong>Hashtable和ConcurrentHashMap集合的底层原理概述</strong></p><p>HashTable的结构图如下，可看出在所有的链表都加锁了，故加锁的范围大，效率自然就低了。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221126130147813.png" alt="image-20221126130147813"></p><p>ConcurrentHashMap结构图如下，可见其只在一条链上加锁，故锁的范围较小，效率自然就高了。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221126130537171.png" alt="image-20221126130537171"></p><h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><p>某个线程任务必须等待其他线程执行完毕以后才能最终触发自己执行。</p><p>需求： 公司召集5名员工开会，等5名员工都到了，会议开始。</p><p>​1. 在以下代码中，5名员工还未全部到达会议，就已经开始组织会议。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//循环创建线程，总创建5个线程代表5个员工</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i ++)&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">EmployeeThread</span>(<span class="string">&quot;员工&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 开始会议</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Meeting</span>()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建会议开始的线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Meeting</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;员工5开始组织会议。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建员工线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmployeeThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EmployeeThread</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;进入会议&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221126135812833.png" alt="image-20221126135812833"></p><ol start="2"><li>利用并发包提供的CyclicBarrier类可以保证先让员工进入会议，在开始组织会议</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 例如:公司召集5名员工开会，等5名员工都到了，会议开始。</span></span><br><span class="line"><span class="comment"> * 我们创建5个员工线程，1个开会任务，几乎同时启动</span></span><br><span class="line"><span class="comment"> * 使用cyclicBarrier保证5名员工线程全部执行后，再执行开会线程。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 构造器:</span></span><br><span class="line"><span class="comment"> *  public cyclicBarrier(int parties,Runnable barrierAction)</span></span><br><span class="line"><span class="comment"> *       用于在线程到达屏障5时，优先执行barrierAction，方便处理更复杂的业务场景</span></span><br><span class="line"><span class="comment"> * 方法:</span></span><br><span class="line"><span class="comment"> *  public int await ()</span></span><br><span class="line"><span class="comment"> *      每个线程调用await方法告诉cyclicBarrier我已经到达了屏障，然后当前线程被阻塞</span></span><br><span class="line"><span class="comment"> *  小结:</span></span><br><span class="line"><span class="comment"> *      可以实现多线程中，某个任务在等待其他线程执行完毕以后触发。循坏屏障可以实现达到一组屏障就触发一个任务执行!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建循环屏障对象，让5个员工全部进入会议在进行开会</span></span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">5</span>,<span class="keyword">new</span> <span class="title class_">Meeting</span>());</span><br><span class="line">        <span class="comment">//循环创建线程，创建5个线程代表5个员工</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i ++)&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">EmployeeThread</span>(<span class="string">&quot;员工&quot;</span> + i,cyclicBarrier).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建会议开始的线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Meeting</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;员工5开始组织会议。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建员工线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmployeeThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="comment">//接收CyclicBarrier的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CyclicBarrier cyclicBarrier;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EmployeeThread</span><span class="params">(String name,CyclicBarrier cyclicBarrier)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//Thread.sleep(1000);</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;进入会议&quot;</span>);</span><br><span class="line">            cyclicBarrier.await(); <span class="comment">//源码中有个计数器，当计数器为5时，就将该线程回收</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221126140145795.png" alt="image-20221126140145795"></p><ol start="3"><li>业务应用场景：可以使用以上的思路去实现多线程加载文件后再打包文件，多线程加载速度快，性能较好。</li></ol><h3 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h3><p>作用：用于两个或多个线程之间的信息通信。</p><p><strong>例子1：</strong> 在古代男女结婚大多都是通过媒婆介绍的，那么男女在没结婚之前信息或物品交换都是通过媒婆转达的，更多故事请看以下代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  现有两个人，一男一女，是通过媒婆介绍并结婚的美好故事</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExchangerTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//创建一位媒婆</span></span><br><span class="line">        Exchanger&lt;String&gt; matchmaker = <span class="keyword">new</span> <span class="title class_">Exchanger</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//男女线程，现在男孩和女孩要交换定情信物，那只能通过媒婆转达</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Boy</span>(matchmaker),<span class="string">&quot;男孩&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Girl</span>(matchmaker),<span class="string">&quot;女孩&quot;</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>); <span class="comment">//保证男女孩的定情信物的交换成功</span></span><br><span class="line">        System.out.println(<span class="string">&quot;男孩和女孩都很满意对方的定情信物，于是结婚了哈哈哈&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  男孩子，要求不高</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Boy</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="comment">//男孩要去接待媒婆的到来</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Exchanger&lt;String&gt; matchmaker;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Boy</span><span class="params">(Exchanger&lt;String&gt; matchmaker)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.matchmaker = matchmaker;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">stuff</span> <span class="operator">=</span> <span class="string">&quot;同心锁&quot;</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;男孩开始制作--&gt;&quot;</span> + stuff);</span><br><span class="line">            <span class="comment">//男孩制作完后将其交给媒婆传达并从媒婆那得到女孩的信物</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">girlOfStuff</span> <span class="operator">=</span> matchmaker.exchange(stuff); <span class="comment">// 媒婆需要等待男孩的信物做完才可转交</span></span><br><span class="line">            System.out.println(<span class="string">&quot;男孩收到了女孩的&quot;</span> + girlOfStuff);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  女孩子，要求不高</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="comment">//女孩要去接待媒婆的到来</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Exchanger&lt;String&gt; matchmaker;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Girl</span><span class="params">(Exchanger&lt;String&gt; matchmaker)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.matchmaker = matchmaker;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">stuff</span> <span class="operator">=</span> <span class="string">&quot;钥匙&quot;</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;女孩开始制作--&gt;&quot;</span> + stuff);</span><br><span class="line">            <span class="comment">//女孩制作完后将其交给媒婆传达并从媒婆那得到男孩的信物</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">boyOfStuff</span> <span class="operator">=</span> matchmaker.exchange(stuff);</span><br><span class="line">            System.out.println(<span class="string">&quot;女孩收到了男孩的&quot;</span> + boyOfStuff);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221126145632008.png" alt="image-20221126145632008"></p><p><strong>例子2：</strong>正所谓结婚是双向奔赴的结果，那上面的例子可能只是在理想的环境下发生的罢了，现实中哪有如此容易啊，那么请看以下故事的结局是如何。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  现有两个人，一男一女悲惨故事</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExchangerTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//创建一个媒婆对象</span></span><br><span class="line">        Exchanger&lt;String&gt; matchmaker = <span class="keyword">new</span> <span class="title class_">Exchanger</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//男女线程，现在男孩和女孩要交换定情信物，那只能通过媒婆转达</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Boy</span>(matchmaker),<span class="string">&quot;男孩&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Girl</span>(matchmaker),<span class="string">&quot;女孩&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  男孩子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Boy</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="comment">//男孩要去接待媒婆的到来</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Exchanger&lt;String&gt; matchmaker;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Boy</span><span class="params">(Exchanger&lt;String&gt; matchmaker)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.matchmaker = matchmaker;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">stuff</span> <span class="operator">=</span> <span class="string">&quot;同心锁&quot;</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;男孩开始制作--&gt;&quot;</span> + stuff);</span><br><span class="line">            <span class="comment">//男孩制作完后将其交给媒婆传达并从媒婆那得到女孩的信物，男孩是一位急性子，只能等5s，若女孩还没有给定情信物的话就去自杀了</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">girlOfStuff</span> <span class="operator">=</span> matchmaker.exchange(stuff,<span class="number">5</span>, TimeUnit.SECONDS); <span class="comment">// 媒婆需要等待男孩的信物做完才可转交</span></span><br><span class="line">            System.out.println(<span class="string">&quot;男孩收到了女孩的&quot;</span> + girlOfStuff);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  女孩子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="comment">//女孩要去接待媒婆的到来</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Exchanger&lt;String&gt; matchmaker;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Girl</span><span class="params">(Exchanger&lt;String&gt; matchmaker)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.matchmaker = matchmaker;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">stuff</span> <span class="operator">=</span> <span class="string">&quot;钥匙&quot;</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;女孩开始制作--&gt;&quot;</span> + stuff);</span><br><span class="line">            <span class="comment">//女孩对未见过面的男孩犹豫了6s才将信物送出去了</span></span><br><span class="line">            Thread.sleep(<span class="number">6000</span>);</span><br><span class="line">            <span class="comment">//女孩制作完后将其交给媒婆传达并从媒婆那得到男孩的信物</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">boyOfStuff</span> <span class="operator">=</span> matchmaker.exchange(stuff);</span><br><span class="line">            System.out.println(<span class="string">&quot;女孩收到了男孩的&quot;</span> + boyOfStuff);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221126151314144.png" alt="image-20221126151314144"></p><p><strong>应用业务场景：</strong>数据校验。在公司的流水账中数据的校验，可以定义两个线程对流水账中数据先各自校验，然后再把各自的校验结果进行交换，比对对方的校验结果和自己校验结果是否一致，这样可以大大的降低流水账中数据的出错率。</p><h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><p>概述：Lambda是JDK1.8之后提供的，作用是简化匿名内部类的写法。</p><ul><li>使用Lambda表达式的条件是：一个类中只能有一个抽象方法的函数式接口。</li></ul><p>以下代码是Lambda的基本用法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//匿名内部类的写法</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;匿名内部类线程开启&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="comment">//lambda写法</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;lambda线程&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h1><p>概述：stream流是JDK1.8之后提供，目的是为了简化集合数据操作的写法，同时也优化了执行的性能。以下代码可以体现Stream流的便利</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 业务需求：找到姓张的并且名字长度为3的客户</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//客户列表</span></span><br><span class="line">        List&lt;String&gt; users = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        users.add(<span class="string">&quot;张三丰&quot;</span>);</span><br><span class="line">        users.add(<span class="string">&quot;张韩&quot;</span>);</span><br><span class="line">        users.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        users.add(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        users.add(<span class="string">&quot;刘鸥上&quot;</span>);</span><br><span class="line">        users.add(<span class="string">&quot;张麻子&quot;</span>);</span><br><span class="line">        <span class="comment">//遍历找到姓张的并且长度为3的</span></span><br><span class="line">        <span class="keyword">for</span> (String user: users) &#123;</span><br><span class="line">            <span class="keyword">if</span>(user.startsWith(<span class="string">&quot;张&quot;</span>) &amp;&amp; user.length() == <span class="number">3</span>)&#123;</span><br><span class="line">                System.out.println(user);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;----------stream流------------&quot;</span>);</span><br><span class="line">        <span class="comment">//stream流写法</span></span><br><span class="line">        users.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;张&quot;</span>)).filter(s -&gt; s.length() == <span class="number">3</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221126161207005.png" alt="image-20221126161207005"></p><h2 id="常用的API"><a href="#常用的API" class="headerlink" title="常用的API"></a>常用的API</h2><ol><li><p>forEach ：逐一处理(遍历)</p></li><li><p>long count ()： 统计个数</p></li><li><p>filter ：过滤元素<br>– stream<T> filter (Predicate&lt;? sup er T&gt; predicate)</p></li><li><p>limit：取前几个元素</p></li><li><p>skip：跳过前几个</p></li><li><p>map：数据加工方法</p></li><li><p>concat：合并流。 静态方法</p><p><strong>以上方法除了count 和forEach终结流 ，其余都是非终结流，终结流是调用方法后没有返回值，非终结流是有返回值。</strong></p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  常用API测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//客户列表</span></span><br><span class="line">        List&lt;String&gt; userList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        userList.add(<span class="string">&quot;张三丰&quot;</span>);</span><br><span class="line">        userList.add(<span class="string">&quot;张韩&quot;</span>);</span><br><span class="line">        userList.add(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        userList.add(<span class="string">&quot;张麻子&quot;</span>);</span><br><span class="line">        <span class="comment">//1. 过滤出姓张的客户并打印</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------1------------&quot;</span>);</span><br><span class="line">        userList.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;张&quot;</span>)).forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------2------------&quot;</span>);</span><br><span class="line">        <span class="comment">//2. 计算出客户的个数</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> userList.stream().count();</span><br><span class="line">        System.out.println(count);</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------3------------&quot;</span>);</span><br><span class="line">        <span class="comment">//3. 取前两个的客户名</span></span><br><span class="line">        userList.stream().limit(<span class="number">2</span>).forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------4------------&quot;</span>);</span><br><span class="line">        <span class="comment">//4. 取最后两个的客户</span></span><br><span class="line">        userList.stream().skip(userList.size() - <span class="number">2</span>).forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------5------------&quot;</span>);</span><br><span class="line">        <span class="comment">//5. 在每个客户名称上都加上m字母</span></span><br><span class="line">        userList.stream().map(s -&gt; s + <span class="string">&quot;m&quot;</span>).forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------6------------&quot;</span>);</span><br><span class="line">        <span class="comment">//6. 将下面的列表合成一个列表</span></span><br><span class="line">        List&lt;String&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        temp.add(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        temp.add(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        Stream&lt;String&gt; res = Stream.concat(userList.stream(), temp.stream());</span><br><span class="line">        res.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221126164020510.png" alt="image-20221126164020510" style="zoom:67%;" /><h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><ol><li>以下是常用的API测试</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 常用Api测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileApiTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建文件对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\test.jpg&quot;</span>); <span class="comment">//以绝对路径获取文件对象</span></span><br><span class="line">        <span class="comment">//1. 获取文件的相对路径</span></span><br><span class="line">        System.out.println(f1.getPath());</span><br><span class="line">        <span class="comment">//2. 获取文件的绝对路径</span></span><br><span class="line">        System.out.println(f1.getAbsolutePath());</span><br><span class="line">        <span class="comment">//3. 获取文件的名称，带后缀</span></span><br><span class="line">        System.out.println(f1.getName());</span><br><span class="line">        <span class="comment">//4. 获取文件的大小，以字节单位</span></span><br><span class="line">        System.out.println(f1.length());</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------&quot;</span>);</span><br><span class="line">        <span class="comment">//以相对路径获取文件对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;b_based_item2\\file\\temp\\hello.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//1. 获取文件的相对路径</span></span><br><span class="line">        System.out.println(f2.getPath());</span><br><span class="line">        <span class="comment">//2. 获取文件的绝对路径</span></span><br><span class="line">        System.out.println(f2.getAbsolutePath());</span><br><span class="line">        <span class="comment">//3. 获取文件的名称，带后缀</span></span><br><span class="line">        System.out.println(f2.getName());</span><br><span class="line">        <span class="comment">//4. 获取文件的大小，以字节为单位</span></span><br><span class="line">        System.out.println(f2.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>File的判断API</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建文件对象</span></span><br><span class="line"><span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\test.jpg&quot;</span>); <span class="comment">//以绝对路径获取文件对象</span></span><br><span class="line"><span class="comment">//1. 判断文件是否存在</span></span><br><span class="line">System.out.println(f1.exists());</span><br><span class="line"><span class="comment">//2. 判断是否是文件，若是，返回true 否则 返回false</span></span><br><span class="line">System.out.println(f1.isFile());</span><br><span class="line"><span class="comment">//3. 判断文件对象是否是文件夹</span></span><br><span class="line">System.out.println(f1.isDirectory());</span><br></pre></td></tr></table></figure><ol start="3"><li>File的删除和创建相关的API</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以相对路径获取文件对象</span></span><br><span class="line"><span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;b_based_item2\\file\\temp\\hello1.txt&quot;</span>);</span><br><span class="line"><span class="comment">// 删除文件，若删除成功返回true，否则返回false，以下操作同理</span></span><br><span class="line">f2.delete();</span><br><span class="line"><span class="comment">// 删除空文件夹，非空删除不了</span></span><br><span class="line"><span class="type">File</span> <span class="variable">f3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;b_based_item2\\file\\test&quot;</span>);</span><br><span class="line">f3.delete();</span><br><span class="line"><span class="comment">// 创建多级目录</span></span><br><span class="line"><span class="type">File</span> <span class="variable">f4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;b_based_item2\\file\\temp\\hello\\world&quot;</span>);</span><br><span class="line">f4.mkdirs();</span><br></pre></td></tr></table></figure><ol start="4"><li>File的文件夹的相关API操作</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文件列表的获取和遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FIleApiTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建文件对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\java\\installpackage&quot;</span>);</span><br><span class="line">        <span class="comment">//获取当前文件夹中所有的文件名称</span></span><br><span class="line">        String[] fileNames = file.list();</span><br><span class="line">       <span class="comment">//断言fileNames数组不为空，防止报错</span></span><br><span class="line">        <span class="keyword">assert</span> fileNames != <span class="literal">null</span>;</span><br><span class="line">        Arrays.stream(fileNames).forEach(System.out::println); <span class="comment">//打印</span></span><br><span class="line">        <span class="comment">//获取当前文件夹中的所有文件对象</span></span><br><span class="line">        File[] files = file.listFiles();</span><br><span class="line">        <span class="keyword">if</span>(files == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">            System.out.println(f.getAbsolutePath());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h2><p>递归算法的三要素（缺一不可）</p><ul><li><p>递归的终结点。</p></li><li><p>递归的公式。</p></li><li><p>递归的方向，递归公式必须往终结点的方向靠近。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecursionTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(f(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="comment">//递归的终结点</span></span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">1</span> &amp;&amp; x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归的公式，该递归公式为f(x-1) + 1 故在x -1 会一直若x是正数就会往x == 1终结点靠近。</span></span><br><span class="line">        <span class="keyword">return</span> f(x - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>以下是递归算法的案例</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  猴子吃桃:</span></span><br><span class="line"><span class="comment"> *      猴子第一天摘了若干个桃子，当即吃了一半，觉得好不过瘾，然后又多吃了一个。</span></span><br><span class="line"><span class="comment"> *      第二天又吃了前一天剩下的一半，觉得好不过瘾，然后又多吃了一个。</span></span><br><span class="line"><span class="comment"> *      以后每天都是如此</span></span><br><span class="line"><span class="comment"> *      等到第十天再吃的时候发现只有1个桃子，请问猴子第一天总共摘了多少个桃子。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   公式推导：假设天数为n从1开始算起，f(n)为猴子吃桃子数</span></span><br><span class="line"><span class="comment"> *      f(n + 1) = f(n) - f(n)/2 - 1</span></span><br><span class="line"><span class="comment"> *      公式变换：2f(n + 1) = 2f(n) - f(n) - 2</span></span><br><span class="line"><span class="comment"> *           =&gt; f(n) = 2f(n + 1) + 2</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   递归的三要素</span></span><br><span class="line"><span class="comment"> *      递归的终结点：f(10) = 1</span></span><br><span class="line"><span class="comment"> *      递归的公式：f(n) = 2f(n + 1) + 2</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecursionTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(f(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//递归的终结点</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归的公式</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * f(n + <span class="number">1</span>) + <span class="number">2</span>; <span class="comment">//得出答案为：1534</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  要求：求出n的阶层</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  公式推导：f(n) = n * (n-1) * ... * 3 * 2 * 1</span></span><br><span class="line"><span class="comment"> *  找规律得：f(n) = f(n - 1) * n</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  递归的三要素</span></span><br><span class="line"><span class="comment"> *      递归的终结点：f(1) = 1</span></span><br><span class="line"><span class="comment"> *      递归的公式：f(n) = f(n - 1) * n</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecursionTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(f(<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f(n - <span class="number">1</span>) * n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递归搜索文件"><a href="#递归搜索文件" class="headerlink" title="递归搜索文件"></a>递归搜索文件</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文件搜索测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileSearchTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//在javaFileStore目录下寻找word.txt文件</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> fileSearch(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\javaFileStore&quot;</span>), <span class="string">&quot;word.txt&quot;</span>);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mkdir：目录</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileName：要查找的文件名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 若找到返回该文件的绝对路径，不存在返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">fileSearch</span><span class="params">(File mkdir,String fileName)</span>&#123;</span><br><span class="line">        <span class="comment">//1. 判断该目录是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(!mkdir.exists()) &#123;</span><br><span class="line">            <span class="comment">//说明不存在</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2. 获取该目录下的所有文件</span></span><br><span class="line">        File[] files = mkdir.listFiles();</span><br><span class="line">        <span class="comment">//3. 判断该目录下是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(files == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//说明files文件夹为空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历判断是否是文件</span></span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            <span class="keyword">if</span>(file.isFile()) &#123;</span><br><span class="line">                <span class="comment">//说明是文件</span></span><br><span class="line">                <span class="keyword">if</span>(file.getName().contains(fileName)) &#123;</span><br><span class="line">                    <span class="comment">//说明找到了</span></span><br><span class="line">                    <span class="keyword">return</span> file.getAbsolutePath();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//说明是目录，递归再寻找</span></span><br><span class="line">                <span class="keyword">return</span> fileSearch(file,fileName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221127132603389.png" alt="image-20221127132603389"></p><h2 id="I-x2F-O流"><a href="#I-x2F-O流" class="headerlink" title="I&#x2F;O流"></a>I&#x2F;O流</h2><p>概述： File类只能操作文件对象本身并不能对其进行读写操作，读写文件应是I&#x2F;O操作，I&#x2F;O流可以理解成水流模型，IO是水管，数据是水流。</p><h3 id="I-x2F-O流的分类"><a href="#I-x2F-O流的分类" class="headerlink" title="I&#x2F;O流的分类"></a>I&#x2F;O流的分类</h3><p><strong>按照流的方向分类</strong></p><p>（ 1 ）输出流：以内存为基准，把内存中的数据写出到磁盘文件或者网络介质中去的流称为输出流。输出流作用是写数据到文件，或者写数据发送给别人。</p><p>（ 2 ）输入流：以内存为基准，把磁盘文件中的数据或者网络中的数据读入到内存中去的流称为输入流，输入流的作用:读取数据到内存。</p><p><strong>按照流的内容分类</strong></p><p>（ 1 ）字节流： 流中的数据的最小单位是一个一个的字节(bit)，这个流就是字节流。(万”物”皆可字节流)</p><p>（ 2 ）字符流： 流中的数据的最小单位是一个一个的字符，这个流就是字符流。(针对于文本内容)</p><h3 id="I-x2F-O流代码实现"><a href="#I-x2F-O流代码实现" class="headerlink" title="I&#x2F;O流代码实现"></a>I&#x2F;O流代码实现</h3><ol><li><strong>字节输入流（结合图理解字节流的工作流程）</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字节流读取文件内容测试测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IOStreamTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//创建一根水管（字节输入流对象）</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;b_based_item2\\file\\temp\\hello.txt&quot;</span>); </span><br><span class="line">       <span class="comment">//定义一个桶</span></span><br><span class="line">        <span class="type">byte</span>[] buff = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">//桶中装水大小容量</span></span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="comment">//循环将桶中的水倒出（打印）</span></span><br><span class="line">        <span class="keyword">while</span> ((len = is.read(buff)) != -<span class="number">1</span>) &#123; <span class="comment">//当桶中没水了会返回一个-1</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(buff,<span class="number">0</span>,len)); <span class="comment">// new String() 将字节转换成字符，可以避免输出中文乱码（桶需要比文件还大）</span></span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">//关闭水管</span></span><br><span class="line">        is.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221127143510871.png" alt="image-20221127143510871"></p><ol start="2"><li><strong>字节输出流</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字节流输出流测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IOStreamTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//创建一根输出流水管（默认会将文件中的内容覆盖）</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;b_based_item2\\file\\temp\\hello.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//不会覆盖文件中的内容，在创建对象时，加个参数true</span></span><br><span class="line">        <span class="comment">//OutputStream os = new FileOutputStream(&quot;b_based_item2\\file\\temp\\hello.txt&quot;,true);</span></span><br><span class="line">        <span class="comment">//定义一个水桶并装水（内容）</span></span><br><span class="line">        <span class="type">byte</span>[] buff = <span class="string">&quot;我本可以忍受黑暗，如果我未曾见过光明&quot;</span>.getBytes();</span><br><span class="line">        <span class="comment">//将水桶中的水倒进水池中（将内容写入文件中）</span></span><br><span class="line">        os.write(buff);</span><br><span class="line">        <span class="comment">//刷新水管</span></span><br><span class="line">        os.flush();</span><br><span class="line">        <span class="comment">//关闭水管</span></span><br><span class="line">        os.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>复制文件案例</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 复制文件测试</span></span><br><span class="line"><span class="comment"> *  需求：从一个文件中读取数据复制到另一个文件目录中</span></span><br><span class="line"><span class="comment"> *  注意：以下的写法是JDK1.7后提供的新写法 try-catch-resource java自动会释放资源</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IOCopyTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="keyword">try</span> (</span><br><span class="line">               <span class="comment">//创建字节输入流</span></span><br><span class="line">               <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;b_based_item2\\file\\temp\\hello.txt&quot;</span>);</span><br><span class="line">                <span class="comment">//创建字节输出流对象</span></span><br><span class="line">                <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;b_based_item2\\file\\temp\\hello\\hello.txt&quot;</span>);</span><br><span class="line">             )&#123;</span><br><span class="line">           <span class="comment">//从输入流中读取数据</span></span><br><span class="line">           <span class="comment">//定义一个桶</span></span><br><span class="line">           <span class="type">byte</span>[] buff = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">           <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">           <span class="comment">//从水池中抽水并通过os将水倒进另一个水池中</span></span><br><span class="line">           <span class="keyword">while</span> ((len = is.read(buff)) != -<span class="number">1</span>) &#123;</span><br><span class="line">               os.write(buff,<span class="number">0</span>,len);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>字符输入流</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文件字符输入流。</span></span><br><span class="line"><span class="comment"> *      --作用:以内存为基准，把磁盘文件的数据以字符的形式读入到内存。</span></span><br><span class="line"><span class="comment"> *          简单来说，读取文本文件内容到内存中去。</span></span><br><span class="line"><span class="comment"> *      --构造器:</span></span><br><span class="line"><span class="comment"> *          public FileReader(File file):创建一个字符输入流与源文件对象接通</span></span><br><span class="line"><span class="comment"> *           public FileReader (string filePath):创建一个字符输入流与源文件路径接通</span></span><br><span class="line"><span class="comment"> *      --方法:</span></span><br><span class="line"><span class="comment"> *          public int read():读取一个字符的编号返回!读取完毕返回-1</span></span><br><span class="line"><span class="comment"> *          public int read (char[] buffer):读取一个字符数组，</span></span><br><span class="line"><span class="comment"> *              读取多少个字符就返回多少个数量，读取完毕返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IOReadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">            <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;b_based_item2\\file\\temp\\hello.txt&quot;</span>);</span><br><span class="line">        )&#123;</span><br><span class="line">            <span class="comment">//从文件中以字符为单位读取数据</span></span><br><span class="line">            <span class="type">char</span>[] buff = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((len = fr.read(buff)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(buff,<span class="number">0</span>,len));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>字符输出流</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字符输出流测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IOWriterTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">//以追加数据的形式创建输出流</span></span><br><span class="line">                <span class="type">Writer</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;b_based_item2\\file\\temp\\hello.txt&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">             )&#123;</span><br><span class="line">            <span class="comment">//定义需要写入的数据文字</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">info1</span> <span class="operator">=</span> <span class="string">&quot;code&quot;</span>;</span><br><span class="line">            <span class="comment">//写入数据</span></span><br><span class="line">            writer.write( info1 + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">info2</span> <span class="operator">=</span> <span class="string">&quot;实力与野心不符，这是一件很可悲的事情&quot;</span>;</span><br><span class="line">            writer.write(info2 + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="I-x2F-O缓冲流"><a href="#I-x2F-O缓冲流" class="headerlink" title="I&#x2F;O缓冲流"></a>I&#x2F;O缓冲流</h3><ol><li><strong>字节缓冲输入流</strong>：因为BufferedInputStream类是继承InputStream类的，故API接口几乎不变</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字节缓冲输入流:BufferedInputStream</span></span><br><span class="line"><span class="comment"> *     --作用:可以把低级的字节输入流包装成一个高级的缓冲字节输入流管道，</span></span><br><span class="line"><span class="comment"> *            从而提高字节输入流读数据的性能。</span></span><br><span class="line"><span class="comment"> *     --构造器:public BufferedInputStream (InputStream in)</span></span><br><span class="line"><span class="comment"> *     --原理:缓冲字节输入流管道自带了一个8KB的缓冲池，每次可以直接借用操作系统的功能最多提取8KB</span></span><br><span class="line"><span class="comment"> *            的数据到缓冲池中去，以后我们直接从缓冲池读取数据，所以性能较好!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IOBufferStreamTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">              <span class="comment">//创建对象</span></span><br><span class="line">              <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;b_based_item2\\file\\temp\\hello.txt&quot;</span>))</span><br><span class="line">           )&#123;</span><br><span class="line">            <span class="comment">//定义一个桶</span></span><br><span class="line">            <span class="type">byte</span>[] buff = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((len = is.read(buff)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(buff,<span class="number">0</span>,len));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>缓冲字节输出流</strong>：BufferedOutputStream继承OutputStream类，故API接口与上面的几乎不变</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  字节缓冲输出流:BufferedOutputStream</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IOBufferStreamTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">              <span class="comment">//创建对象</span></span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;b_based_item2\\file\\temp\\hello.txt&quot;</span>,<span class="literal">true</span>))</span><br><span class="line">           )&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">info</span> <span class="operator">=</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">            os.write(info.getBytes());</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>字节流和字节缓冲流的性能分析</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字节流和字符缓冲字节流性能测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IOPerformanceTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        copy1();</span><br><span class="line">        copy2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//由于一个一个字节复制文件太慢了直接pass</span></span><br><span class="line">    <span class="comment">//一个一个字节数组复制文件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copy1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">//创建字节输入流</span></span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;b_based_item2\\file\\temp\\temp.mp4&quot;</span>);</span><br><span class="line">                <span class="comment">//创建字节输出流对象</span></span><br><span class="line">                <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;b_based_item2\\file\\temp\\hello\\temp1.mp4&quot;</span>);</span><br><span class="line">        )&#123;</span><br><span class="line">            <span class="comment">//从输入流中读取数据</span></span><br><span class="line">            <span class="comment">//定义一个桶</span></span><br><span class="line">            <span class="type">byte</span>[] buff = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//从水池中抽水并通过os将水倒进另一个水池中</span></span><br><span class="line">            <span class="keyword">while</span> ((len = is.read(buff)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                os.write(buff,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;字节流一次一数组复制文件所耗时：&quot;</span> + (end - start) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//缓冲字节流一次一个数组复制</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copy2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">//创建字节输入流</span></span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;b_based_item2\\file\\temp\\temp.mp4&quot;</span>));</span><br><span class="line">                <span class="comment">//创建字节输出流对象</span></span><br><span class="line">                <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;b_based_item2\\file\\temp\\hello\\temp2.mp4&quot;</span>));</span><br><span class="line">        )&#123;</span><br><span class="line">            <span class="comment">//从输入流中读取数据</span></span><br><span class="line">            <span class="comment">//定义一个桶</span></span><br><span class="line">            <span class="type">byte</span>[] buff = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//从水池中抽水并通过os将水倒进另一个水池中</span></span><br><span class="line">            <span class="keyword">while</span> ((len = is.read(buff)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                os.write(buff,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;字节缓冲流一次一数组复制文件所耗时：&quot;</span> + (end - start)  + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221127164321276.png" alt="image-20221127164321276"></p><p>总结：如上图结果显示，字节缓冲流的性能比普通的字节流性能还要好。</p><ol start="4"><li><strong>字符输入缓冲流</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字符缓冲流测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IOBufferReadTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="keyword">try</span> (</span><br><span class="line">               <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;b_based_item2\\file\\temp\\hello.txt&quot;</span>));</span><br><span class="line">           )&#123;</span><br><span class="line">           <span class="comment">//从文件中读取数据</span></span><br><span class="line">           <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">           <span class="comment">//一次读取一行字符</span></span><br><span class="line">           <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">               System.out.println(line);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>字符缓冲输出流</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字符缓冲输出流测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IOBufferWriteTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//创建字符缓冲输出对象(新添加的内容加入到文件的末尾)</span></span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;b_based_item2\\file\\temp\\hello.txt&quot;</span>,<span class="literal">true</span>));</span><br><span class="line">        <span class="comment">//换一行</span></span><br><span class="line">        bw.newLine();</span><br><span class="line">        <span class="comment">//写入数据</span></span><br><span class="line">        bw.write(<span class="string">&quot;我本可以忍受黑暗&quot;</span>);</span><br><span class="line">        <span class="comment">//换一行</span></span><br><span class="line">        bw.newLine();</span><br><span class="line">        <span class="comment">//再写入数据</span></span><br><span class="line">        bw.write(<span class="string">&quot;假如我为曾见过光明&quot;</span>);</span><br><span class="line"></span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;异常的作用&quot;&gt;&lt;a href=&quot;#异常的作用&quot; class=&quot;headerlink&quot; title=&quot;异常的作用&quot;&gt;&lt;/a&gt;异常的作用&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;提高程序的健壮性和安全性。&lt;/li&gt;
&lt;li&gt;可以处理代码问题，防止程序出现问题后的死亡。&lt;/li&gt;
&lt;</summary>
      
    
    
    
    
    <category term="java基础" scheme="http://example.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>node.js安装说明及环境配置</title>
    <link href="http://example.com/2022/11/20/node-js%E5%AE%89%E8%A3%85%E8%AF%B4%E6%98%8E%E5%8F%8A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>http://example.com/2022/11/20/node-js%E5%AE%89%E8%A3%85%E8%AF%B4%E6%98%8E%E5%8F%8A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</id>
    <published>2022-11-20T04:31:48.000Z</published>
    <updated>2023-01-26T12:48:24.535Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装node-js步骤"><a href="#安装node-js步骤" class="headerlink" title="安装node.js步骤"></a>安装node.js步骤</h2><p>（一）官网下载安装包</p><ol><li>官网下载：<a href="https://nodejs.org/en/">Node.js (nodejs.org)</a></li></ol><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221120143619510.png" alt="image-20221120143619510" style="zoom:50%" /><ol start="2"><li>解压安装包进入你所安装的目录下，并创建两个目录分别为node_global和node_cache，<ol><li>node_globe：全局目录，下载的文件是保存于此</li><li>node_cache：缓存目录，保存一些node运行时的日志文件等等</li></ol></li><li>前两步完成后使用快捷键win+r输入cmd进入命令窗口，输入命令：<ol><li>node -v ：查看node是否安装成功</li><li>npm -v：查看npm命令是否安装成功，若安装成功如下图所示</li></ol></li></ol><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221120160703329.png" alt="image-20221120160703329"></p><p>（二）设置自定义全局目录和缓存目录</p><p>以上步骤完成后，以管理员身份运行cmd，输入以下命令</p><p>（三）配置环境变量</p><pre><code>      1. 将【用户变量】下的【Path】修改为【D:\Nodejs\node_global】，之后点击确定。</code></pre><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221120161915822.png" alt="image-20221120161915822"></p><ol start="2"><li>在【系统变量】下新建【NODE_PATH】【D:\Nodejs\node_global\node_modules】</li></ol><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221120162015871.png" alt="image-20221120162015871"></p><ol start="3"><li>在【系统变量】下的【Path】新建添加node全局文件夹【D:\Nodejs\node_global】，之后点击确定。</li></ol><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221120162114934.png" alt="image-20221120162114934" style="zoom:67%;" /><p>（四）下载cnpm命令</p><ol><li><p>说明：npm 默认的 registry ,也就是下载 npm 包时是从国外的服务器下载，国内很慢，一般都会指向淘宝 <a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a></p></li><li><p>npm config get registry         查看下当前的镜像源</p></li><li><p>npm config set registry <a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org/</a>     更换镜像为淘宝镜像</p></li><li><p>npm config get registry        检查配置是否成功 </p></li><li><p>npm install -g cnpm –registry&#x3D;<a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a>      全局安装基于淘宝源的cnpm</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;安装node-js步骤&quot;&gt;&lt;a href=&quot;#安装node-js步骤&quot; class=&quot;headerlink&quot; title=&quot;安装node.js步骤&quot;&gt;&lt;/a&gt;安装node.js步骤&lt;/h2&gt;&lt;p&gt;（一）官网下载安装包&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;官网下载：&lt;a hr</summary>
      
    
    
    
    
    <category term="node.js" scheme="http://example.com/tags/node-js/"/>
    
  </entry>
  
  <entry>
    <title>spring+springmvc+maven笔记</title>
    <link href="http://example.com/2022/11/20/spring+springmvc+maven%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2022/11/20/spring+springmvc+maven%E7%AC%94%E8%AE%B0/</id>
    <published>2022-11-19T16:00:00.000Z</published>
    <updated>2023-01-26T11:18:16.884Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>概念</strong>：Spring是分层的Java SE&#x2F;EE应用full-stack轻量级开源框架，以loC ( Inverse Of Control:反转控制)和AOP (Aspect Oriented Programming :面向切面编程)为内核。</p><p><strong>应用</strong>：提供了展现层SpringMVC和持久层Spring JDBCTemplate 以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的JavaEE企业应用开源框架”</p><p><strong>优势</strong></p><p>（1）方便解耦，简化开发</p><p>通过Spring提供的lOC容器，可以将对象间的依赖关系交由Spring进行控制，避免硬编码所造成的过度耦合。用户也不必再为单例模式类、属性文件解析等这些很底层的需求编写代码，可以更专注于上层的应用。</p><p>（2）AOP编程的支持</p><p>通过Spring的AOP功能，方便进行面向切面编程，许多不容易用传统OOP实现的功能可以通过AOP轻松实现。</p><p>（3）声明式事务的支持</p><p>可以将我们从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活的进行事务管理提高开发效率和质量。</p><p>（4）方便集成各种优秀框架</p><p>Spring对各种优秀框架(Struts、Hibernate、Hessian、Quartz等)的支持。</p><p>（5）降低JavaEE API的使用难度</p><p>Spring对JavaEEAPI(如JDBC、JavaMail、远程调用等）进行了薄薄的封装层，使这些API的使用难度大为降低。</p><p>（6）Java源码是经典学习范例</p><p>Spring的源代码设计精妙、结构清晰、匠心独用，处处体现着大师对Java设计模式灵活运用以及对Java技术的高深造诣。它的源代码无疑是Java技术的最佳实践的范例。</p><h2 id="Spring-framework"><a href="#Spring-framework" class="headerlink" title="Spring framework"></a>Spring framework</h2><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221130172942524.png" alt="image-20221130172942524"></p><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><p>概述：使用对象时，由主动new产生对象转换为由外部提供对象，此过程中对象创建控制权由程序转移到外部，此思想称为控制反转技术对IOC思想进行了实现，Spring提供了一个容器，称为IoC容器，用来充当IoC思想中的 “外部“，IoC容器负责对象的创建、初始化等一系列工作，被创建或被管理的对象在IoC容器中统称为Bean。</p><p><strong>创建Bean的步骤如下</strong></p><ol><li>pom.xml文件中导入spring-context坐标（版本5.0.5.RELEASE）</li><li>resource目录下创建spring的配置文件，通常将其命名为applicationContext.xml</li><li>在applicationContext.xml利用bean标签创建即可，如下所示</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 将bookDaoImpl类交给Spring的IOC管理(将其变为bean) --&gt;</span><br><span class="line">   &lt;!-- id值随便取，class值是指向实例类 --&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;bookDao&quot;</span> class=<span class="string">&quot;com.springbased.dao.impl.BookDaoImpl&quot;</span> /&gt;</span><br><span class="line">&lt;!-- 将bookServiceImpl类交给Spring的IOC管理(将其变为bean) --&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;bookService&quot;</span> class=<span class="string">&quot;com.springbased.service.impl.BookServiceImpl&quot;</span>  /&gt;</span><br></pre></td></tr></table></figure><ul><li>从IOC容器中获取bean</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//获取IOC容器</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//根据id获取具体的bean 两种方法：</span></span><br><span class="line">        <span class="comment">//1)通过id方式获取  Object getBean(String id);</span></span><br><span class="line">        <span class="comment">//2)通过类对象获取  Class getBean(类名称.class);</span></span><br><span class="line">        <span class="type">BookService</span> <span class="variable">bookDao</span> <span class="operator">=</span> (BookService)ac.getBean(<span class="string">&quot;bookService&quot;</span>);</span><br><span class="line">        <span class="comment">//调用方法</span></span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Bean基本属性"><a href="#Bean基本属性" class="headerlink" title="Bean基本属性"></a>Bean基本属性</h2><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221130175356015.png" alt="image-20221130175356015"></p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221130175501245.png" alt="image-20221130175501245"></p><p>scope默认单例的原因是：在非单例下，Ioc容器创建同一个类的bean多是不同的，对bean的复用性不高，当bean创建过多会导致性能的下降，还会浪费内存空间资源，故在单例模式下的优势在于，能避免实例重复创建；应用于避免存在多个实例引起程序逻辑错误的场合；较节约内存。</p><h2 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h2><ul><li>生命周期︰从创建到消亡的完整过程</li><li>bean生命周期：bean从创建到销毁的整体过程</li><li>bean生命周期控制：在bean创建后到销毁前做一些事情</li></ul><p>bean的生命周期可以实现InitializingBean，DisposableBean来重写bean的初始化和销毁的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span>, InitializingBean, DisposableBean &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;saving....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Bean被销毁前执行的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;destroy ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建Bean的初始化方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><p>概述：依赖注入(Dependency Injection) :它是Spring框架核心IOC的具体实现。在编写程序时，通过控制反转，把对象的创建交给了Spring，但是代码中不可能出现没有依赖的情况。IOC解耦只是降低他们的依赖关系，但不会消除。例如:业务层仍会调用持久层的方法。那这种业务层和持久层的依赖关系，在使用Spring之后，就让Spring来维护了。简单的说，就是坐等框架把持久层对象传入业务层，而不用我们自己去获取。</p><p><strong>setter依赖注入方式</strong></p><ol><li>在service层中定义成员变量来接收来自bean的注入</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="comment">//1. 创建一个dao对象，接收来自XMl文件注入bean</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    <span class="comment">//2. 构造set方法接收</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        bookDao.save();</span><br><span class="line">        System.out.println(<span class="string">&quot;service save ......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>在applicationContext.xml文件中配置如下，注意：其中name对应的值是set后边的单词，以小写开头，ref的值是将name的值赋值给定的类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 将bookDaoImpl类交给Spring的IOC管理(将其变为bean) --&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;bookDao&quot;</span> class=<span class="string">&quot;com.springbased.dao.impl.BookDaoImpl&quot;</span> /&gt;</span><br><span class="line">&lt;!-- 将bookServiceImpl类交给Spring的IOC管理(将其变为bean) --&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;bookService&quot;</span> class=<span class="string">&quot;com.springbased.service.impl.BookServiceImpl&quot;</span> &gt;</span><br><span class="line">    &lt;!--将service和dao通过property标签进行绑定--&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">        注意点：</span><br><span class="line">          name：是指向类属性的名称</span><br><span class="line">          ref：是指向bean中id为bookDao</span><br><span class="line">     --&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;bookDao&quot;</span> ref=<span class="string">&quot;bookDao&quot;</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221130181123964.png" alt="image-20221130181123964"></p><p><strong>构造器依赖注入</strong></p><ol><li>在service层中创建一个构造器如下</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="comment">//1. 创建一个dao对象，接收来自XMl文件注入bean</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BookServiceImpl</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. 创建一个构造器，为成员变量赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BookServiceImpl</span><span class="params">(BookDao bookDao, UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        bookDao.save();</span><br><span class="line">        System.out.println(<span class="string">&quot;service save ......&quot;</span>);</span><br><span class="line">        userDao.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>xml的配置如下，构造器注入的标签是constructor-arg</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 将bookDaoImpl类交给Spring的IOC管理(将其变为bean) --&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;bookDao&quot;</span> class=<span class="string">&quot;com.springbased1.dao.impl.BookDaoImpl&quot;</span>/&gt;</span><br><span class="line">&lt;!-- 将userDao加载成bean --&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;userDao&quot;</span> class=<span class="string">&quot;com.springbased1.dao.impl.UserDaoImpl&quot;</span>/&gt;</span><br><span class="line">&lt;!-- 将bookServiceImpl类交给Spring的IOC管理(将其变为bean) --&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;bookService&quot;</span> class=<span class="string">&quot;com.springbased1.service.impl.BookServiceImpl&quot;</span>&gt;</span><br><span class="line">    &lt;constructor-arg name=<span class="string">&quot;userDao&quot;</span> ref=<span class="string">&quot;userDao&quot;</span> /&gt;  </span><br><span class="line">    &lt;constructor-arg name=<span class="string">&quot;bookDao&quot;</span> ref=<span class="string">&quot;bookDao&quot;</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li>构造器注入的过程</li></ol><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221130183436290.png" alt="image-20221130183436290"></p><h2 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h2><p>配置中使用bean标签autowire属性设置自动装配的类型，如下所示是applicationContext.xml的配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 将bookDaoImpl类交给Spring的IOC管理(将其变为bean) --&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;bookDao&quot;</span> class=<span class="string">&quot;com.springbased1.dao.impl.BookDaoImpl&quot;</span>/&gt;</span><br><span class="line">&lt;!-- 将userDao加载成bean --&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;userDao&quot;</span> class=<span class="string">&quot;com.springbased1.dao.impl.UserDaoImpl&quot;</span>/&gt;</span><br><span class="line">&lt;!-- byType是按类型注入 还有按名称注入byName--&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;bookService&quot;</span> class=<span class="string">&quot;com.springbased1.service.impl.BookServiceImpl&quot;</span> autowire=<span class="string">&quot;byType&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="comment">//1. 创建一个dao对象，接收来自XMl文件注入bean</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="comment">//在自动注入，必须提供一个setter方法，Spring的IOC容器会从setter方法作为入口赋值给该类的成员变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        bookDao.save();</span><br><span class="line">        System.out.println(<span class="string">&quot;service save ......&quot;</span>);</span><br><span class="line">        userDao.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用自动装配时需注意一下几点</p><ul><li>自动装配用于引用类型依赖注入，不能对简单类型进行操作</li><li>使用按类型装配时( byType )必须保障容器中相同类型的bean唯一，推荐使用</li><li>使用按名称装配时（byName )必须保障容器中具有指定名称的bean，因变量名与配置耦合，不推荐使用</li><li>自动装配优先级低于setter注入与构造器注入，同时出现时自动装配配置失效</li></ul><h2 id="整合第三方数据源"><a href="#整合第三方数据源" class="headerlink" title="整合第三方数据源"></a>整合第三方数据源</h2><ol><li>导入druid坐标</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.2</span><span class="number">.11</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>在applicationContext.xml中配置如下</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;dataSource&quot;</span> class=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;driverClassName&quot;</span> value=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span> /&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;username&quot;</span> value=<span class="string">&quot;root&quot;</span> /&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;password&quot;</span> value=<span class="string">&quot;123456&quot;</span> /&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;url&quot;</span> value=<span class="string">&quot;jdbc:mysql//localhost:3306/test&quot;</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li>整合成功的标志</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//获取IOC容器中的Bean对象</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//从容器中获取数据源</span></span><br><span class="line">        <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> (DataSource)ac.getBean(<span class="string">&quot;dataSource&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221201130442404.png" alt="image-20221201130442404"></p><h3 id="加载properties配置文件中的配置信息"><a href="#加载properties配置文件中的配置信息" class="headerlink" title="加载properties配置文件中的配置信息"></a>加载properties配置文件中的配置信息</h3><p>开启context的命名空间，在xml页面上方增加如下信息</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221201131141810.png" alt="image-20221201131141810"></p><p>在resource目录下定义一个装连接数据库的配置文件.properties，配置信息如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jdbc.url=jdbc:mysql<span class="comment">//localhost:3306/test</span></span><br><span class="line">jdbc.druidName=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=<span class="number">123456</span></span><br></pre></td></tr></table></figure><p>在数据库连接配置中，使用占位符方式取出.properties文件中对应的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 利用context命令，使用通配符* 将所有的.properties文件引入--&gt;</span><br><span class="line">&lt;context:property-placeholder location=<span class="string">&quot;classpath:*.properties&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 使用$占位符方式，从.properties文件取出对应的值--&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;dataSource&quot;</span> class=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;driverClassName&quot;</span> value=<span class="string">&quot;$&#123;jdbc.druidName&#125;&quot;</span> /&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;username&quot;</span> value=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span> /&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;password&quot;</span> value=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span> /&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;url&quot;</span> value=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><h2 id="注解开发"><a href="#注解开发" class="headerlink" title="注解开发"></a>注解开发</h2><p><strong>使用注解@Component加载Bean</strong></p><ol><li>开启xml文件组件扫描，使用context命令</li><li>在需要的类上加上注解@Component(“bean名称”)即可将此类加载成Bean</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 开启组件扫描，若没有开启扫描，注解将会失效 base-<span class="keyword">package</span>是扫描的范围--&gt;</span><br><span class="line">&lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">&quot;com.springbased1&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">//将此类加载成Bean，未给这个bean命名，则默认类型加载</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;service save ......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//获取IOC容器中的Bean对象</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//根据数据类型获取bean</span></span><br><span class="line">        <span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> ac.getBean(BookService.class);</span><br><span class="line">        bookService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用@ComponentScan注解代替xml中的组件扫描</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">//标记该类是配置类</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.springbased1&quot;)</span> <span class="comment">//开启组件扫描</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComponentConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在用配置类替换xml配置文件则需从配置类中获取容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//从配置类中获取容器</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(ComponentConfig.class);</span><br><span class="line">        <span class="comment">//根据数据类型获取bean，根据数据类型获取时应注意在IOC容器中只能有一个该类型的数据。</span></span><br><span class="line">        <span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> ac.getBean(BookService.class);</span><br><span class="line">        bookService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring&quot;&gt;&lt;a href=&quot;#Spring&quot; class=&quot;headerlink&quot; title=&quot;Spring&quot;&gt;&lt;/a&gt;Spring&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;</summary>
      
    
    
    
    
    <category term="ssm" scheme="http://example.com/tags/ssm/"/>
    
  </entry>
  
  <entry>
    <title>在线课堂项目技术文档</title>
    <link href="http://example.com/2022/03/16/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E5%A0%82%E5%B9%B3%E5%8F%B0/"/>
    <id>http://example.com/2022/03/16/%E5%9C%A8%E7%BA%BF%E8%AF%BE%E5%A0%82%E5%B9%B3%E5%8F%B0/</id>
    <published>2022-03-16T10:45:00.000Z</published>
    <updated>2023-04-22T02:58:46.340Z</updated>
    
    <content type="html"><![CDATA[<h1 id="项目引入"><a href="#项目引入" class="headerlink" title="项目引入"></a>项目引入</h1><h2 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h2><p>本项目是本公司自研的一个专门针对成人职业技能教育的网络课堂系统，网站提供了成人职业技能培训的相关课程，如：软件开发培训、职业资格证书培训、成人学历教育培训等课程。项目基于B2B2C的业务模式，培训机构可以在平台入驻、发布课程，运营人员对发布的课程进行审核，审核通过后课程才可以发布成功，课程包括免费和收费两种形式，对于免费课程可以直接选课学习，对于收费课程在选课后需要支付成功才可以继续学习。</p><p><strong>什么是B2B2C？</strong><br>（ 1 ）B2B2C是一种电子商务类型的网络购物商业模式，B是Business的简称，C是Consumer的简称，第一个B指的是商品或服务的供应商，第二个B指的是从事电子商务的企业，C则是表示消费者。</p><p><strong>B2B的定义：</strong>企业跟企业之间的电子商务运作方式。</p><p><strong>B2C的定义：</strong>企业跟消费者之间的电子商务运作方式。</p><h2 id="项目模块"><a href="#项目模块" class="headerlink" title="项目模块"></a>项目模块</h2><p>本项目包括了用户端、机构端、运营端。</p><p>核心模块包括：内容管理、媒资管理、课程搜索、订单支付、选课管理、认证授权等。下图是项目的功能模块图:</p><p>下图是项目整体的功能模块</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230313185148244.png" alt="整体的功能模块图"></p><h2 id="Maven坐标依赖引入报红问题"><a href="#Maven坐标依赖引入报红问题" class="headerlink" title="Maven坐标依赖引入报红问题"></a>Maven坐标依赖引入报红问题</h2><p>在创建父工程项目时，引入了对应Maven坐标后再pom.xml文件中有很多的依赖是没有引到工程中的，那么这个问题的原因如下：</p><p>（ 1 ）Maven中的下载来源中不存在你所需要的坐标依赖包，我们可以在Maven目录下对<strong>settings.xml文件</strong>加入以下来源依赖，然后重新到工程中刷新maven即可。（进入maven&#x2F;conf）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus aliyun<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/repositories/central/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>internal nexus repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;url&gt;http://192.168.1.100:8081/nexus/content/groups/public/&lt;/url&gt;--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repo.maven.apache.org/maven2<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus aliyun<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus aliyun<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>Central<span class="tag">&lt;/<span class="name">id</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">url</span>&gt;</span>http://repo1.maven.org/maven2<span class="tag">&lt;/<span class="name">url</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（ 2 ）在父工程中有<dependencyManagement>的标签，该标签的作用是管理各个的依赖坐标版本，不会对依赖包进行下载，所以你工程中存在此标签的话可以先删除掉该标签，再进行一个Maven工程刷新，让爆红的依赖包下载到Maven工程中，最后在加上<dependencyManagement>即可解决。</p><p>（ 3 ）设置的问题，你可以打开IDEA的设置，看下Maven的设置是否和你自己下载的Maven相对应，如下图</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230314162731425.png" alt="设置"></p><h1 id="微服务项目搭建"><a href="#微服务项目搭建" class="headerlink" title="微服务项目搭建"></a>微服务项目搭建</h1><h2 id="功能模块注册到nacos中"><a href="#功能模块注册到nacos中" class="headerlink" title="功能模块注册到nacos中"></a>功能模块注册到nacos中</h2><p>（ 1 ）首先需要在父工程下引入以下坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud-alibaba.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（ 2 ）在需要注册到 nacos 中心的模块下引入以下坐标 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 引入nacos的配置管理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（ 3 ）编写配置文件，本项目中分为两种配置文件 bootstrap.properties 和 application.yml ，其中 bootstrap.properties 是用于nacos配置中心的文件，application.yml 是用于 nacos 注册发现的文件，如下格式</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">63110</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">education-online-system</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">education-online-space</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置nacos配置服务中心的ip地址</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.server-addr</span>=<span class="string">127.0.0.1:8848</span></span><br><span class="line"><span class="comment"># 命名空间</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.namespace</span>=<span class="string">education-online-space</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 指定nacos中心的配置文件</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.ext-config[0].data-id</span>=<span class="string">education-online-gateway.yaml</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.ext-config[0].group</span>=<span class="string">dev</span></span><br><span class="line"><span class="comment"># 是否自动刷新配置文件，当配置文件更新时，服务也会更新</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.ext-config[0].refresh</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure><h2 id="网关的搭建"><a href="#网关的搭建" class="headerlink" title="网关的搭建"></a>网关的搭建</h2><p>（ 1 ）需要新建立一个服务模块，可以命名 xxx-xxx-gateway</p><p>（ 2 ）引入依赖坐标，如下</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">&lt;!-- 网关依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 引入nacos的配置管理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（ 3 ）编写配置文件，如下</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 网关端口</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9999</span></span><br><span class="line"><span class="comment"># 注册到nacos中</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">education-online-gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">education-online-space</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 路由配置</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">content-service</span> <span class="comment"># 随便起，只要ID唯一即可</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://education-online-content</span> <span class="comment"># lb (LoadBalance)负载均衡</span></span><br><span class="line">          <span class="attr">predicates:</span> <span class="comment"># 路由断言：满足某些条件再执行请求</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/content/**</span>  <span class="comment"># 请求路径中带有content的会被路由分发到content-service中</span></span><br></pre></td></tr></table></figure><h2 id="分布式文件系统"><a href="#分布式文件系统" class="headerlink" title="分布式文件系统"></a>分布式文件系统</h2><h3 id="什么是分布式文件系统"><a href="#什么是分布式文件系统" class="headerlink" title="什么是分布式文件系统"></a>什么是分布式文件系统</h3><p><strong>概述：</strong>分布式文件系统（Distributed File System，DFS）是指文件系统管理的物理存储资源不一定直接连接在本地节点上，而是通过计算机网络与节点（可简单的理解为一台计算机）相连或是若干不同的逻辑磁盘分区或卷标组合在一起而形成的完整的有层次的文件系统。DFS为分布在网络上任意位置的资源提供一个逻辑上的树形文件系统结构，从而使用户访问分布在网络上的共享文件更加简便。单独的DFS共享文件夹的作用是相对于通过网络上的其他共享文件夹的访问点。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230322151156873.png" alt="image-20230322151156873"></p><p>**网络文件系统(NFS)**：是文件系统之上的一个网络抽象，来允许远程客户端以与本地文件系统类似的方式，来通过网络进行访问。虽然NFS不是第一个此类系统，但是它已经发展并演变成UNIX系统中最强大最广泛使用的网络文件系统。NFS允许在多个用户之间共享公共文件系统，并提供数据集中的优势，来最小化所需的存储空间。</p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230322151556299.png" alt="网络文件系统(NFS)" style="zoom:80%;" /><p>特点：</p><p>（ 1 ）在客户端上映射NFS服务器的驱动器。</p><p>（ 2 ）客户端通过网络访问NFS服务器的硬盘完全透明。</p><p><strong>googleFs：</strong>GFS是一个可扩展的分布式文件系统，用于大型的、分布式的、对大量数据进行访问的应用。它运行于廉价的普通硬件上，可以提供容错功能。它可以给人量的用户提供总体性能较高的服务。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230324123337626.png" alt="googleFs"></p><p>（ 1 ） GFS采用主从结构，一个GFS集群由一个master和大量的chunkserver组成。</p><p>（ 2 ） master存储了数据文件的元数据，一个文件被分成了若干块存储在多个chunkserver中</p><p>（ 3 ）用户从master中获取数据元信息，向chunkserver存储数据。</p><p><strong>HDFS：</strong>是Hadoop Distributed File. System的简称，是Hadoop抽象文件系统的一种实现。HDFS是一个高度容错性的系统，适缶部署在廉价的机器上。HDFS能提供高吞吐量的数据访问，非常适合大规模数据集上的应用。HDFS的文件分布在集群机器上，同时提供副本进行容错及可靠性保证。例如客户端写入读取文件的直接操作都是分布在集群各个机器上的，没有单点性能压力。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230322152102141.png" alt="HDFS架构图"></p><p>（ 1 ）HDFS采用主从结构，一个HDFS集群由一个名称结点和若干数据结点组成。</p><p>（ 2 ）名称结点存储数据的元信息，一个完整的数据文件分成若干块存储在数据结点。</p><p>（ 3 ）客户端从名称结点获取数据的元信息及数据分块的信息，得到信息客户端即可从数据块来存取数据。</p><h3 id="minio文件系统"><a href="#minio文件系统" class="headerlink" title="minio文件系统"></a>minio文件系统</h3><p><strong>概述：</strong></p><p>（ 1 ）采用MinlO构建分布式文件系统，MinlO是一个非常轻量的服务,可以很简单的和其他应用的结合使用，它兼容亚马逊S3云存储服务接口，非常适合于存储大容量非结构化的数据，例如图片、视频、日志文件、备份数据和容器&#x2F;虚拟机镜像等。</p><p>（ 2 ）它一大特点就是轻量，使用简单，功能强大，支持各种平台，单个文件最大5TB，兼容Amazon S3接口，提供了Java、Python、GO等多版本SDK支持。</p><p>（ 3 ）MinlO集群采用去中心化共享架构，每个结点是对等关系，通过Nginx可对MinlO进行负载均衡访问。去中心化有什么好处？</p><p><strong>好处：</strong>在大数据领域，通常的设计理念都是无中心和分布式Minio分布式模式可以帮助你搭建一个高可用的对象存储服务，你可以使用这些存储设备，而不用考虑其真实物理位置。它将分布在不同服务器上的多块硬盘组成一个对象存储服务。由于硬盘分布在不同的节点上，分布式Minio避免了单点故障。如下图：</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230322152729473.png" alt="MinlO进行负载均衡访问"></p><p>Minio使用**<u>纠删码技术</u>**来保护数据，它是一种恢复丢失和损坏数据的数学算法，它将数据分块冗余的分散存储在各各节点的磁盘上，所有的可用磁盘组成一个集合，上图由8块硬盘组成一个集合，当上传一个文件时会通过纠删码算法计算对文件进行分块存储，除了将文件本身分成4个数据块，还会生成4个校验块，数据块和校验块会分散的存储在这8块硬盘上。</p><p>使用纠删码的好处是即便丢失一半数量（N&#x2F;2）的硬盘，仍然可以恢复数据。比如上边集合中有4个以内的硬盘损害仍可保证数据恢复，不影响上传和下载，如果多于一半的硬盘坏了则无法恢复。</p><p><strong>执行以下命令可以创建minio的文件存储节点</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minio.exe server 文件节点路径 ...</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minio.exe server D:\java\minio\develop\data1 D:\java\minio\develop\data2</span><br></pre></td></tr></table></figure><p>根据控制台所提示的路径访问</p><h3 id="使用-JAVA-客户端-SDK"><a href="#使用-JAVA-客户端-SDK" class="headerlink" title="使用 JAVA 客户端 SDK"></a>使用 JAVA 客户端 SDK</h3><p>（ 1 ）引入 minio 的 SDK 依赖坐标（需要 JDK1.8 版本以上）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.squareup.okhttp3<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>okhttp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.minio<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>minio<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.4.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（ 2 ）上传文件 和 删除文件的测试代码如下，当测试成功后即可在WEB控制台中到目标文件目录下看到上传的文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EducationOnlineMediaApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建minio的客户端</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">MinioClient</span> <span class="variable">minioClient</span> <span class="operator">=</span> MinioClient.builder()</span><br><span class="line">            .endpoint(<span class="string">&quot;http://127.0.0.1:9000&quot;</span>) <span class="comment">// url路径</span></span><br><span class="line">            .credentials(<span class="string">&quot;minioadmin&quot;</span>,<span class="string">&quot;minioadmin&quot;</span>) <span class="comment">// 登入秘钥</span></span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  上传文件测试</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">uploadFile</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       <span class="comment">// 获取所指定的类型</span></span><br><span class="line">        <span class="type">ContentInfo</span> <span class="variable">contentType</span> <span class="operator">=</span> ContentInfoUtil.findExtensionMatch(<span class="string">&quot;.mp4&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置上传的相关参数</span></span><br><span class="line">        <span class="type">UploadObjectArgs</span> <span class="variable">video</span> <span class="operator">=</span> UploadObjectArgs.builder()</span><br><span class="line">                .bucket(<span class="string">&quot;video&quot;</span>) <span class="comment">// 指定桶的名称</span></span><br><span class="line">                .filename(<span class="string">&quot;D:/video/wuti.mp4&quot;</span>)  <span class="comment">// 指定本地文件</span></span><br><span class="line">                .object(<span class="string">&quot;wuti.mp4&quot;</span>) <span class="comment">// 对象名称 -&gt; 可以看成文件名</span></span><br><span class="line">                .contentType(contentType.getMimeType())</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用MinioClient对象上传</span></span><br><span class="line">        minioClient.uploadObject(video);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  删除文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">removeFile</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">RemoveObjectArgs</span> <span class="variable">args</span> <span class="operator">=</span> RemoveObjectArgs.builder()</span><br><span class="line">                .bucket(<span class="string">&quot;video&quot;</span>)</span><br><span class="line">                .object(<span class="string">&quot;wuti.mp4&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        minioClient.removeObject(args);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  下载文件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">downloadFile</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 配置下载文件的相关参数</span></span><br><span class="line">        <span class="type">GetObjectArgs</span> <span class="variable">args</span> <span class="operator">=</span> GetObjectArgs.builder()</span><br><span class="line">                .bucket(<span class="string">&quot;video&quot;</span>)</span><br><span class="line">                .object(<span class="string">&quot;wuti.mp4&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">// 调用客户端下载</span></span><br><span class="line">        <span class="type">GetObjectResponse</span> <span class="variable">response</span> <span class="operator">=</span> minioClient.getObject(args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过二进制读取文件，在下载到本地磁盘中 可能会出现网络丢包问题</span></span><br><span class="line">        <span class="type">byte</span>[] buff = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> Files.newOutputStream(Paths.get(<span class="string">&quot;D:\\video\\test.mp4&quot;</span>));</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = response.read(buff)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            os.write(buff,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 比较文件的完整性</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（ 3 ）contentType：设置contentType可以通过com.j256.simplemagic.ContentType枚举类查看常用的mimeType(媒体类型)通过扩展名得到mimeType，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取所指定的类型</span></span><br><span class="line"><span class="type">ContentInfo</span> <span class="variable">contentType</span> <span class="operator">=</span> ContentInfoUtil.findExtensionMatch(<span class="string">&quot;.mp4&quot;</span>);</span><br></pre></td></tr></table></figure><h1 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h1><h2 id="上传图片业务"><a href="#上传图片业务" class="headerlink" title="上传图片业务"></a>上传图片业务</h2><p>上传课程图片总体上包括两部分：</p><p>1、上传课程图片前端请求媒资管理服务将文件上传至分布式文件系统，并且在媒资管理数据库保存文件信息。</p><p>2、上传图片成功保存图片地址到课程基本信息表中。</p><p>过程图：</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230322170846166.png" alt="图片上传业务过程"></p><p>（ 1 ）前端进入上传图片界面。</p><p>（ 2 ）上传图片，请求媒资管理服务。</p><p>（ 3 ）媒资管理服务将图片文件存储在MinlO。</p><p>（ 4 ）媒资管理记录文件信息到数据库。</p><p>（ 5 ）前端请求内容管理服务保存课程信息，在内容管理数据库保存图片地址。</p><h3 id="在Nacos中配置minio的相关参数"><a href="#在Nacos中配置minio的相关参数" class="headerlink" title="在Nacos中配置minio的相关参数"></a>在Nacos中配置minio的相关参数</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">minio:</span></span><br><span class="line">  <span class="attr">endpoint:</span> <span class="string">http://127.0.0.1:9000</span></span><br><span class="line">  <span class="attr">accessKey:</span> <span class="string">minioadmin</span></span><br><span class="line">  <span class="attr">secretKey:</span> <span class="string">minioadmin</span></span><br><span class="line">  <span class="attr">bucket:</span> </span><br><span class="line">    <span class="attr">imgFile:</span> <span class="string">image</span></span><br><span class="line">    <span class="attr">videoFile:</span> <span class="string">video</span></span><br></pre></td></tr></table></figure><p>配置完成后需要在业务中通过注解@Value(“${}”)来注入，将minoClient对象注入到IOC容器中，如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  媒资配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinioConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MinioConfigProperties minioProperties;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 注入到IOC容器的MinioClient</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MinioClient <span class="title function_">minioClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> MinioClient.builder()</span><br><span class="line">                .endpoint(minioProperties.getEndpoint())</span><br><span class="line">                .credentials(minioProperties.getAccessKey(),minioProperties.getSecretKey())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="上传视频业务"><a href="#上传视频业务" class="headerlink" title="上传视频业务"></a>上传视频业务</h2><h3 id="什么是断点续传？"><a href="#什么是断点续传？" class="headerlink" title="什么是断点续传？"></a>什么是断点续传？</h3><p>​通常视频文件都比较大，所以对于媒资系统上传文件的需求要满足大文件的上传要求。http协议本身对上传文件大小没有限制，但是客户的网络环境质量、电脑硬件环境等参差不齐，如果一个大文件快上传完了网断了没有上传完成，需要客户重新上传，用户体验非常差，所以对于大文件上传的要求最基本的是断点续传。</p><p><strong>引用百度百科：</strong>断点续传指的是在下载或上传时，将下载或上传任务（一个文件或一个压缩包)人为的划分为几个部分，每一个部分采用一个线程进行上传或下载，如果碰到网络故障，可以从已经上传或下载的部分开始继续上传下载未完成的部分，而没有必要从头开始上传下载，断点续传可以提高节省操作时间，提高用户体验性。</p><p>下图是断点续传的原理过程图：</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230324104009498.png" alt="断点续传的原理过程图"></p><p>过程文字说明：</p><p>1、前端上传前先把文件分成块</p><p>2、一块一块的上传，上传中断后重新上传，已上传的分块则不用再上传</p><p>3、各分块上传完成最后在服务端合并文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  分块测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChunkTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  分块</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">chunkFileTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 创建原文件对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">sourceFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\video\\test.mp4&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建分块文件的路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">chunkFilePath</span> <span class="operator">=</span> <span class="string">&quot;D:\\video\\chunk\\test\\&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分块文件的大小 1MB</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">chunkSize</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分为几块文件块</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">chunkNumber</span> <span class="operator">=</span> (<span class="type">int</span>)Math.ceil( (sourceFile.length() * <span class="number">1.0</span>) / chunkSize );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 写缓存区</span></span><br><span class="line">        <span class="type">byte</span>[] buff= <span class="keyword">new</span> <span class="title class_">byte</span>[chunkSize];</span><br><span class="line">        <span class="comment">// 创建原文件【读流】对象</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(sourceFile);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; chunkNumber; ++ i )&#123;</span><br><span class="line">            <span class="comment">// 创建文件块对象</span></span><br><span class="line">            <span class="type">File</span> <span class="variable">chunkFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(chunkFilePath + i);</span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(chunkFile);</span><br><span class="line">            <span class="comment">// 读取原文件流并写入到分块文件中去</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((len = fis.read(buff)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                fos.write(buff,<span class="number">0</span>,len);</span><br><span class="line">                <span class="keyword">if</span>(chunkFile.length() &gt;= chunkSize) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            fos.close();</span><br><span class="line">        &#125;</span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 合并</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">margeFileTest</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 创建源文件对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">sourceFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\video\\test.mp4&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建合并后所放目录对象</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">afterMargePath</span> <span class="operator">=</span> <span class="string">&quot;D:\\video\\chunk\\marge.mp4&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 文件块所在的目录</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\video\\chunk\\test&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取文件块个数（有序）</span></span><br><span class="line">        File[] files = file.listFiles();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(files == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 排序</span></span><br><span class="line">        Arrays.sort(files, Comparator.comparingInt(o -&gt; Integer.parseInt(o.getName())));</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] buff = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(afterMargePath);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历个数进行合并</span></span><br><span class="line">        <span class="keyword">for</span> (File part: files) &#123;</span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(part);</span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="comment">// 写入操作</span></span><br><span class="line">            <span class="keyword">while</span> ((len = fis.read(buff)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                fos.write(buff,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">            fis.close();</span><br><span class="line">        &#125;</span><br><span class="line">        fos.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 校验合成的文件和原文件是否相同</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sourceMd5</span> <span class="operator">=</span> DigestUtils.md5DigestAsHex(Files.newInputStream(sourceFile.toPath()));</span><br><span class="line">        <span class="type">String</span> <span class="variable">margeMd5</span> <span class="operator">=</span> DigestUtils.md5DigestAsHex(Files.newInputStream(Paths.get(afterMargePath)));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(sourceMd5.equals(margeMd5)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;合并成功~~~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="业务流程"><a href="#业务流程" class="headerlink" title="业务流程"></a>业务流程</h3><p><strong>概述版本的通信图</strong></p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230324123532267.png" alt="业务流程图"></p><p>在此项目中存在一个问题。就是Spring  Mvc默认只能接受1MB和文件最大尺寸1MB，所以需要在配置文件中配置相关的参数</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">multipart:</span></span><br><span class="line">      <span class="attr">max-file-size:</span> <span class="string">50MB</span></span><br><span class="line">      <span class="attr">max-request-size:</span> <span class="string">50MB</span></span><br></pre></td></tr></table></figure><p><strong>业务通信图如下所示</strong></p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230328220652059.png" alt="文件业务通信图"></p><p>（ 1 ）<strong>文件</strong>上传前的检查：检查文件是否在数据库中和minio分布式文件存储系统中存在，若minio分布式文件存储系统不存在该文件，则可以进行下一步，否则文件不能上传到minio中</p><p>（ 2 ）上传<strong>文件块</strong>前的检查：检查minio分布式文件系统中是否存在该文件块，若存在则响应给前端结果文为true，若文件块不存在则返回false</p><p>（ 3 ）上传文件块到minio：需要先将前端传来的文件块<strong>临时保存到本地磁盘</strong>，然后对文件块进行上传，最后将临时保存的文件块进行删除</p><p>（ 4 ）合并文件块：当所有的文件块都上传到minio中，则就开始对于这些文件块进行合并成为一个完整文件保存到minio，当合并完成后需要进行文件的是否无损的合并比较（可以使用md5对文件进行比较），比较完成后就将minio上的文件块进行删除操作。</p><p><strong>md5文件比较介绍：</strong>当文件的长度和原本的文件长度相同，则生成的md5字符串是一样的，否则是不一样的。</p><h2 id="视频转码业务"><a href="#视频转码业务" class="headerlink" title="视频转码业务"></a>视频转码业务</h2><h3 id="视频编码的介绍（来自百度百科）"><a href="#视频编码的介绍（来自百度百科）" class="headerlink" title="视频编码的介绍（来自百度百科）"></a>视频编码的介绍（来自百度百科）</h3><p>所谓视频<a href="https://baike.baidu.com/item/%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F/6451499">编码方式</a>就是指通过<a href="https://baike.baidu.com/item/%E5%8E%8B%E7%BC%A9%E6%8A%80%E6%9C%AF/1444262">压缩技术</a>，将原始<a href="https://baike.baidu.com/item/%E8%A7%86%E9%A2%91%E6%A0%BC%E5%BC%8F/123472">视频格式</a>的文件转换成另一种视频格式文件的方式。<a href="https://baike.baidu.com/item/%E8%A7%86%E9%A2%91%E6%B5%81/9392168">视频流</a>传输中最为重要的编解码标准有<a href="https://baike.baidu.com/item/%E5%9B%BD%E9%99%85%E7%94%B5%E8%81%94/6302433">国际电联</a>的H.261、H.263、H.264，运动静止图像专家组的M-JPEG和国际标准化组织运动图像专家组的MPEG系列标准，此外在互联网上被广泛应用的还有Real-Networks的RealVideo、微软公司的WMV以及Apple公司的QuickTime等。</p><p>首先我们要分清文件格式和编码格式</p><p><strong>（ 1 ）文件格式：</strong>是指.mp4、.avi、.rmvb等这些不同扩展名的视频文件的文件格式，视频文件的内容主要包括视频和音频，其文件格式是按照一定的编码格式去编码，并且按照该文件所规定的封装格式将视频、音频、字幕等信息封装在一起，播放器会根据它们的封装格式去提取出编码，然后由播放器解码，最终播放音视频。</p><p><strong>（ 2 ）音视频编码格式：</strong>通过音视频的压缩技术，将视频格式转换成另一种视频格式，通过视频编码实现流媒体的传输</p><p>​比如：一个.avi的视频文件原来的编码是a，通过编码后编码格式变为b，音频原来为c，通过编码后变为d。</p><h3 id="当前业务需求的分析"><a href="#当前业务需求的分析" class="headerlink" title="当前业务需求的分析"></a>当前业务需求的分析</h3><p>将视频的文件格式转换成【.mp4】，视频的编码格式为【H.264】，音频编码格式为【ACC】 这些都是可以使用开源的ffmpeg来实现的</p><p>ffmpeg的官网地址：<a href="https://ffmpeg.org/">https://ffmpeg.org/</a></p><h3 id="文件格式和MIMETYPE的对应表"><a href="#文件格式和MIMETYPE的对应表" class="headerlink" title="文件格式和MIMETYPE的对应表"></a>文件格式和MIMETYPE的对应表</h3><table><thead><tr><th align="center">minetype</th><th align="center">文件格式</th></tr></thead><tbody><tr><td align="center">application&#x2F;msword</td><td align="center">doc</td></tr><tr><td align="center">application&#x2F;pdf</td><td align="center">pdf</td></tr><tr><td align="center">application&#x2F;rtf</td><td align="center">rtf</td></tr><tr><td align="center">application&#x2F;vnd.ms-excel</td><td align="center">xls</td></tr><tr><td align="center">application&#x2F;vnd.ms-powerpoint</td><td align="center">ppt</td></tr><tr><td align="center">application&#x2F;zip</td><td align="center">zip</td></tr><tr><td align="center">audio&#x2F;mpeg</td><td align="center">mp3</td></tr><tr><td align="center">image&#x2F;gif</td><td align="center">gif</td></tr><tr><td align="center">image&#x2F;jpeg</td><td align="center">jpeg jpg</td></tr><tr><td align="center">image&#x2F;png</td><td align="center">png</td></tr><tr><td align="center">text&#x2F;plain</td><td align="center">txt</td></tr><tr><td align="center">video&#x2F;mp4</td><td align="center">mp4</td></tr><tr><td align="center">video&#x2F;x-msvideo</td><td align="center">avi</td></tr><tr><td align="center">video&#x2F;x-flv</td><td align="center">flv</td></tr></tbody></table><h1 id="分布式任务处理"><a href="#分布式任务处理" class="headerlink" title="分布式任务处理"></a>分布式任务处理</h1><h2 id="什么是分布式任务调度"><a href="#什么是分布式任务调度" class="headerlink" title="什么是分布式任务调度"></a>什么是分布式任务调度</h2><p>我们可以先思考一下下面业务场景的解决方案：</p><ul><li>某电商系统需要在每天上午10点，下午3点，晚上8点发放一批优惠券。</li><li>某银行系统需要在信用卡到期还款日的前三天进行短信提醒。</li><li>某财务系统需要在每天凌晨0:10结算前一天的财务数据，统计汇总。</li><li>12306会根据车次的不同，而设置某几个时间点进行分批放票。</li><li>某网站为了实现天气实时展示，每隔5分钟就去天气服务器获取最新的实时天气信息。</li></ul><p>以上场景就是任务调度所需要解决的问题。</p><p><strong>任务调度是指系统为了自动完成特定任务，在约定的特定时刻去执行任务的过程。有了任务调度即可解放更多的人力由系统自动去执行任务。</strong></p><p>​通常任务调度的程序是集成在应用中的，比如：优惠卷服务中包括了定时发放优惠卷的的调度程序，结算服务中包括了定期生成报表的任务调度程序，由于采用分布式架构，一个服务往往会部署多个冗余实例来运行我们的业务，在这种分布式系统环境下运行任务调度，我们称之为<strong>分布式任务调度</strong>，如下图：</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230329195957249.png" alt="分布式任务调度图"></p><p>例如上图所示：分布式任务调度让原本只有一个实例来执行业务变成可以有多个实例执行同一个业务。</p><h2 id="xx-job-中间件"><a href="#xx-job-中间件" class="headerlink" title="xx-job 中间件"></a>xx-job 中间件</h2><h3 id="前提概述"><a href="#前提概述" class="headerlink" title="前提概述"></a>前提概述</h3><p>源码地址：</p><p>（ 1 ）码云：<a href="https://gitee.com/xuxueli0323/xxl-job.git">https://gitee.com/xuxueli0323/xxl-job.git</a></p><p>（ 2 ）github：<a href="https://github.com/xuxueli/xxl-job.git">https://github.com/xuxueli/xxl-job.git</a></p><p>xx-job是用 java 程序开发的分布式任务调度的中间件，所以需要有 java 程序运行的环境如下</p><ul><li>Maven 3+</li><li>Jdk 1.7+</li><li>Mysql 5.6+</li></ul><h3 id="xx-job-中间件原理说明"><a href="#xx-job-中间件原理说明" class="headerlink" title="xx-job 中间件原理说明"></a>xx-job 中间件原理说明</h3><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230329164145311.png" alt="架构图"></p><p><strong>执行流程：</strong></p><p>（ 1 ）任务执行器根据配置的调度中心的地址，自动注册到调度中心</p><p>（ 2 ）达到任务触发条件，调度中心下发任务</p><p>（ 3 ）执行器基于线程池执行任务，并把执行结果放入内存队列中、把执行日志写入日志文件中</p><p>（ 4 ）执行器消费内存队列中的执行结果，主动上报给调度中心</p><p>（ 5 ）当用户在调度中心查看任务日志，调度中心请求任务执行器，任务执行器读取任务日志文件并返回日志详情</p><hr style="color:red;height:10px"><p>xxl-job主要的组成部分有：调度中心、执行器、任务。</p><p><strong>（ 1 ）调度中心：</strong></p><p>​负责管理调度信息，按照调度配置发出调度请求，自身不承担业务代码</p><p>​主要职责为执行器管理、任务管理、监控运维、日志管理等</p><p><strong>（ 2 ）执行器：</strong></p><p>​负责接收调度请求并执行任务逻辑</p><p>​主要职责是注册服务、任务执行服务（接收到任务后会放入线程池中的任务队列)、执行结果上报、日志服务等</p><p><strong>（ 3 ）任务：</strong></p><p>​具体的业务代码</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230329201019023.png" alt="三者关系图"></p><hr style="color:red;height:10px"<h3 id="搭建-xx-job-任务调度中心"><a href="#搭建-xx-job-任务调度中心" class="headerlink" title="搭建 xx-job 任务调度中心"></a>搭建 xx-job 任务调度中心</h3><p>（ 1 ）首先需要到码云或者GitHub将其源码下载到本机上，然后使用IDEA打开，把里面【doc&#x2F;db】中的数据库脚本文件，在数据库中新建一个数据库用于放xx-job的数据库脚本文件<span style="color:red">（注意，需要修改源代码中数据库的地址）</span>。</p><p>（ 2 ）运行xxl-job-admim目录下的application，然后访问<a href="http://localhost:8080/xxl-job-admin/">http://localhost:8080/xxl-job-admin/</a>  （账号 &#x2F; 密码  -&gt; admin &#x2F; 123456）</p><p>（ 3 ）<strong>配置执行器</strong>，执行器负责与调度中心通信接收调度中心发起的任务调度请求。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230329170930725.png" alt="配置执行器"></p><p>（ 4 ）在需要任务调度的模块下引入下列依赖坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.xuxueli<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xxl-job-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（ 5 ）在nacos下的yaml文件中配置 xxl-job</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">xxl:</span></span><br><span class="line">  <span class="attr">job:</span></span><br><span class="line">    <span class="attr">admin:</span></span><br><span class="line">      <span class="attr">addresses:</span> <span class="string">http://127.0.0.1:8080/xxl-job-admin</span></span><br><span class="line">    <span class="attr">executor:</span></span><br><span class="line">      <span class="attr">appname:</span> <span class="string">test-media</span></span><br><span class="line">      <span class="attr">address:</span> <span class="comment">#  空着，不要填写，由xxl-job自动分配</span></span><br><span class="line">      <span class="attr">ip:</span> <span class="comment"># 空着，不要填写</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">9999</span></span><br><span class="line">      <span class="attr">logpath:</span> <span class="string">/data/applogs/xxl-job/jobhandler</span></span><br><span class="line">      <span class="attr">logretentiondays:</span> <span class="number">30</span></span><br><span class="line">    <span class="attr">accessToken:</span> <span class="string">default_token</span></span><br><span class="line"><span class="comment">#配置本地优先</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"> <span class="attr">cloud:</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="attr">override-none:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>（ 6 ）在 xxl-job 源码中有提供一个配置文件【src&#x2F;main&#x2F;java&#x2F;com&#x2F;xxl&#x2F;job&#x2F;executor&#x2F;core&#x2F;config】这个目录下的java配置类复制放到自己项目中即可。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230329183214200.png" alt="配置"></p><p>（ 7 ）进入【任务管理】界面，新增任务，如下图的设置（图中还有一个 jobHandler 是在服务器中所定义的<span style="color:red">任务名称</span>）</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230329191459731.png" alt="新增任务设置图"></p><p>（ 8 ）从xxl-job的源码中目录【src&#x2F;main&#x2F;java&#x2F;com&#x2F;xxl&#x2F;job&#x2F;executor&#x2F;service&#x2F;jobhandler】这个目录复制到自己的项目下，里面定义了 xxl-job 的任务</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230329192054234.png" alt="服务器中的任务定义格式"></p><h3 id="高级参数配置"><a href="#高级参数配置" class="headerlink" title="高级参数配置"></a>高级参数配置</h3><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230331152916463.png" alt="高级配置说明图"></p><p style="color:red">路由策略的说明表如下</p><table><thead><tr><th align="center">路由策略名称</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">第一个</td><td align="center">固定选择第一个机器</td></tr><tr><td align="center">轮询</td><td align="center">逐个选择正常的机器</td></tr><tr><td align="center">随机</td><td align="center">随机选择在线的机器</td></tr><tr><td align="center">一致性HASH</td><td align="center">每个任务按照Hash算法固定选择某一台机器，且所有任务均匀散列在不同机器上</td></tr><tr><td align="center">最不经常使用</td><td align="center">使用频率最低的机器优先被选举</td></tr><tr><td align="center">最近最久未使用</td><td align="center">最久未使用的机器优先被选举</td></tr><tr><td align="center">故障转移</td><td align="center">按照顺序依次进行心跳检测，第一个心跳检测成功的机器选定为目标执行器并发起调度</td></tr><tr><td align="center">忙碌转移</td><td align="center">按照顺序依次进行空闲检测，第一个空闲检测成功的机器选定为目标执行器并发起调度</td></tr><tr><td align="center">分片广播</td><td align="center">广播触发对应集群中所有机器执行一次任务，同时系统自动传递分片参数；可根据分片参数开发分片任务</td></tr></tbody></table><p style="color:red">任务调度过期策略</p><table><thead><tr><th align="center">过期策略名称</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">忽略</td><td align="center">调度过期后，忽略过期的任务，从当前时间开始重新计算下次触发时间</td></tr><tr><td align="center">立即执行一次</td><td align="center">调度过期后，立即执行一次，并从当前时间开始重新计算下次触发时间</td></tr></tbody></table><p style="color:red">阻塞过期策略</p><table><thead><tr><th align="center">阻塞过期策略</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">单机串行（默认）</td><td align="center">调度请求进入单机执行器后，调度请求进入FIFO队列并以串行方式运行</td></tr><tr><td align="center">丢弃后续调度</td><td align="center">调度请求进入单机执行器后，发现执行器存在运行的调度任务，本次请求将会被丢弃并标记为失败</td></tr><tr><td align="center">覆盖之前调度</td><td align="center">调度请求进入单机执行器后，发现执行器存在运行的调度任务，将会终止运行中的调度任务并清空队列，然后运行本地调度任务</td></tr></tbody></table><p>任务超时时间：支持自定义任务超时时间，任务运行超时将会主动中断任务</p><p>失败重试次数：支持自定义任务失败重试次数，当任务失败时将会按照预设的失败重试次数主动进行重试</p><h3 id="分片广播"><a href="#分片广播" class="headerlink" title="分片广播"></a>分片广播</h3><p>调度中心会向当前任务的所有执行器节点都发起一个调度请求，并且带上分片参数。执行器在收到请求之后，可以通过<code>index</code>的值，以不同<code>index</code>的值来做分片策略。每个执行器收到调度请求同时接收分片参数。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230331145951213.png" alt="分片广播图解"></p><p><span style="color:blue">xxl-job支持动态扩容执行器集群从而动态增加分片数量，当有任务量增加可以部署更多的执行器到集群中，调度中心会动态修改分片的数量。</span ></p><p>在创建新的任务管理时选择下图所示的配置即可</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230331150919155.png" alt="image-20230331150919155"></p><p>两个实例的在启动时注意端口不能冲突：</p><p>实例1：在VM options处添加：-Dserver.port&#x3D;63051 -Dxxl.job.executor.port&#x3D;9998</p><p>实例2：在VM options处添加：-Dserver.port&#x3D;63050 -Dxxl.job.executor.port&#x3D;9999</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230331152443837.png" alt="配置"></p><p>启动两个实例，观察任务调度中心，稍等片刻执行器有两个就说明这两个任务就可以正常的被调度。</p><p><strong>作业分片适用哪些场景呢？</strong></p><p>（ 1 ）分片任务场景：10个执行器的集群来处理10w条数据，每台机器只需要处理1w条数据，耗时降低10倍；</p><p>（ 2 ）广播任务场景：广播执行器同时运行shell脚本，广播集群节点进行缓存更新等。</p><p>所以，广播分片方式不仅可以充分发挥每个执行器的能力，并且根据分片参数可以控制任务是否执行，最终灵活控制了执行器集群分布式处理任务。</p><h1 id="视频处理"><a href="#视频处理" class="headerlink" title="视频处理"></a>视频处理</h1><p>（ 1 ）业务需求：视频上传成功需要对视频的格式进行转码处理，比如：.avi的文件转成mp4文件。</p><h2 id="作业分片技术方案"><a href="#作业分片技术方案" class="headerlink" title="作业分片技术方案"></a>作业分片技术方案</h2><p>在视频上传成功后，会将视频的基础信息保存到数据库的【<strong>视频基础信息表</strong>】和【<strong>视频待处理任务表</strong>】。现在启动多个执行器实例去查询这些待处理任务<strong>【技术难点1】此时如何保证多个执行器不会查询到重复的任务呢</strong></p><p>那么可以根据：xxl-job 调度中心会给执行器分配好分片序号，在向执行器任务调度的同时下发<strong>分片总数</strong>以及<strong>分片序号</strong>等参数，执行器收到这些参数根据自己的业务需求去利用这些参数。如下图</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230331161305148.png" alt="技术难点1解决方案说明图"></p><h2 id="保证任务不重复执行"><a href="#保证任务不重复执行" class="headerlink" title="保证任务不重复执行"></a>保证任务不重复执行</h2><p><strong>【技术难点2】通过作业分片方案保证了执行器之间查询到不重复的任务，如果一个执行器在处理一个视频还没有完成，此时调度中心又一次请求调度，为了不重复处理同一个视频该怎么办？</strong></p><p>可以根据 xxl-job 高级参数设置中的一些策略是解决方案的切入点</p><p>（ 1 ）调度过期策略选择【忽略】，原因是：若是选择了【立即执行一次】，可能会出现下图所示的情况</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230331164322751.png" alt="切入点1：调度过期策略选择"></p><p>（ 2 ）堵塞处理策略选择【丢弃后续调度】，这里如果选择【覆盖之前调度】则可能重复执行任务，这里选择丢弃后续调度或单机串行方式来避免任务重复执行。</p><p><strong>【技术难点3】保证接口的任务的幂等性</strong></p><p>（ 1 ）幂等性：它描述了一次和多次请求某一个资源对于资源本身中该是有同样的结果。</p><p>（ 2 ）幂等性是为了解决重复提交问题，比如：恶意刷单，重复支付等。</p><p>（ 3 ）解决幂等性常用的方案：</p><p>​1）数据库约束，比如：唯一索引，主键。</p><p>​2）乐观锁，常用于数据库，更新数据时根据乐观锁状态去更新。</p><p>​3）唯一序列号，操作传递一个唯一序列号，操作时判断与该序列号相等则执行。</p><p>在本项目中可以在任务待处理表中增加一个标记字段来说明某个任务是否被执行过，每次查询数据库时都需要带上该标记字段，查询未处理的任务</p><h2 id="网络传输导致重复执行"><a href="#网络传输导致重复执行" class="headerlink" title="网络传输导致重复执行"></a>网络传输导致重复执行</h2><p>问题描述：在 xxl-job 分布式任务调度中每个执行器都是定义在应用程序源码中，所以任务执行器和调度中心是通过网络调度的，有时候网络不稳定导致执行器挂掉了，由于 xxl-job 的特性对于执行器的编号和总数是动态变化的。</p><p>场景假设：现有3个执行器在执行任务，其中编号为0的执行器由于网络原因挂掉了，那么这时候调度中心对执行器会重新编号，其余两个的其中一个可能会重复处理前执行器0所处理的任务。【在以上方案的基础上】</p><p><strong>根本原因：多个执行器对于共享资源的修改</strong></p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230401133054450.png" alt="image-20230401133054450"></p><p style="color:blue">解决方案：</p><p>（ 1 ）加锁：加普通的锁并不能解决此问题，需要加分布式锁即可解决</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(锁对象)&#123;</span><br><span class="line">   执行任务...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230401134321779.png" alt="synchronized锁"></p><p>（ 2 ）分布式锁：虚拟机都去抢占同一个锁，锁是一个单独的程序提供加锁、解锁服务。该锁已不属于某个虚拟机，而是分布式部署，由多个虚拟机所共享，这种锁叫分布式锁。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230401135107703.png" alt="分布式锁"></p><p><strong>（ 3 ）分布式锁实现方案：</strong></p><p>​1 ）基于数据库实现分布锁：利用数据库主键唯一性的特点，或利用数据库唯一索引、行级锁的特点，多个线程同时去更新相同的记录，谁更新成功谁就抢到锁。</p><p>​2 ）基于redis实现锁：redis提供了分布式锁的实现方案，比如：setnx、set nx、redisson等。拿SETNX举例说明，SETNX命令的工作过程是去set一个不存在的key，多个线程去设置同一个key只会有一个线程设置成功，设置成功的的线程拿到锁。</p><p>​3 ）使用zookeeper实现：zookeeper是一个分布式协调服务，主要解决分布式程序之间的同步的问题。zookeeper的结构类似的文件目录，多线程向zookeeper创建一个子目录(节点)只会有一个创建成功，利用此特点可以实现分布式锁，谁创建该结点成功谁就获得锁。</p><h2 id="整体业务流程梳理"><a href="#整体业务流程梳理" class="headerlink" title="整体业务流程梳理"></a>整体业务流程梳理</h2><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230331171958698.png" alt="业务图解"></p><p>（ 1 ）前端页面通过文件分块上传到服务端，经媒资服务再上传到minio分布式文件服务中</p><p>（ 2 ）媒资服务将视频文件上传成功后会保存视频文件的【基本信息表】和文件格式需要转换的【待处理表】</p><p>（ 3 ）媒资文件处理执行器会定时从数据库中读取待处理的任务，然后进行文件格式转换处理，处理成功后就上传到minio服务器</p><h1 id="门户网站的部署"><a href="#门户网站的部署" class="headerlink" title="门户网站的部署"></a>门户网站的部署</h1><p>下图是门户网站的部署及请求流程图</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230403170215115.png" alt="用户请求流程图"></p><h1 id="分布式事务篇"><a href="#分布式事务篇" class="headerlink" title="分布式事务篇"></a>分布式事务篇</h1><p><strong>问题引入：</strong>某个业务操作需要向数据库、redis、elasticsearch、MinIO写四份数据，这里存在分布式事务问题。</p><h2 id="本地事务"><a href="#本地事务" class="headerlink" title="本地事务"></a>本地事务</h2><p>​通过spring的aop特性实现的注解事务是属于<strong>本地事务</strong>，本地事务只控制本地数据库的业务操作，可以保证本地数据库的ACID特性，但涉及到远程调用的业务则不能生效，无法保证业务的原子性。看图解</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230406205255090.png" alt="本地事务"></p><h2 id="什么是分布式事务？"><a href="#什么是分布式事务？" class="headerlink" title="什么是分布式事务？"></a>什么是分布式事务？</h2><p>​现在的需求业务操作后将数据写入数据库、redis、elasticsearch、MinIO四个地方，这四个地方已经不限制在一个数据库内，是由四个分散的服务去提供，与这四个服务去通信需要网络通信，而网络存在不可到达性，这种分布式系统环境下，通过与不同的服务进行网络通信去完成事务称之为<strong>分布式事务。</strong></p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230406210642400.png" alt="分布式事务"></p><h2 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h2><p>控制分布式事务首先需要理解CAP理论，什么是CAP理论？</p><p>CAP：Consistency、Availability、Partition tolerance三个词语的缩写，分别表示<strong>一致性、可用性、分区容忍性</strong>。</p><p>（ 1 ）一致性：是指用户不管访问哪一个结点拿到的数据都是最新的，比如查询小明的信息，不能出现在数据没有改变的情况下两次查询结果不一样。</p><p>（ 2 ）可用性：是指任何时候查询用户信息都可以查询到结果，但不保证查询到最新的数据。</p><p>（ 3 ）分区容忍性：也叫分区容错性，当系统采用分布式架构时由于网络通信异常导致请求中断、消息丢失，但系统依然对外提供服务。</p><p>CAP理论要强调的是在分布式系统中这三点不可能全部满足，<strong>由于是分布式系统须满足分区容忍性</strong>，因为服务之间难免出现网络异常，不能因为局部网络异常导致整个系统不可用。</p><p><strong>分布式事务满足P，C和A不能同时满足</strong></p><p>（ 1 ）如果要满足C一致性，必须等待小明的信息同步完成系统才可用（否则会出现请求到服务实例2和3查询不到数据，违反了一致性），在信息同步过程中系统是不可用的，所以满足C的同时无法满足A。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230406213023157.png" alt="保证一致性图解说明"></p><p>（ 2 ）如果要满足A可用性，要时刻保证系统可用就不用等待信息同步完成，此时系统的一致性无法满足。</p><p><strong>总结：</strong>在分布式系统中进行分布式事务控制，要么保证CP、要么保证AP，看业务需求是否需要保证一致性还是可用性来进行取舍。</p><h2 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h2><p>BASE：Basically Available(基本可用)、Soft state(软状态) 和 Eventually consistent (最终一致性) 三个短语的缩写。</p><p><strong>（ 1 ）基本可用：</strong>当系统无法满足全部可用时保证核心服务可用即可，比如一个外卖系统，每到中午12点左右系统并发量很高，此时要保证下单流程涉及的服务可用，其它服务暂时不可用。</p><p><strong>（ 2 ）软状态：</strong>是指可以存在中间状态，比如：打印自己的社保统计情况，该操作不会立即出现结果，而是提示你打印中，请在XXX时间后查收。虽然出现了中间状态，但最终状态是正确的。</p><p><strong>（ 3 ）最终一致性：</strong>退款操作后没有及时到账，经过一定的时间后账户到账，舍弃强一致性，满足最终一致性。</p><h2 id="分布式事务常用的技术方案"><a href="#分布式事务常用的技术方案" class="headerlink" title="分布式事务常用的技术方案"></a>分布式事务常用的技术方案</h2><p>实现CP就是要实现强一致性：</p><p>（ 1 ）使用Seata框架基于AT模式实现</p><p>（ 2 ）使用Seata框架基于TCC模式实现</p><p>实现AP则要保证最终数据一致性：</p><p>（ 1 ）使用消息队列通知的方式去实现，通知失败自动重试，达到最大失败次数需要人工处理</p><p>（ 2 ）使用任务调度方式，定时进行轮询</p><h1 id="身份认证与授权"><a href="#身份认证与授权" class="headerlink" title="身份认证与授权"></a>身份认证与授权</h1><p>。。。</p><h1 id="Bug问题解决篇"><a href="#Bug问题解决篇" class="headerlink" title="Bug问题解决篇"></a>Bug问题解决篇</h1><h2 id="mapper-xml特殊符号转义问题"><a href="#mapper-xml特殊符号转义问题" class="headerlink" title="mapper.xml特殊符号转义问题"></a>mapper.xml特殊符号转义问题</h2><p>（ 1 ）问题描述：在spring中的mapper.xml文件中写SQL语句不能出现特殊符号，否则会包错</p><p>（ 2 ）问题解决：使用以下对应的转义符号</p><table><thead><tr><th align="center">字符</th><th align="center">转义字符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">&gt;</td><td align="center">&gt;</td><td align="center">大于</td></tr><tr><td align="center">&gt;&#x3D;</td><td align="center">&gt;&#x3D;</td><td align="center">大于等于</td></tr><tr><td align="center">&lt;</td><td align="center">&lt;</td><td align="center">小于</td></tr><tr><td align="center">&lt;&#x3D;</td><td align="center">&lt;&#x3D;</td><td align="center">小于等于</td></tr><tr><td align="center">“</td><td align="center">&quot;</td><td align="center">双引号</td></tr><tr><td align="center">’</td><td align="center">&amp;apos;</td><td align="center">单引号</td></tr><tr><td align="center">&amp;</td><td align="center">&amp;</td><td align="center">and</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;项目引入&quot;&gt;&lt;a href=&quot;#项目引入&quot; class=&quot;headerlink&quot; title=&quot;项目引入&quot;&gt;&lt;/a&gt;项目引入&lt;/h1&gt;&lt;h2 id=&quot;项目背景&quot;&gt;&lt;a href=&quot;#项目背景&quot; class=&quot;headerlink&quot; title=&quot;项目背景&quot;&gt;&lt;/a</summary>
      
    
    
    
    
    <category term="spring-cloud微服务项目" scheme="http://example.com/tags/spring-cloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
</feed>
