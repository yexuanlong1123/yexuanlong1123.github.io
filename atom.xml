<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Welcome To New World</title>
  
  <subtitle>故不积跬步，无以至千里；不积小流，无以成江海。</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-02-17T09:40:30.571Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>孤江自流</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>redis基础与进阶</title>
    <link href="http://example.com/2023/02/17/redis%E5%9F%BA%E7%A1%80%E4%B8%8E%E8%BF%9B%E9%98%B6/"/>
    <id>http://example.com/2023/02/17/redis%E5%9F%BA%E7%A1%80%E4%B8%8E%E8%BF%9B%E9%98%B6/</id>
    <published>2023-02-17T02:16:00.000Z</published>
    <updated>2023-02-17T09:40:30.571Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis基础篇"><a href="#Redis基础篇" class="headerlink" title="Redis基础篇"></a>Redis基础篇</h1><h2 id="Nosql和SQL的介绍"><a href="#Nosql和SQL的介绍" class="headerlink" title="Nosql和SQL的介绍"></a>Nosql和SQL的介绍</h2><p>概述：数据库存储类型有分为SQL（关系型）和NOSQL（非关系型）型数据库</p><p><strong>SQL型的数据库存储特点：</strong></p><p>（1）结构化：表结构存储</p><p>（2）表之间是有关联的</p><p>（3）可以使用SQL语句进行操作</p><p>（4）满足ACID特性：原子性、永久性、一致性、隔离性</p><p>（5）存储方式：磁盘</p><p><strong>NOSQL型数据库存储特点：</strong></p><p>（1）非结构型：像redis数据库是以key-value结构进行存储的</p><p>（2）无关联的</p><p>（3）非SQL</p><p>（4）存储方式：内存（性能比较好）</p><p><strong>使用场景：</strong></p><p>（1）SQL型：对数据安全性和一致性要求较高，数据结构固定</p><p>（2）NOSQL型：数据结构不固定，对性能要求较高，对一致性和安全性要求不高</p><h2 id="Redis的基本介绍"><a href="#Redis的基本介绍" class="headerlink" title="Redis的基本介绍"></a>Redis的基本介绍</h2><p>概述：Redis诞生于2009年全称是Remote Dictionary Server，远程词典服务器，是一个基于内存的键值型NoSQL数据库。</p><p><strong>Redis的特征：</strong></p><p>（1）键值性（key-value）：value支持多种数据结构，功能丰富</p><p>（2）单线程，每个命令具备原子性</p><p>（3）低延迟，速度快（基于内存、IO多路复用、良好的编码）</p><p>（4）支持数据持久化</p><p>（5）支持主从集群、分片集群支持多语言客户端</p><h2 id="Redis的在Linux上安装"><a href="#Redis的在Linux上安装" class="headerlink" title="Redis的在Linux上安装"></a>Redis的在Linux上安装</h2><p>（1）因为Redis是基于c语言编写的，所以首先需要安装gcc依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y gcc tcl</span><br></pre></td></tr></table></figure><p>（2）可以到Redis官网下载linux的安装压缩包，【<a href="https://redis.io/download/#redis-downloads%E3%80%91">https://redis.io/download/#redis-downloads】</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解压命令</span></span><br><span class="line">tar -zxvf redis压缩包文件名称</span><br></pre></td></tr></table></figure><p>（3）进入redis的目录下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd redisxxx</span><br></pre></td></tr></table></figure><p>（4）执行编译命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make $$ make install </span><br></pre></td></tr></table></figure><p>（5）若没有出错，则说明安装成功</p><p>（6）redis-cli的默认安装路径在 &#x2F;usr&#x2F;local&#x2F;bin 目录下</p><h3 id="Redis指定配置文件打开"><a href="#Redis指定配置文件打开" class="headerlink" title="Redis指定配置文件打开"></a>Redis指定配置文件打开</h3><p>如果要让Redis以(后台方式启动，则必须修改Redis配置文件，就在我们之前解压的redis安装包下，进入redis的目录下，找到redis.conf文件，然后进行修改，但在修改前最好进行备份</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp redis.conf redis.conf.bak</span><br></pre></td></tr></table></figure><p>使用以下命令进入redis.conf文件进行编辑</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi redis.conf</span><br></pre></td></tr></table></figure><p><strong>修改配置文件（必要）</strong></p><p>（1）监听的地址，默认是127.0.0.l，会导致只能在本地访问。修改为0.0.0.0则可以在任意IP访问，生产环境下不要设置为0.0.0.0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bind 0.0.0.0</span><br></pre></td></tr></table></figure><p>（2）守护进程，让redis服务器后台运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes</span><br></pre></td></tr></table></figure><p>（3）设置密码，每次进入redis客户端时需要密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requirepass xxxxx</span><br></pre></td></tr></table></figure><p><strong>其它配置（非必要）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#监听的端口</span><br><span class="line">port 6379</span><br><span class="line"></span><br><span class="line">#工作目录，默认是当前目录，也就是运行redis-server时的命令，日志、持久化等文件会保存在这个目录</span><br><span class="line">dir</span><br><span class="line"></span><br><span class="line">#数据库数量，设置为l，代表只使用1个库，默认有16个库，编号0~15</span><br><span class="line">databases 1</span><br><span class="line"></span><br><span class="line">#设置redis能够使用的最大内存</span><br><span class="line">maxmemory 512mb</span><br><span class="line"></span><br><span class="line">#日志文件，默认为空，录日志，可以指定日志文件名</span><br><span class="line">logfile &quot;redis.log&quot;</span><br></pre></td></tr></table></figure><h3 id="运行Redis服务器和客户端"><a href="#运行Redis服务器和客户端" class="headerlink" title="运行Redis服务器和客户端"></a>运行Redis服务器和客户端</h3><p>必要修改的配置文件完成后就进入到&#x2F;redis&#x2F;src目录下，执行以下命令运行redis服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server redis.conf</span><br></pre></td></tr></table></figure><p>执行以下命令执行客户端</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 虚拟机ip -p 端口号 -a 密码</span><br></pre></td></tr></table></figure><h2 id="Redis的数据结构"><a href="#Redis的数据结构" class="headerlink" title="Redis的数据结构"></a>Redis的数据结构</h2><table><thead><tr><th align="center">数据类型</th><th align="center">表现形式</th></tr></thead><tbody><tr><td align="center"><strong>String</strong></td><td align="center"><strong>hello world</strong></td></tr><tr><td align="center"><strong>Hash</strong></td><td align="center"><strong>{name: “jack”,age : 21}</strong></td></tr><tr><td align="center"><strong>List</strong></td><td align="center"><strong>[A —&gt; B —&gt; C]</strong></td></tr><tr><td align="center"><strong>Set</strong></td><td align="center"><strong>{A, B, C}</strong></td></tr><tr><td align="center"><strong>SortedSet</strong></td><td align="center"><strong>{A: 1, B: 2, C: 3}</strong></td></tr><tr><td align="center"><strong>GEO</strong></td><td align="center"><strong>{A: (30.5, 60.6)}</strong></td></tr><tr><td align="center"><strong>BitMap</strong></td><td align="center"><strong>01010010101</strong></td></tr><tr><td align="center"><strong>HyperLog</strong></td><td align="center"><strong>01010010101</strong></td></tr></tbody></table><h2 id="Redis通用命令"><a href="#Redis通用命令" class="headerlink" title="Redis通用命令"></a>Redis通用命令</h2><p>（1）查询符合模板的key命令，生产模式下不建议使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keys pattern</span><br></pre></td></tr></table></figure><p>（2）删除key的命令，可以删除多个</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del key ...</span><br></pre></td></tr></table></figure><p>（3）判断key是否存在</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exists key ...</span><br></pre></td></tr></table></figure><p>（4）设置key的有效期</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expire key second</span><br></pre></td></tr></table></figure><p>（5）TTL：查看一个key的有效期</p><h2 id="String类型的相关命令"><a href="#String类型的相关命令" class="headerlink" title="String类型的相关命令"></a>String类型的相关命令</h2><p>String类型，也就是字符串类型，是Redis中最简单的存储类型。其value是字符串，不过根据字符串的格式不同，又可以分为3类</p><ul><li><p>string：普通字符串</p></li><li><p>int：整数类型，可以做自增、自减操作</p></li><li><p>float：浮点类型，可以做自增、自减操作</p></li></ul><p>不管是哪种格式，底层都是字节数组形式存储，只不过是编码方式不同。字符串类型的最大空间不能超过512m。</p><table><thead><tr><th align="center">命令</th><th align="center">作用</th><th align="center">使用形式</th></tr></thead><tbody><tr><td align="center">set</td><td align="center">添加或者修改一个String类型的键值对</td><td align="center">set key value</td></tr><tr><td align="center">get</td><td align="center">获取已存在key对应的value</td><td align="center">get key</td></tr><tr><td align="center">mset</td><td align="center">批量添加或修改String类型的键值对</td><td align="center">mset k1 v1 k2 v2 …</td></tr><tr><td align="center">mget</td><td align="center">批量获取多个key对应的value</td><td align="center">mget k1 k2 k3 …</td></tr><tr><td align="center">incr</td><td align="center">让一个整型的key自增1</td><td align="center">incr key</td></tr><tr><td align="center">incrby</td><td align="center">让一个整型的key自增并指定步长</td><td align="center">incrby key 步长</td></tr><tr><td align="center">incrbyfloat</td><td align="center">让一个浮点类型的数字自增并指定步长</td><td align="center">incrbyfloat key 步长</td></tr><tr><td align="center">setnx</td><td align="center">添加一个String类型的键值对，前提是这个key不存在，否则不执行</td><td align="center">setnx key value</td></tr><tr><td align="center">setex</td><td align="center">添加一个String类型的键值对，并且指定有效期</td><td align="center">setex key value</td></tr></tbody></table><h3 id="Key的层级结构"><a href="#Key的层级结构" class="headerlink" title="Key的层级结构"></a>Key的层级结构</h3><p>（1）Redis的key允许有多个单词形成层级结构，多个单词之间用∵’隔开，格式【项目名:业务名:id】，可以根据实际需要进行改变</p><p>（2）如果Value是一个ava对象，例如一个User对象，则可以将对象序列化为JSON字符串后存储</p><table><thead><tr><th align="center">key</th><th align="center">value</th></tr></thead><tbody><tr><td align="center">xxx:user:1</td><td align="center">{name: “jack”, age: 5}</td></tr><tr><td align="center">xxx:user:2</td><td align="center">{name: “mike”, age: 10}</td></tr></tbody></table><h2 id="Hash结构相关的命令"><a href="#Hash结构相关的命令" class="headerlink" title="Hash结构相关的命令"></a>Hash结构相关的命令</h2><p>概述：Hash类型，也叫散列，其value是一个无序字典，类似于Java中的HashMap结构</p><p>hash数据类型可以对对象中的每个字段进行CRUD操作，hash类型的形象图如下</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230217153701353.png" alt="image-20230217153701353"></p><p><strong>Hash结构相关命令表如下</strong></p><table><thead><tr><th align="center">命令</th><th align="center">作用</th><th align="center">使用形式</th></tr></thead><tbody><tr><td align="center">hset</td><td align="center">添加或者修改hash类型key的field的值</td><td align="center">hset key field value</td></tr><tr><td align="center">hget</td><td align="center">获取一个hash类型key的field的值</td><td align="center">hget key filed</td></tr><tr><td align="center">hmset</td><td align="center">批量添加多个hash类型key的field的值</td><td align="center">hmset key f1 v1  f2 v2 …</td></tr><tr><td align="center">hmget</td><td align="center">批量获取多个hash类型key的field的值</td><td align="center">hmget key f1  f2  …</td></tr><tr><td align="center">hgetall</td><td align="center">获取一个hash类型的key中的所有的field和value</td><td align="center">hgetall key</td></tr><tr><td align="center">hkeys</td><td align="center">获取一个hash类型的key中的所有的field</td><td align="center">hkeys key</td></tr><tr><td align="center">hvals</td><td align="center">获取一个hash类型的key中的所有的value</td><td align="center">hvals key</td></tr><tr><td align="center">hincrby</td><td align="center">让一个hash类型key的字段值自增并指定步长</td><td align="center">hincrby key filed 步长</td></tr><tr><td align="center">hsetnx</td><td align="center">添加一个hash类型的key的field值，前提是这个field不存在，否则不执行</td><td align="center">hsetnx key filed</td></tr></tbody></table><h2 id="List类型相关的命令"><a href="#List类型相关的命令" class="headerlink" title="List类型相关的命令"></a>List类型相关的命令</h2><p>Redis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。</p><p><strong>特征也与LinkedList类似：有序、元素可以重复插入和删除快查询速度一般。</strong></p><table><thead><tr><th align="center">命令</th><th align="center">作用</th><th align="center">使用形式</th></tr></thead><tbody><tr><td align="center">lpush</td><td align="center">向左列表插入一个或多个元素</td><td align="center">lpush key element …</td></tr><tr><td align="center">lpop</td><td align="center">移除并返回列表左侧的第一个元素，没有则返回nil</td><td align="center">lpop key</td></tr><tr><td align="center">rpush</td><td align="center">向右列表插入一个或多个元素</td><td align="center">rpush key element …</td></tr><tr><td align="center">rpop</td><td align="center">移除并返回列表右侧的第一个元素，没有则返回nil</td><td align="center">rpop key</td></tr><tr><td align="center">lrange</td><td align="center">返回一段角标范围内的所有元素</td><td align="center">lrange key start end</td></tr><tr><td align="center">blpop</td><td align="center">在没有元素时等待指定时间，而不是直接返回nil</td><td align="center">blpop key</td></tr><tr><td align="center">brpop</td><td align="center">在没有元素时等待指定时间，而不是直接返回nil</td><td align="center">brpop key</td></tr></tbody></table><h2 id="Set类型的相关的命令"><a href="#Set类型的相关的命令" class="headerlink" title="Set类型的相关的命令"></a>Set类型的相关的命令</h2><p>Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征：</p><ul><li>无序</li><li>元素不可重复</li><li>查询块</li><li>支持交集、并集和差集操作</li></ul><p>常见的命令如下</p><table><thead><tr><th align="center">命令</th><th align="center">作用</th><th align="center">使用形式</th></tr></thead><tbody><tr><td align="center">sadd</td><td align="center">往set集合中添加一个或多个成员</td><td align="center">sadd key member …</td></tr><tr><td align="center">srem</td><td align="center">在set集合中删除指定成员</td><td align="center">srem key member …</td></tr><tr><td align="center">scard</td><td align="center">返回set集合中的成员个数</td><td align="center">scard key</td></tr><tr><td align="center">sismember</td><td align="center">判断某个成员是否在集合中</td><td align="center">sismember key member</td></tr><tr><td align="center">smembers</td><td align="center">获取set集合中的所有成员</td><td align="center">smembers key</td></tr><tr><td align="center">sinter</td><td align="center">求key1和key2的交集</td><td align="center">sinter key1 key2</td></tr><tr><td align="center">sdiff</td><td align="center">求key1和key2的差集</td><td align="center">sdiff key1 key2</td></tr><tr><td align="center">sunion</td><td align="center">求key1和key2的并集</td><td align="center">sunion key1 key2</td></tr></tbody></table><p><strong>下图是有关于交集、并集和差集的关系图（注意，并集是下图A和B的所有部分）</strong></p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230217164812431.png" alt="image-20230217164812431"></p><h2 id="SortSet类型相关的命令"><a href="#SortSet类型相关的命令" class="headerlink" title="SortSet类型相关的命令"></a>SortSet类型相关的命令</h2><p>Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加hash表。SortedSet具备下列特性：</p><ul><li>可排序</li><li>元素不重复</li><li>查询速度快</li></ul><p>因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能。</p><table><thead><tr><th align="center">命令</th><th align="center">作用</th><th align="center">使用形式</th></tr></thead><tbody><tr><td align="center">zadd</td><td align="center">添加一个或多个元素到sortedset，如果已经存在则更新其score值</td><td align="center">zadd key score member …</td></tr><tr><td align="center">zrem</td><td align="center">删除指定的元素</td><td align="center">zrem key member …</td></tr><tr><td align="center">zscore</td><td align="center">获取sorted set中的指定元素的score值</td><td align="center">zscore key member</td></tr><tr><td align="center">zrank</td><td align="center">获取sorted set 中的指定元素的排名</td><td align="center">zrank key member</td></tr><tr><td align="center">zcard</td><td align="center">获取sorted set中的元素个数</td><td align="center">zcard key</td></tr><tr><td align="center">zcount</td><td align="center">统计score值在给定范围内的所有元素的个数</td><td align="center">zcount key mim max</td></tr><tr><td align="center">zincreby</td><td align="center">让sorted set中的指定元素自增，步长为指定的increment值</td><td align="center">zincreby key increment member</td></tr><tr><td align="center">zrange</td><td align="center">按照score排序后，获取指定排名范围内的元素</td><td align="center">zrange key mim max</td></tr><tr><td align="center">zrangebyscore</td><td align="center">按照score排序后，获取指定排名范围内的元素（按照分数排名）</td><td align="center">zrangebyscore key mim max</td></tr></tbody></table><p style="color: red">注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可</p><h1 id="Redis的Java客户端"><a href="#Redis的Java客户端" class="headerlink" title="Redis的Java客户端"></a>Redis的Java客户端</h1><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230217172404149.png" alt="image-20230217172404149"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Redis基础篇&quot;&gt;&lt;a href=&quot;#Redis基础篇&quot; class=&quot;headerlink&quot; title=&quot;Redis基础篇&quot;&gt;&lt;/a&gt;Redis基础篇&lt;/h1&gt;&lt;h2 id=&quot;Nosql和SQL的介绍&quot;&gt;&lt;a href=&quot;#Nosql和SQL的介绍&quot; cla</summary>
      
    
    
    
    
    <category term="redis;nosql" scheme="http://example.com/tags/redis-nosql/"/>
    
  </entry>
  
  <entry>
    <title>nginx基础详解</title>
    <link href="http://example.com/2023/02/15/nginx%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2023/02/15/nginx%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/</id>
    <published>2023-02-15T02:34:00.000Z</published>
    <updated>2023-02-16T02:54:12.091Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Nginx的基本介绍"><a href="#Nginx的基本介绍" class="headerlink" title="Nginx的基本介绍"></a>Nginx的基本介绍</h1><p><strong>概述：</strong>Nginx是一个高性能的HTTP反向代理服务器，特点是占用内存小，并发能力强</p><p><strong>Nginx作为Web服务器：</strong>Nginx可以作为静态页面的web服务器，同时还支持CGI协议的动态语言，比如perl，php等。但是不支持java。Java程序只能通过与tomcat配合完成。Nginx,专为性能优化而开发，性能是其最重要的考量,实现上非常注重效率，能经受高负载的考验，有报告表明能支持高达50,000个并发连接数。</p><h1 id="Nging的基本特性"><a href="#Nging的基本特性" class="headerlink" title="Nging的基本特性"></a>Nging的基本特性</h1><ul><li>反向代理</li><li>负载均衡</li><li>动静分离</li></ul><p><strong>正向代理概念：客户端（浏览器）通过配置代理服务器访问到目标资源</strong></p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230215132101431.png" alt="image-20230215132101431"></p><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>概述：反向代理，其实客户端对代理是无感知的，因为客户端不需要任何配置就可以访问，我们只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，在返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器P地址。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230215133524255.png" alt="image-20230215133524255"></p><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>若是在小项目中并发量并不是很大，一般都会采用下图所示最基本的架构，好处是开发成本低，易于维护。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230215135802654.png" alt="image-20230215135802654"></p><p>但如今的大数据时代，一般的软件都有一定的用户量，现大部分的软件都会优先采用负载均衡进行用户请求的各个目标服务器上，增加目标服务器的数量，这时需要将用户请求平均分发，如下图所示</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230215140744602.png" alt="image-20230215140744602"></p><h2 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h2><p>在大部分的传统小项目中都是采用动态资源和静态资源不分离开发，虽然这样可以降低开发难度，但对开发人员的技术要求高，开发效率也会受到影响。</p><p>（1）动态资源就是放到数据库的数据，具有实时性，动态更新数据等特点，像jsp，servlet等。</p><p>（2）静态资源就是HTML，CSS，JS等文件</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230215141724380.png" alt="image-20230215141724380"></p><p>那什么是动静分离？动静分离就是让动态资源和静态资源分离开来，将静态资源放到代理服务器中，代理服务器中有专门用于存放静态资源的文件，当用户请求代理服务会先将页面渲染到客户端，然后根据客户需求将请求发送给目标服务器。如下图</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230215152851632.png" alt="image-20230215152851632"></p><h1 id="Nginx的常用命令"><a href="#Nginx的常用命令" class="headerlink" title="Nginx的常用命令"></a>Nginx的常用命令</h1><p><em><strong>使用nginx的（linux）命令的前提是进入root&#x2F;usr&#x2F;nginx&#x2F;sbin目录下才会生效</strong></em></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看nginx的版本号</span></span><br><span class="line">nginx -v</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动nginx的命令</span></span><br><span class="line">./nginx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭nginx的命令</span></span><br><span class="line">nginx -s stop</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重新加载nginx服务器</span></span><br><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure><h1 id="Nginx的配置文件"><a href="#Nginx的配置文件" class="headerlink" title="Nginx的配置文件"></a>Nginx的配置文件</h1><p>nginx的配置文件在xxx&#x2F;nginx&#x2F;conf目录下的nginx.conf文件，我们需要对该文件进行一些配置需要知道该配置是由什么组成的？组成部分如下</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230215150412247.png" alt="image-20230215150412247"></p><p>（1）<strong>全局块：</strong>主要会设置一些影响nginx服务器整体运行的配置指令。</p><p>比如 worker_processes 1，worker_processes值越大，可以支持的并发处理量也越多</p><p>（2）<strong>events块：</strong>events涉及的指令主要是影响用户和Nginx服务器的网络连接数量</p><p>比如worker_connections  1024，表示用连接数最大为1024</p><p>（3）<strong>http块：</strong>这算是Nginx服务器配置中最频繁的部分，代理、缓存和日志定义等绝大多数功能和第三方模块的配置都在这里</p><p>如下图是http块的组成部分</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230215151525508.png" alt="image-20230215151525508"></p><h1 id="Nginx的应用"><a href="#Nginx的应用" class="headerlink" title="Nginx的应用"></a>Nginx的应用</h1><p>在这部分会实现反向代理、负载均衡、动静分离。</p><h2 id="反向代理的实现"><a href="#反向代理的实现" class="headerlink" title="反向代理的实现"></a>反向代理的实现</h2><p>需求：通过nginx代理服务器将<u><a href="http://www.123.com/">www.123.com</a></u>网站发送的请求转发到192.168.177.130:8080的服务器上，nginx的服务端口是192.168.166.120:80</p><p><strong>反向代理过程如下图</strong></p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230215153036342.png" alt="image-20230215153036342"></p><p>对nginx&#x2F;conf目录下的nginx.conf文件的配置参数如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"># 配置最大并发量</span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line"># 配置最大连接数</span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line"># 请求类型和响应类型</span><br><span class="line">    default_type  application/json;</span><br><span class="line"># 连接超时时间</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line"># 监听的ip端口192.168.166.120:80</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  192.168.166.120;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">         root   html/htm_pro;</span><br><span class="line"># 将发送的请求代理到192.168.177.130:8080</span><br><span class="line">proxy_pass 192.168.177.130:8080;</span><br><span class="line">         index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>进阶需求：</strong>根据用户访问不同的路径代理到不同的目标服务器上，现用户访问了两次不同的路径如下</p><p>（1）192.168.166.120:80&#x2F;edu&#x2F;index.html 代理到 192.168.130:8081服务器上。</p><p>（2）192.168.166.120:80&#x2F;gig&#x2F;index.html  代理到 192.168.130:8086服务器上。</p><p><strong>过程图如下</strong></p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230215155246819.png" alt="image-20230215155246819"></p><p>对nginx&#x2F;conf目录下的nginx.conf文件的配置参数如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"># 配置最大并发量</span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line"># 配置最大连接数</span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line"># 请求类型和响应类型</span><br><span class="line">    default_type  application/json;</span><br><span class="line"># 连接超时时间</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line"># 监听的ip端口192.168.166.120:80</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  192.168.166.120;</span><br><span class="line"># 访问根页面</span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html/htm_pro;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"># 若访问路径包含edu，则代理到192.168.130:8081</span><br><span class="line">location ~ /edu/ &#123;</span><br><span class="line">proxy_pass 192.168.130:8081;</span><br><span class="line">        &#125;</span><br><span class="line">        # 若访问路径包含gig，则代理到192.168.130:8086</span><br><span class="line">location ~ /gig/ &#123;</span><br><span class="line">proxy_pass 192.168.130:8086;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="负载均衡的实现"><a href="#负载均衡的实现" class="headerlink" title="负载均衡的实现"></a>负载均衡的实现</h2><p><strong>需求：</strong>现有两台服务器A和B，现在需要将用户的请求平均分配给A和B服务器，那么以下是配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"># 配置最大并发量</span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line"># 配置最大连接数</span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">   include mime.types;</span><br><span class="line"># 请求类型和响应类型</span><br><span class="line">   default_type  application/json;</span><br><span class="line"># 连接超时时间</span><br><span class="line">   keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line"># A和B的服务器列表</span><br><span class="line">upstream myserver&#123;</span><br><span class="line">    server 192.168.166.1:9091 # A的ip</span><br><span class="line">    server 192.168.166.1:9092 # B的ip</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line"> #监听的ip端口192.168.166.120:80</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  192.168.166.120;</span><br><span class="line"> #访问根页面</span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html/htm_pro;</span><br><span class="line">   proxy_pass http://myserver;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>四种负载均衡策略</strong></p><p>（1）轮询：每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。【默认】</p><p>（2）权重：weight代表权，重默认为1，权重越高的服务器被分配的客户端请求就越多。适用于各个服务器性能不均衡的情况下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream myserver&#123;</span><br><span class="line">server 192.168.166.1:9091 weight=10;</span><br><span class="line">server 192.168.166.1:9092 weight=20;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）ip_hash：每个请求按访间ip.的 hash结果分配,这样每个访额固定访问一个后端服务器,可以解决session的问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream myserver&#123;</span><br><span class="line">ip_hash;</span><br><span class="line">server 192.168.166.1:9091;</span><br><span class="line">server 192.168.166.1:9092;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）fair(第三方)：按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream myserver&#123;</span><br><span class="line">fair;</span><br><span class="line">server 192.168.166.1:9091;</span><br><span class="line">server 192.168.166.1:9092;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动静分离的实现"><a href="#动静分离的实现" class="headerlink" title="动静分离的实现"></a>动静分离的实现</h2><p>将静态资源（HTML、JS、CSS）文件放到…&#x2F;nginx&#x2F;html目录下即可，然后再配置nginx.conf文件，配置如下</p><pre><code>location / &#123;   # 配置静态资源的所在目录htm_pro   root   /htm_pro;   ndex  index.html index.htm;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Nginx的基本介绍&quot;&gt;&lt;a href=&quot;#Nginx的基本介绍&quot; class=&quot;headerlink&quot; title=&quot;Nginx的基本介绍&quot;&gt;&lt;/a&gt;Nginx的基本介绍&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;概述：&lt;/strong&gt;Nginx是一个高性能的HTTP反向</summary>
      
    
    
    
    
    <category term="nginx" scheme="http://example.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>23种设计模式详解笔记</title>
    <link href="http://example.com/2023/02/04/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2023/02/04/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-02-04T08:59:00.000Z</published>
    <updated>2023-02-16T02:51:49.937Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h1><p>在软件开发中，为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性，程序员要尽量根据6条原则来开发程序，从而提高软件开发效率、节约软件开发成本和维护成本。</p><h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><p><em><strong>对修改关闭，对扩展开放</strong></em>，在程序需要进行扩展的时候，不能修改原有的代码，程序设计之初就需要考虑如何扩展功能而不修改源码，实现一个动态扩展功能的效果，简而言之就是提高程序的可扩展性、易于维护和升级。</p><p>​下图是对开闭原则的一个实践测试，在现实生活中人们一部手机就可以走天下，这个很大程度得益于手机支付功能，手机支付有很多的渠道，有微信支付、支付宝支付、银行卡支付等等不同的支付方式，那你需要开发一个可以扩展这些支付的程序那应该如何设计呢？首先需要对支付这个行为抽象定义为抽象类，然后把具体的支付行为交给派生类去实现，这样就可以实现扩展支付的方式了。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230204180422604.png" alt="手机支付扩展图"></p><p>代码设计（demo）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  抽象支付类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractPayment</span> &#123;</span><br><span class="line">    <span class="comment">// 支付方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">payment</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  微信支付</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeixinPayment</span> <span class="keyword">extends</span> <span class="title class_">AbstractPayment</span>&#123;</span><br><span class="line">    <span class="comment">// 具体实现交由子类实现</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">payment</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;微信支付。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  支付宝支付</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZhifubaiPayment</span> <span class="keyword">extends</span> <span class="title class_">AbstractPayment</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">payment</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;支付宝支付。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  支付完成</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PaymentComplete</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> AbstractPayment pay;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPay</span><span class="params">(AbstractPayment pay)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.pay = pay;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        pay.payment();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="里氏代换原则"><a href="#里氏代换原则" class="headerlink" title="里氏代换原则"></a>里氏代换原则</h2><p>里氏代换原则：任何基类可以出现的地方，子类一定可以出现。通俗理解∶子类可以扩展父类的功能，但不能改变父类原有的功能。换句话说，子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。</p><p>如果通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大。</p><p><strong>【例】长方体不是正方体</strong></p><p>​在数学领域里，正方形毫无疑问是长方形，它是一个长宽相等的长方形。所以，我们开发的一个与几何图形相关的软件系统，就可以顺理成章的让正方形继承自长方形。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230206142930889.png" alt="image-20230206142930889"></p><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  长方形类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="comment">// 宽度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> width;</span><br><span class="line">    <span class="comment">// 长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> length;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getWidth</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> width;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWidth</span><span class="params">(<span class="type">double</span> width)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getLength</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLength</span><span class="params">(<span class="type">double</span> length)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.length = length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  正方形：长和宽相同</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">extends</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLength</span><span class="params">(<span class="type">double</span> length)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.setLength(length);</span><br><span class="line">        <span class="built_in">super</span>.setWidth(length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWidth</span><span class="params">(<span class="type">double</span> width)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.setWidth(width);</span><br><span class="line">        <span class="built_in">super</span>.setLength(width);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RectangleDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建长方形对象</span></span><br><span class="line">        <span class="type">Rectangle</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line">        <span class="comment">// 设置长和宽</span></span><br><span class="line">        r.setLength(<span class="number">20.0</span>);</span><br><span class="line">        r.setWidth(<span class="number">10.0</span>);</span><br><span class="line">        <span class="comment">// 进行扩宽</span></span><br><span class="line">        resize(r);</span><br><span class="line">        <span class="comment">// 打印信息</span></span><br><span class="line">        printWidthAndLength(r);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;=======正方形扩宽=======&quot;</span>);</span><br><span class="line">        <span class="type">Square</span> <span class="variable">square</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Square</span>();</span><br><span class="line"></span><br><span class="line">        square.setWidth(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        resize(square);</span><br><span class="line">        printWidthAndLength(square);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 扩大宽度的方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">(Rectangle rectangle)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (rectangle.getWidth() &lt;= rectangle.getLength()) &#123;</span><br><span class="line">            rectangle.setWidth(rectangle.getWidth() + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printWidthAndLength</span><span class="params">(Rectangle r)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;长度：&quot;</span> + r.getLength());</span><br><span class="line">        System.out.println(<span class="string">&quot;宽度：&quot;</span> + r.getWidth());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230206143910071.png" alt="image-20230206143910071"></p><p>​在运行结果中可以看出，在长方形扩宽操作中是符合我们的预期的，因为长方形不要求长和宽相等，故长方形的宽扩大时它的长是不会跟着改变的，而在正方形扩宽中是一个死循环，因为长方形的宽扩大时长也会跟的扩大，这样就会形成一个死循环，直到报错为止。我们得出结论：在resize方法中，Rectangle类型的参数是不能被Square类型的参数所代替，如果进行了替换就得不到预期结果。因此，Square类和Rectangle类之间的继承关系违反了里氏代换原则，它们之间的继承关系不成立，正方形不是长方形。</p><p>知道了问题的所在，那我们可以在抽象出一个四边形接口，来分别获取长方形和正方形的宽和长。看以下类图</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230206145939216.png" alt="image-20230206145939216"></p><h2 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h2><p>​高层模块不应该依赖底层模块，两者都应依赖于抽象，抽象不应该依赖细节，细节应该依赖于抽象。简单的说是要求对抽象进行编程而不是对细节实现进行编程。这样就降低了客户和实现模块的耦合。</p><p><strong>【例】组装电脑</strong></p><p>​现要组装一台电脑，需要配件cpu，硬盘，内存条。只有这些配置都有了，计算机才能正常的运行。选择cpu有很多选择，如Intel，AMD等，硬盘可以选择希捷，西数等，内存条可以选择金士顿，海盗船等。类图如下</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230206151504078.png" alt="image-20230206151504078"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  电脑</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line">    <span class="comment">// cpu</span></span><br><span class="line">    <span class="keyword">private</span> IntelCpu cpu;</span><br><span class="line">    <span class="comment">// 内存条</span></span><br><span class="line">    <span class="keyword">private</span> KingstonMemory memory;</span><br><span class="line">    <span class="comment">// 硬盘</span></span><br><span class="line">    <span class="keyword">private</span> XijieHardDisk hardDisk;</span><br><span class="line">    <span class="keyword">public</span> IntelCpu <span class="title function_">getCpu</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cpu;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCpu</span><span class="params">(IntelCpu cpu)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cpu = cpu;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> KingstonMemory <span class="title function_">getMemory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> memory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMemory</span><span class="params">(KingstonMemory memory)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.memory = memory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> XijieHardDisk <span class="title function_">getHardDisk</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> hardDisk;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHardDisk</span><span class="params">(XijieHardDisk hardDisk)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.hardDisk = hardDisk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;计算机启动中...&quot;</span>);</span><br><span class="line">        cpu.run();</span><br><span class="line">        memory.save();</span><br><span class="line">        hardDisk.save(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">data</span> <span class="operator">=</span> hardDisk.getData();</span><br><span class="line">        System.out.println(<span class="string">&quot;从硬盘的初始化中读取到数据：&quot;</span> + data);</span><br><span class="line">        System.out.println(<span class="string">&quot;启动完成...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  IntelCpu -- 一种cpu的品牌</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntelCpu</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;IntelCpu正在运行中...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  金士顿内存条 -- 某种品牌</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KingstonMemory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;金士顿内存条正在保存数据...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  希捷硬盘类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XijieHardDisk</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(String data)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;数据在希捷硬盘中保存成功！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;数据从希捷硬盘中获取中...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;data...&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComputerDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建组装计算机的各个部件</span></span><br><span class="line">        <span class="type">IntelCpu</span> <span class="variable">cpu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntelCpu</span>();</span><br><span class="line">        <span class="type">KingstonMemory</span> <span class="variable">memory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">KingstonMemory</span>();</span><br><span class="line">        <span class="type">XijieHardDisk</span> <span class="variable">hardDisk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XijieHardDisk</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 组装部件</span></span><br><span class="line">        computer.setCpu(cpu);</span><br><span class="line">        computer.setMemory(memory);</span><br><span class="line">        computer.setHardDisk(hardDisk);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 运行计算机</span></span><br><span class="line">        computer.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230206152951968.png" alt="image-20230206152951968"></p><p>​在以上的设计模式中存在一个问题，就是用户需要更换其他品牌的硬件时需要对原代码进行修改，这样就违反了开闭原则，那么可以根据依赖倒转原则进行改进，改进的类图如下</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230206160227874.png" alt="image-20230206160227874"></p><p>​这样设计可以解决起初设计的问题，用户若要更换其他品牌的内存或其他的硬件，则直接实现相关的接口重写方法即可，这样就不用对Computer中的代码进行修改了。</p><h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><p>客户端不应该被迫依赖于它不使用的方法；一个类对异个类的依赖应该建立在最小的接口上。概念过于抽象，请看下图可以有助于理解</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230206162548228.png" alt="image-20230206162548228"></p><p><strong>【例】不同类别的智能门</strong></p><p>​XX品牌的A类智能门上需要有人脸识别、密码解锁和指纹识别的功能；B类智能门需要有人脸识别和密码解锁功能；C类智能门需要有密码解锁功能；那应该如何设计才会比较合理呢？若将人脸识别、密码解锁和指纹识别抽象为一个接口，那明显不符合该需求，应该将人脸识别、密码解锁和指纹识别抽象为三个接口，哪类智能门需要哪个功能就实现哪个接口，这样就符合接口隔离原则，详细类图如下（该类图是实现了A类智能门，其余智能门实现思路只需要实现相应的接口即可）</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230206165528415.png" alt="image-20230206165528415"></p><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  密码解锁 功能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PasswordUnlock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">passwordValidate</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指纹识别</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RecognitionDactylogram</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dactylogramValidate</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  人脸识别 功能接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RecognitionSurface</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">surfaceValidate</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  A类智能门</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntelligentDoorA</span> <span class="keyword">implements</span> <span class="title class_">PasswordUnlock</span>,RecognitionSurface,RecognitionDactylogram&#123;</span><br><span class="line">    <span class="comment">// 类别</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">char</span> <span class="variable">type</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(type + <span class="string">&quot;类智能门正在工作。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 密码验证</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">passwordValidate</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;密码认证服务启动成功。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 指纹验证</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dactylogramValidate</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;指纹认证服务启动成功。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 扫脸验证</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">surfaceValidate</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;扫脸识别服务启动成功。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  智能门测试类 -- 接口隔离原则</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntelligentDoorDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建A类智能门对象</span></span><br><span class="line">        <span class="type">IntelligentDoorA</span> <span class="variable">doorA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntelligentDoorA</span>();</span><br><span class="line">        <span class="comment">// 启动服务</span></span><br><span class="line">        doorA.dactylogramValidate();</span><br><span class="line">        doorA.surfaceValidate();</span><br><span class="line">        doorA.passwordValidate();</span><br><span class="line"></span><br><span class="line">        doorA.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230206170929837.png" alt="image-20230206170929837"></p><h2 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h2><p>迪米特法则又叫最少知识原则。</p><p>只和你的直接朋友交谈，不跟”陌生人”说话“(Talk only to your immediate friends and not to strangers)。</p><p>其含义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。</p><p>迪米特法则中的”朋友”是指:当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。概念有些抽象，请看下图理解</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230206194111351.png" alt="image-20230206194111351"></p><p>【例】明星和经纪人的关系</p><p>​明星由于全身心投入工作中，所以许多日常事务由经纪人负责处理，如和粉丝的见面会，和媒体公司的业务洽淡等。这里的经纪人是明星的朋友，而粉丝和媒体公司是陌生人，所以适合使用迪米特法则。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230206192156492.png" alt="image-20230206192156492"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  公司类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Company</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  粉丝类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fans</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  明星类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Star</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  经纪人代理类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Agent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Fans fans;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Company company;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Star star;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFans</span><span class="params">(Fans fans)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.fans = fans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCompany</span><span class="params">(Company company)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.company = company;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStar</span><span class="params">(Star star)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.star = star;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 安排粉丝见面</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">meeting</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(fans.getName() + <span class="string">&quot;和&quot;</span> + star.getName() + <span class="string">&quot;见面了~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理与其他公司的合作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">business</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(company.getName() + <span class="string">&quot;和&quot;</span> + star.getName() + <span class="string">&quot;又签约了1年的合同~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AgentDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建经纪人对象</span></span><br><span class="line">        <span class="type">Agent</span> <span class="variable">agent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Agent</span>();</span><br><span class="line">        <span class="comment">// 公司</span></span><br><span class="line">        <span class="type">Company</span> <span class="variable">company</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Company</span>();</span><br><span class="line">        company.setName(<span class="string">&quot;XXX娱乐传媒公司&quot;</span>);</span><br><span class="line">        <span class="comment">// 粉丝</span></span><br><span class="line">        <span class="type">Fans</span> <span class="variable">fans</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Fans</span>();</span><br><span class="line">        fans.setName(<span class="string">&quot;小明&quot;</span>);</span><br><span class="line">        <span class="comment">// 明星</span></span><br><span class="line">        <span class="type">Star</span> <span class="variable">star</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Star</span>();</span><br><span class="line">        star.setName(<span class="string">&quot;ikun&quot;</span>);</span><br><span class="line">        <span class="comment">// 粉丝和明星的见面、明星与公司的业务都是通过经纪人的代理的</span></span><br><span class="line">        agent.setCompany(company);</span><br><span class="line">        agent.setFans(fans);</span><br><span class="line">        agent.setStar(star);</span><br><span class="line">        <span class="comment">// 开始见面会和业务合作</span></span><br><span class="line">        agent.business();</span><br><span class="line">        agent.meeting();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h2><p>合成复用原则是指:尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。通常类的复用分为继承复用和合成复用两种。</p><p>继承复用虽然有简单和易实现的优点，但它也存在以下缺点:</p><ol><li>继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为”白箱”复用。</li><li>子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。</li><li>它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。</li></ol><p>采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能。以下是它的优点</p><ol><li>它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为”黑箱”复用。</li><li>对象间的耦合度低。可以在类的成员位置声明抽象。</li><li>复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。</li></ol><p>【例】汽车分类管理程序</p><p>​汽车有很多的标准来进行分类，可以按颜色分为白色、黑色等等，也可以按照“动力源”的不同分为需要加油的汽车和需要充电的汽车，那么通过颜色和动力源进行组合可以组合成：白色汽车、白色电动汽车、黑色汽车、黑色电动汽车等等，以下类图是通过继承的方式去实现该需求。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230206201613763.png" alt="image-20230206201613763"></p><p>​那么按照以上的设计，如果需要新增新能源汽车类别，那应该如何新增呢？那就需要让新能汽车类继承Car类，从而在根据颜色继承新能源汽车类，这样就会至少得增加2个类，若又有很多颜色的汽车，那还要增加类，这样就有点不合理。我们可以通过聚合的方式去设计，避免多级继承，如下是改进后的类图</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230206202625839.png" alt="image-20230206202625839"></p><h1 id="创建者模式"><a href="#创建者模式" class="headerlink" title="创建者模式"></a>创建者模式</h1><p>创建型模式的主要关注点是”怎样创建对象? ”，它的主要特点是”将对象的创建与使用分离”。这样可以降低系统的耦合度，使用者不需要关注对象的创建细节。</p><p>创建者模式可以分为</p><ul><li>单例模式</li><li>工厂 方法模式</li><li>抽象工程模式</li><li>原型模式</li><li>建造者模式</li></ul><h2 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h2><p>单例设计模式是java设计模式中最简单的一种设计模式，这种模式下只涉及到一个类对象被创建，需要保证该类创建的对象只能有一个，提供一个访问该类的唯一对象方法，实例化一次，然后每次访问的对象都是同一个，这就是单例设计模式。</p><p><strong>单例模式的实现</strong></p><p>单例模式分为两种：</p><ul><li>饿汉式：类加载就会导致单例对象被创建</li><li>懒汉式：类加载不会使单例对象被创建，只有在首次用到对象时才会被创建</li></ul><h3 id="饿汉式单例设计模式"><a href="#饿汉式单例设计模式" class="headerlink" title="饿汉式单例设计模式"></a>饿汉式单例设计模式</h3><p>单例模式直接在成员变量中实例化并将其设为静态变量，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  单例类 -- 饿汉式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;单例类初始化。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供访问唯一对象的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>利用静态代码块实现饿汉式单例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  单例类 -- 饿汉式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;单例类初始化。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供访问唯一对象的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="懒汉式单例设计模式"><a href="#懒汉式单例设计模式" class="headerlink" title="懒汉式单例设计模式"></a>懒汉式单例设计模式</h3><p>概述：使用饿汉式单例设计模式，如果在某个单例类所占用的内存很大，可能会发生内存浪费问题，因为饿汉式在类加载阶段就被创建，而该类一直并未被使用，最后就占着茅坑不拉屎。那么可以使用懒汉式加载单例模式，但其有个缺点：懒汉式响应的速度比饿汉式的慢，因为懒汉式只有对象被使用时才进行加载的，而饿汉式对象还未被使用就已经提前加载完了。以下是实现懒汉式的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  懒汉式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;懒汉式单例初始化。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>懒汉式(静态内部类方式)</strong></p><p>​静态内部类单例模式中实例由内部类创建，由于JM在加载外部类的过程中，是不会加载静态内部类的，只有内部类的属性&#x2F;方法被调用时才会被加载，并初始化其静态属性。静态属性由于被static修饰，保证只被实例化一次，并且严格保证实例化顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  懒汉式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;懒汉式单例初始化。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong>第一次加载Singleton类是不会初始化实例的，当只有调用getInstance()方法时JVM虚拟机会加载SingletonHolder并初始化instance实例，这样不仅保证了线程安全，也保证了创建Singleton的唯一性。</p><p><strong>小结：</strong>静态内部类方式创建懒汉式单例模式是比较优秀的创建方式，在很多的开源项目中都会优先采用该方式，在没有加任何锁的情况下解决了线程安全破坏单例，并且性能没有收到影响和造成内存浪费问题。</p><p>注意：这样有几种方式会破坏单例，因为我在java面试篇中有详细说明到，所以在这不多赘述。</p><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>概述：工厂模式就类似我们生活中加工厂，从其它地方提供原料到加工厂中进行装配，待装配完成后就可以将完整的产品出厂。工厂模式分很多种模式，如下</p><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>【例】点咖啡案例</p><p>咖啡在我们生活中随处可见，咖啡有分为美式咖啡、拿铁、玛奇朵等等种类，现在个需求就是根据客户需要生产出不同的咖啡，因为有些咖啡非常的苦，可以根据客户需求进行加糖或者加奶，现有一个咖啡店，这种需求符合工厂模式，类图如下</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230207142341618.png" alt="image-20230207142341618"></p><p>代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  咖啡类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span> <span class="keyword">instanceof</span> AmericanoCoffee) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;美式咖啡&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span> <span class="keyword">instanceof</span>  LatteCoffee)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;拿铁咖啡&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">adSugar</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;加糖步骤完成。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addMilk</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;加奶步骤完成。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  美式咖啡</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AmericanoCoffee</span> <span class="keyword">extends</span> <span class="title class_">Coffee</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  拿铁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LatteCoffee</span> <span class="keyword">extends</span> <span class="title class_">Coffee</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  咖啡店</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CoffeeStore</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">orderCoffee</span><span class="params">(Class&lt;?&gt; type)</span> &#123;</span><br><span class="line">        Coffee coffee;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(AmericanoCoffee.class == type) &#123;</span><br><span class="line">            <span class="comment">// 创建美式咖啡</span></span><br><span class="line">            coffee = <span class="keyword">new</span> <span class="title class_">AmericanoCoffee</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(LatteCoffee.class == type) &#123;</span><br><span class="line">            <span class="comment">// 创建拿铁</span></span><br><span class="line">            coffee = <span class="keyword">new</span> <span class="title class_">LatteCoffee</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;咖啡不存在~~~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 加配料</span></span><br><span class="line">        coffee.addMilk();</span><br><span class="line">        coffee.adSugar();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> coffee.getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CoffeeStore</span> <span class="variable">store</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CoffeeStore</span>();</span><br><span class="line">        <span class="comment">// 客户点咖啡</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">coffeeName</span> <span class="operator">=</span> store.orderCoffee(AmericanoCoffee.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;客户拿到了【&quot;</span> + coffeeName + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong>在引入中的例子存在着Coffee(咖啡)类和CoffeeStore(咖啡店)类的耦合，因为在orderCoffee中每次都需要根据客户需求去new不同的对象，创建(new)对象的操作本身就是高耦合的操作，若咖啡店中需要引入新种类的咖啡，在以上的设计中是需要修改orderCoffee方法中的判断的，这样就违背了【开闭原则】，若使用工厂模式来设计的话，我们只需要跟工厂打交道，若出现新种类的咖啡，那么就交给工厂本身内部处理即可，这样就达到了与对象解耦的目的了，所有工厂模式最大的优点就是【解耦】。工厂模式分以下几种</p><h3 id="2-2-1-简单工厂模式"><a href="#2-2-1-简单工厂模式" class="headerlink" title="2.2.1 简单工厂模式"></a>2.2.1 简单工厂模式</h3><p>简单工厂模式不是一种设计模式，是一种编程习惯</p><p><strong>组成结构如下：</strong></p><ul><li>抽象产品：定义了产品的规范，描述了产品的主要特性和功能</li><li>具体产品：实现或者继承抽象产品的子类</li><li>具体工厂：提供了创建产品的方法，调用者通过该方法来创建产品</li></ul><p>对引入中例子通过简单工厂模式进行改进，咖啡店中的咖啡从专门生产咖啡中获取咖啡原料，咖啡工厂根据咖啡店所需要的咖啡豆生产即可，改进后的类图如下图</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230207150115757.png" alt="image-20230207150115757"></p><p>代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  美式咖啡</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AmericanoCoffee</span> <span class="keyword">extends</span> <span class="title class_">Coffee</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  拿铁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LatteCoffee</span> <span class="keyword">extends</span> <span class="title class_">Coffee</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  咖啡类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span> <span class="keyword">instanceof</span> AmericanoCoffee) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;美式咖啡&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span> <span class="keyword">instanceof</span>  LatteCoffee)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;拿铁咖啡&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">adSugar</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;加糖步骤完成。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addMilk</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;加奶步骤完成。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  咖啡店</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CoffeeStore</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">orderCoffee</span><span class="params">(Class&lt;?&gt; type)</span> &#123;</span><br><span class="line">        <span class="type">SimpleCoffeeFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleCoffeeFactory</span>();</span><br><span class="line">        <span class="comment">// 从工厂中获取咖啡</span></span><br><span class="line">        <span class="type">Coffee</span> <span class="variable">coffee</span> <span class="operator">=</span> factory.produceCoffee(type);</span><br><span class="line">        <span class="comment">// 加配料</span></span><br><span class="line">        coffee.addMilk();</span><br><span class="line">        coffee.adSugar();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> coffee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  简单咖啡工厂 -- 专门生成咖啡</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleCoffeeFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生产咖啡</span></span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">produceCoffee</span><span class="params">(Class&lt;?&gt; type)</span> &#123;</span><br><span class="line">        Coffee coffee;</span><br><span class="line">        <span class="comment">// 获取全部子类</span></span><br><span class="line">        <span class="keyword">if</span>(AmericanoCoffee.class == type) &#123;</span><br><span class="line">            <span class="comment">// 创建美式咖啡</span></span><br><span class="line">            coffee = <span class="keyword">new</span> <span class="title class_">AmericanoCoffee</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(LatteCoffee.class == type) &#123;</span><br><span class="line">            <span class="comment">// 创建拿铁</span></span><br><span class="line">            coffee = <span class="keyword">new</span> <span class="title class_">LatteCoffee</span>();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;咖啡不存在~~~&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> coffee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong>以上的设计中CoffeeStore每次都是从简单咖啡工厂中获取咖啡原料，而不必关心咖啡原料的加工过程，这样实现了CoffeeStore和Coffee的解耦，同时又产生了新的耦合简单咖啡工厂和咖啡的耦合，若又有新的咖啡新品加入的话需要修改SimpleCoffeeFactory类中的处理逻辑，这样也是违反了【开闭原则】，但比起初设计修修改更为简单，只需要修改SimpleCoffeeFactory中的即可省去了其它的操作。</p><h3 id="2-2-2-工厂方法模式"><a href="#2-2-2-工厂方法模式" class="headerlink" title="2.2.2 工厂方法模式"></a>2.2.2 工厂方法模式</h3><p>概念：定义一个用于创建对象的接口，让子类决定实例化哪个产品类对象。工厂方法使一个产品类的实例化延迟到其工厂的子类。</p><p>工厂方法的主要结构如下</p><ul><li>抽象工厂：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品。</li><li>具体工厂：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。</li><li>抽象产品：定义产品的规范，描述产品的特征和功能</li><li>具体产品：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。</li></ul><p>对以上的例子通过工厂方法模式进一步改进，在这次改进中可以遵守【开闭原则】，类图如下</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230208125507300.png" alt="image-20230208125507300"></p><p>代码自行测试</p><p><strong>工厂方法的优点</strong></p><ul><li>用户只需要知道具体工厂的名称就可以获取到产品，无需知道产品的实现细节</li><li>在系统中添加新产品时只需要添加具体工厂类和具体产品类分别继承对应的父类，这样无需修改源码，满足【开闭原则】</li></ul><p><strong>工厂方法的缺点</strong></p><ul><li>每增加一个新产品都需要添加一个具体工厂和具体产品类，这无疑是增加了系统的复杂度，对后期维护非常的不友好</li></ul><h3 id="2-2-3-抽象工厂模式"><a href="#2-2-3-抽象工厂模式" class="headerlink" title="2.2.3 抽象工厂模式"></a>2.2.3 抽象工厂模式</h3><p>前面介绍的工厂方法模式中考虑的是一类产品的生产，如畜牧场只养动物、电视机厂只生产电视机、服装厂只生产服装等。</p><p>​这些工厂只生产同种类产品，同种类产品称为同等级产品，也就是说：工厂方法模式只考虑生产同等级的产品，但是在现实生活中许多工厂是综合型的工厂，能生产多等级（种类)―的产品，如电器厂既生产电视机又生产洗衣机或空调，大学既有软件专业又有生物专业等。本章要介绍的抽象工厂模式将考虑多等级产品的生产，将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族</p><p><strong>抽象工厂模式结构</strong></p><ul><li>抽象工厂(Abstract Factory)：提供了创建产品的接口，它包含多个创建产品的方法，可以创建多个不同等级的产品。</li><li>具体工厂(Concrete Factory)︰主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。</li><li>抽象产品(Product)：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。</li><li>具体产品(Cancrete Product)：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间是多对一的关系。</li></ul><p><strong>【例】服装厂的生产</strong></p><p>XX服装厂中有生产很多种类的服装，有西式、古风等风格的服装，西式风格的服装有：西装、茄克衫等等；古风类型的服装有：盘扣立领连衣裙、国潮长袖针织衫等等，该服装厂还有生产领带、项链等服饰。若采用 工厂方法模式模式设计在如此多的风格下很容易产生类爆炸，按照抽象工厂模式设计，只需要将服装风格分为古风类和西式风格类，领带、胸针划分为西式配饰类；步摇、发带划分为古风配饰中；最后将西式风格类和西式配饰类分发给西式工厂生产，古风配饰和古风分发给古风服装工厂生产。以下类图会描述更清楚</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230208141215630.png" alt="image-20230208141215630"></p><p><strong>抽象工厂模式的优缺点</strong></p><p><strong>优点：</strong>当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。</p><p><strong>缺点：</strong>当新增新产品时所有的工厂类中的代码都需要修改</p><p><strong>使用场景如下</strong></p><ul><li><p>当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等</p></li><li><p>系统中有多个产品族，但每次只使用其中的某一族产品。如有人只喜欢穿某一个品牌的衣服和鞋。</p></li><li><p>系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。</p></li></ul><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p><strong>概述：</strong>用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型对象相同的新对象（类似克隆）。</p><p><strong>结构：</strong></p><ul><li>抽象原型类：规定了具体原型对象必须实现的的 clone ()方法。</li><li>具体原型类：实现抽象原型类的clone ()方法，它是可被复制的对象。</li><li>访问类：使用具体原型类中的 clone ()方法来复制新的对象。</li></ul><p>接口类图如下</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230209144558097.png" alt="image-20230209144558097"></p><p><strong>原型模式分为深克隆和浅克隆</strong></p><p><strong>浅克隆：</strong>创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。（克隆出来的对象与原对象地址是相同的）</p><p><strong>深克隆：</strong>创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。（克隆出来的对象地址与原对象不同）</p><p>Java中的object类中提供了clone()方法来实现浅克隆。cloneable接口是上面的类图中的抽象原型类，而实现了cloneable接口的子实现类就是具体的原型类。代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  真实对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Realizetype</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Realizetype</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;原型真实对象创建成功~~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;克隆对象创建成功！！！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>【例】克隆羊</strong></p><p>克隆羊一般外形都会很向，所以需要对克隆羊进行编号以防识别混乱，所以克隆羊除了编号不同，宏观上都几乎相同，以下是克隆羊的类图</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230209151345250.png" alt="image-20230209151345250"></p><p>代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  真实的羊</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RealSheep</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;羊名称：【&quot;</span> + name + <span class="string">&quot;】&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> RealSheep <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> (RealSheep) <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CloneSheepTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">RealSheep</span> <span class="variable">realSheep</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RealSheep</span>();</span><br><span class="line">        <span class="comment">// 克隆</span></span><br><span class="line">        <span class="type">RealSheep</span> <span class="variable">clone1</span> <span class="operator">=</span> realSheep.clone();</span><br><span class="line">        realSheep.setName(<span class="string">&quot;多利（真实羊）&quot;</span>);</span><br><span class="line">        clone1.setName(<span class="string">&quot;001（克隆羊）&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印</span></span><br><span class="line">        realSheep.show();</span><br><span class="line">        clone1.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>概述：将一个复杂对象的构建和表示分离，使同样的构建过程可以创建不同的表示</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230210142739106.png" alt="image-20230210142739106"></p><p>( 1 )、分离了部件的构建（由Builder完成）和装配（由Director完成），从而构建出复杂对象，适用于：某个对象的构建过程复杂的情况</p><p>( 2 ) 、由于实现了装配和构建器的解耦，相同的构建器，不同的装配可以建造出不同的对象；不同的构建器，相同的装配也可创建出不同的对象，提高了复用性</p><p>( 3 )、建造者模式可以将部件和组装过程分开，一步一步构建复杂对象，用户只需要指定目标对象，就可以获得该对象，无需关心内部实现。</p><p><strong>建造者模式的结构</strong></p><p>( 1 )、抽象建造者类(Builder)：这个接口规定要实现复杂对象的那些部分的创建，并不涉及具体的部件对象的创建。</p><p>( 2 )、具体建造者类(ConcreteBuilder)：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。在构造过程完成后，提供产品的实例。</p><p>( 3 )、产品类(Product)：要创建的复杂对象。</p><p>( 4 )、指挥者类(Director)：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230210145317708.png" alt="image-20230210145317708"></p><p>【例】手机的生产构建</p><p>假设，手机的构建过程都是大同小异，不同品牌的手机可能外形不一样或者内部芯片不一样，但归根结底每种智能手机都有芯片、存储器（内存）等部件，这样的一个构建过程就可以使用创建者模式进行构建出。现在需要构建出OPPO和华为这两种品牌的手机，只需要构建芯片、存储器（内存）即可，类图如下</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230210153633699.png" alt="image-20230210153633699"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  智能手机类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Smartphone</span> &#123;</span><br><span class="line">    <span class="comment">// 名称</span></span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="comment">// 品牌</span></span><br><span class="line">    <span class="keyword">protected</span> String brand;</span><br><span class="line">    <span class="comment">// 内存</span></span><br><span class="line">    <span class="keyword">private</span> String memory;</span><br><span class="line">    <span class="comment">// 芯片</span></span><br><span class="line">    <span class="keyword">private</span> String chip;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMemory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> memory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMemory</span><span class="params">(String memory)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.memory = memory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getChip</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> chip;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setChip</span><span class="params">(String chip)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.chip = chip;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  oppo品牌手机</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OppoPhone</span> <span class="keyword">extends</span> <span class="title class_">Builder</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">buildChip</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.phone.setChip(<span class="string">&quot;马里亚纳 MariSilicon X&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">buildMemory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.phone.setMemory(<span class="string">&quot;128G&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">buildBaseInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.phone.brand = <span class="string">&quot;OPPO&quot;</span>;</span><br><span class="line">        <span class="built_in">super</span>.phone.name = <span class="string">&quot;OPPO Reno9&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Smartphone <span class="title function_">getProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> phone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  华为</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HuaweiPhone</span> <span class="keyword">extends</span> <span class="title class_">Builder</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">buildChip</span><span class="params">()</span> &#123;</span><br><span class="line">        phone.setChip(<span class="string">&quot;骁龙888&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">buildMemory</span><span class="params">()</span> &#123;</span><br><span class="line">        phone.setMemory(<span class="string">&quot;256G&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">buildBaseInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        phone.name = <span class="string">&quot;HUAWEI P50&quot;</span>;</span><br><span class="line">        phone.brand = <span class="string">&quot;华为&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Smartphone <span class="title function_">getProduct</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> phone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  指挥者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Director</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Builder builder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Director</span><span class="params">(Builder builder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.builder = builder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取已构建完成的产品</span></span><br><span class="line">    <span class="keyword">public</span> Smartphone <span class="title function_">construct</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 装配</span></span><br><span class="line">        builder.buildChip();</span><br><span class="line">        builder.buildMemory();</span><br><span class="line">        builder.buildBaseInfo();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> builder.getProduct();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  抽象建造者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">Smartphone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Smartphone</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建芯片</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildChip</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 构建内存</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildMemory</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 构建基础信息</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildBaseInfo</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 获取到具体产品</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> Smartphone <span class="title function_">getProduct</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  客户</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建指挥者对象并传入目标品牌的手机对象</span></span><br><span class="line">        <span class="comment">// Director director = new Director(new HuaweiPhone());</span></span><br><span class="line">        <span class="type">Director</span> <span class="variable">director</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Director</span>(<span class="keyword">new</span> <span class="title class_">OppoPhone</span>());</span><br><span class="line">        <span class="comment">// 进行构建</span></span><br><span class="line">        <span class="type">Smartphone</span> <span class="variable">phone</span> <span class="operator">=</span> director.construct();</span><br><span class="line">        <span class="comment">// 打印信息</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;成功建造出 品牌【%s】,名称【%s】,芯片型号【%s】,内存【%s】&quot;</span>,phone.brand,phone.name,</span><br><span class="line">                phone.getChip(),phone.getMemory());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点如下</strong></p><p>( 1 )、建造者模式的封装性很好。使用建造者模式可以有效的封装变化，在使用建造者模式的场景中，一般产品类和建造者类是比较稳定的，因此，将主要的业务逻辑封装在指挥者类中对整体而言可以取得比较好的稳定性。</p><p>( 2 )、在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。</p><p>( 3 )、可以更加精细地控制产品的创建过程。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。</p><p>( 4 )、建造者模式很容易进行扩展。如果有新的需求，通过实现一个新的建造者类就可以完成，基本上不用修改之前已经测试通过的代码，因此也就不会对原有功能引入风险。符合【开闭原则】。</p><p><strong>缺点：</strong>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。</p><p><em><strong>使用场景</strong></em></p><p>建造者(Builder)模式创建的是复杂对象，其产品的各个部分经常面临着剧烈的变化，但将它们组合在一起的算法却相对稳定，所以它通常在以下场合使用。</p><p>( 1 )、创建的对象较复杂，由多个部件构成，各部件面临着复杂的变化，但构件间的建造顺序是稳定的。</p><p>( 2 )、创建复杂对象的算法独立于该对象的组成部分以及它们的装配方式，即产品的构建过程和最终的表示是独立的。</p><h2 id="创建者模式的对比"><a href="#创建者模式的对比" class="headerlink" title="创建者模式的对比"></a>创建者模式的对比</h2><h3 id="工厂方法模式VS建造者模式"><a href="#工厂方法模式VS建造者模式" class="headerlink" title="工厂方法模式VS建造者模式"></a>工厂方法模式VS建造者模式</h3><p>工厂方法模式注重的是对整体对象的创建，而建造者模式注重的是部件构建的过程，意在一步一步的通过精确的构建出复杂对象</p><p><strong>例子：</strong>假如A工厂（采用工厂方法模式）需要生产台式电脑，那么A工厂是直接生产出整台的电脑。B工厂（采用建造者模式）生产台式电脑是通过一个一个部件组装成一台电脑。</p><h3 id="抽象工厂模式VS建造者模式"><a href="#抽象工厂模式VS建造者模式" class="headerlink" title="抽象工厂模式VS建造者模式"></a>抽象工厂模式VS建造者模式</h3><p>抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式则是不需要关心构建过程，只关心什么产品由什么工厂生产即可。</p><p>建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品。</p><p>如果将抽象工厂模式看成汽车配件生产工厂，生产一个产品族的产品，那么建造者模式就是一个汽车组装工厂，通过对部件的组装可以制造出—辆完整的汽车</p><h1 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h1><p>概述：结构型模式描述如何将类或对象按某种布局组成更大的结构。它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类。后者采用组合或聚合来组合对象。由于组合关系或聚合关系比继承关系耦合度低，满足【合成复用原则】，所以对象结构型模式比类结构型模式具有更大的灵活性。</p><p><strong>分为7种模式：代理模式、适配器模式、桥接模式、装饰模式、外观模式、组合模式、享元模式。</strong></p><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p><strong>概述：</strong>由于某种原因需要某个对象提供代理控制对该对象访问。这时，访问对象不适合或者不能直接访问到目标对象，代理对象是作为访问对象和目标对象的中介</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230212133649876.png" alt="image-20230212133649876"></p><p><strong>分类：</strong>java中按照代理类生成时机不同，分为<u>静态代理</u>和<u>动态代理</u>，静态代理类是在编译时期完成，动态代理是在java程序运行时期动态生成的类，动态代理又分为JDK和CGLIB代理。</p><p>代理模式分为以下三最种角色：</p><p>( 1 )、抽象主题(subject)类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。</p><p>( 2 )、真实主题(Real subject)类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。</p><p>( 3 )、代理(Proxy)类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问控制或扩展真实主题的功能。</p><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p><strong>【例】火车站买票</strong> </p><p>如果要买火车票的话，需要去火车站买票，坐车到火车站，排队等一系列的操作，显然比较麻烦而火车站在多个地方都有代售点，我们去代售点买票就方便很多了。这个例子其实就是典型的代理模式，火车站是目标对象，代售点是代理对象。类图如下：</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230212134745447.png" alt="image-20230212134745447"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  售卖票窗口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SellTicketWindow</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sellTicket</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  火车站</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrainStation</span> <span class="keyword">implements</span> <span class="title class_">SellTicketWindow</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sellTicket</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;火车票数售卖成功~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  代理售卖点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyPoint</span> <span class="keyword">implements</span> <span class="title class_">SellTicketWindow</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">TrainStation</span> <span class="variable">trainStation</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrainStation</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sellTicket</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;收取售卖代理费用10元&quot;</span>);</span><br><span class="line">        trainStation.sellTicket();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  客户</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 用户找代理商买票</span></span><br><span class="line">        <span class="type">ProxyPoint</span> <span class="variable">point</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyPoint</span>();</span><br><span class="line"></span><br><span class="line">        point.sellTicket();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong>从以上代码中可以看出ProxyPoint类是目标对象和访问对象的中介，ProxyPoint类可以对售卖票这一行为进行增强，例如收取一定的代理服务费用等等</p><h3 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><p>对【火车站买票】卖票的例子进行一个改造，使用动态代理动态生成代理售卖点，使用java提供的java.lang.reflect.Proxy包下的newProxyInstance方法动态代理，<strong>注意：JDK代理是只能对接口进行代理。</strong></p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230212203321103.png" alt="image-20230212203321103"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  售卖票窗口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SellTicketWindow</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sellTicket</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  火车站</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrainStation</span> <span class="keyword">implements</span> <span class="title class_">SellTicketWindow</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sellTicket</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;火车票数售卖成功~~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  获取代理对象的工厂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyPointFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> TrainStation station;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        station = <span class="keyword">new</span> <span class="title class_">TrainStation</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SellTicketWindow <span class="title function_">getProxyPoint</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">SellTicketWindow</span> <span class="variable">instance</span> <span class="operator">=</span> (SellTicketWindow) Proxy.newProxyInstance(</span><br><span class="line">                station.getClass().getClassLoader(),</span><br><span class="line">                station.getClass().getInterfaces(),</span><br><span class="line">                <span class="comment">// 动态代理后执行的方法</span></span><br><span class="line">                ((proxy, method, args) -&gt; &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;收取代理费用（JDK动态代理执行）&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span>  method.invoke(station,args);</span><br><span class="line">                &#125;));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建代理工厂</span></span><br><span class="line">        <span class="type">ProxyPointFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyPointFactory</span>();</span><br><span class="line">        <span class="comment">// 从代理工厂中生产一个代理对象</span></span><br><span class="line">        <span class="type">SellTicketWindow</span> <span class="variable">proxyPoint</span> <span class="operator">=</span> factory.getProxyPoint();</span><br><span class="line">        proxyPoint.sellTicket();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态代理VS动态代理"><a href="#静态代理VS动态代理" class="headerlink" title="静态代理VS动态代理"></a>静态代理VS动态代理</h3><p>动态代理与静态代理相比较，最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理。这样，在接口方法数量比较多的时候，我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。如果接口增加一个方法，静态代理模式除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。而动态代理不会出现该问题</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>优点：</strong></p><p>( 1 )、代理模式是在客户端和目标对象中起一个中介和保护的作用</p><p>( 2 )、代理对象可以扩展目标对象的功能</p><p>( 3 )、代理对象分离了客户端和目标对象之间的直接访问，在一定程度上降低了系统的耦合度</p><p><strong>缺点：</strong>增加了系统的复杂度</p><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p><strong>定义：</strong>将一个类的接口转换成用户所期望的接口，使得原本不兼容的接口能在一起工作。</p><p><strong>分类：</strong>适配器模式分为【对象适配器】和【类适配器】，类适配器需要程序员了解类内部组件且耦合度较高，一般使用【对象适配器】</p><p><strong>适配器模式(Adapter）包含以下主要角色</strong></p><p>( 1 )、目标(Target)接口：当前系统业务所期待的接口，它可以是抽象类或接口</p><p>( 2 )、适配者(Adaptee)类：它是被访问和适配的现存组件库中的组件接口。</p><p>( 3 )、适配器(Adapter)类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问活配者。</p><h3 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a>类适配器</h3><p><strong>【例】读卡器</strong></p><p>现有一台计算机只能读取SD卡中的内容，那么需要读取TF卡中的内容就需要使用到适配器模式，通过适配器将TF接口转化为SD接口兼容工作。类图如下</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230213212659143.png" alt="image-20230213212659143"></p><p><strong>注意：</strong>类适配器模式违背了【合成复用原则】。类适配器是客户类有一个接口规范的情况下可用，反之不可用</p><h3 id="对象适配器"><a href="#对象适配器" class="headerlink" title="对象适配器"></a>对象适配器</h3><p>对<strong>【例】读卡器</strong>进行了一个改造，将TFCard接口聚合到适配器类中，这样一来就符合了【合成复用原则】</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230213215059035.png" alt="image-20230213215059035"></p><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>( 1 )、以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。</p><p>( 2 )、使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。</p><h3 id="JDK中的适配器应用"><a href="#JDK中的适配器应用" class="headerlink" title="JDK中的适配器应用"></a>JDK中的适配器应用</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;设计原则&quot;&gt;&lt;a href=&quot;#设计原则&quot; class=&quot;headerlink&quot; title=&quot;设计原则&quot;&gt;&lt;/a&gt;设计原则&lt;/h1&gt;&lt;p&gt;在软件开发中，为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性，程序员要尽量根据6条原则来开发程序，从而提高</summary>
      
    
    
    
    
    <category term="java;设计模式;" scheme="http://example.com/tags/java-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>java实现二维码</title>
    <link href="http://example.com/2023/01/26/java%E5%AE%9E%E7%8E%B0%E4%BA%8C%E7%BB%B4%E7%A0%81/"/>
    <id>http://example.com/2023/01/26/java%E5%AE%9E%E7%8E%B0%E4%BA%8C%E7%BB%B4%E7%A0%81/</id>
    <published>2023-01-26T12:34:00.000Z</published>
    <updated>2023-01-26T13:24:32.766Z</updated>
    
    <content type="html"><![CDATA[<p>本文章中会介绍如何使用Hutool开源工具包进行二维码的生成，在业务需求中也经常看到需要用到二维码，可以用二维码进行手机扫码登入、扫码支付、扫码加好友等等一系列的需求，但人们知道使用二维码，那二维码到底是一个什么样的实现过程呢？更多详情请看下文</p><p><strong>实现步骤如下</strong></p><p>(1) 首先需要创建一个SpringBoot的项目工程。</p><p>(2)  在pom.xml文件中引入以下三个坐标，这三个包中已经实现了二维码的底层，我们只需要调用其所提供的API接口进行一些参数的调整即可。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- zxing生成二维码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.zxing<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.zxing<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javase<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--开发工具集--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.hutool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hutool-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.6.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>(3)  创建一个配置类，用来配置二维码的长宽或背景色等等属性，然后将二维码的配置方法注入成Bean对象即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QrcConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  将二维码生成器注入为Bean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> QrConfig <span class="title function_">qrConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 设置长和宽，若没有设置则默认300 300</span></span><br><span class="line">        <span class="comment">// QrConfig qrConfig = new QrConfig(300,300);</span></span><br><span class="line">        <span class="type">QrConfig</span> <span class="variable">qrConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QrConfig</span>();</span><br><span class="line">        <span class="comment">// 设置二维码和边框的距离px</span></span><br><span class="line">        qrConfig.setMargin(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 设置背景色</span></span><br><span class="line">        qrConfig.setBackColor(Color.WHITE.getRGB()).setForeColor(Color.BLACK.getRGB());</span><br><span class="line">        <span class="keyword">return</span> qrConfig;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(4) 生成二维码返回给前端页面和将生成的二维码保存到本地磁盘的业务实现过程如下，以下是业务方法的实现过程，这是在service层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  二维码服务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QrServiceImpl</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> QrConfig qrConfig;</span><br><span class="line">   </span><br><span class="line"><span class="comment">// 保存到本地磁盘上</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveQrToLocalFile</span><span class="params">(String content, String filePath)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isEmpty(content) || StringUtils.isEmpty(filePath)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> FileUtil.file(filePath);</span><br><span class="line">        <span class="comment">// 判断是否是一个目录</span></span><br><span class="line">        <span class="keyword">if</span>(!file.isDirectory()) &#123;</span><br><span class="line">            <span class="comment">// 不是目录，则默认放到桌面上</span></span><br><span class="line">            file = FileSystemView.getFileSystemView().getHomeDirectory();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断该路径是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(!file.exists()) &#123;</span><br><span class="line">            <span class="comment">// 说明不存在</span></span><br><span class="line">            file.mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取图片，使用Hutool提供的QrCodeUtil工具类生成</span></span><br><span class="line">        <span class="type">BufferedImage</span> <span class="variable">bufferedImage</span> <span class="operator">=</span> QrCodeUtil.generate(content, qrConfig);</span><br><span class="line">        <span class="comment">// 定义文件名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> UUID.randomUUID().toString(<span class="literal">true</span>) + <span class="string">&quot;.png&quot;</span>;</span><br><span class="line">        <span class="comment">// 创建文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">qrFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(file,fileName);</span><br><span class="line">        <span class="comment">// 输出到磁盘中</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ImageIO.write(bufferedImage,<span class="string">&quot;png&quot;</span>,qrFile);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// 将二维码输出到页面上</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transferToWebpage</span><span class="params">(String content, HttpServletResponse response)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            QrCodeUtil.generate(content,qrConfig,<span class="string">&quot;png&quot;</span>,response.getOutputStream());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(5) 以下是controller层的代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  二维码前端控制器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/qr&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QrcController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> QrService qrService;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@GetMapping(&quot;/message&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">getQrcode</span><span class="params">(HttpServletResponse response)</span> &#123;</span><br><span class="line">        qrService.transferToWebpage(<span class="string">&quot;https://www.baidu.com&quot;</span>,response);</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PostMapping(&quot;/save&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">save</span><span class="params">(<span class="meta">@RequestBody</span> SaveQrcodeVo qrcodeVo)</span> &#123;</span><br><span class="line">        qrService.saveQrToLocalFile(qrcodeVo.getContent(),qrcodeVo.getFilePath());</span><br><span class="line">        <span class="keyword">return</span> Result.ok();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SaveQrcodeVo类是接收来自页面上的请求json参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SaveQrcodeVo</span> &#123;</span><br><span class="line">   <span class="comment">// 二维码的内容</span></span><br><span class="line">    <span class="keyword">private</span> String  content;</span><br><span class="line">   <span class="comment">// 二维码的保存路径</span></span><br><span class="line">    <span class="keyword">private</span> String filePath;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getContent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContent</span><span class="params">(String content)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getFilePath</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> filePath;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFilePath</span><span class="params">(String filePath)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.filePath = filePath;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230126211248883.png" alt="image-20230126211248883"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文章中会介绍如何使用Hutool开源工具包进行二维码的生成，在业务需求中也经常看到需要用到二维码，可以用二维码进行手机扫码登入、扫码支付、扫码加好友等等一系列的需求，但人们知道使用二维码，那二维码到底是一个什么样的实现过程呢？更多详情请看下文&lt;/p&gt;
&lt;p&gt;&lt;strong</summary>
      
    
    
    
    
    <category term="java;二维码" scheme="http://example.com/tags/java-%E4%BA%8C%E7%BB%B4%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>java面试篇笔记</title>
    <link href="http://example.com/2023/01/17/java%E9%9D%A2%E8%AF%95%E7%AF%87%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2023/01/17/java%E9%9D%A2%E8%AF%95%E7%AF%87%E7%AC%94%E8%AE%B0/</id>
    <published>2023-01-17T11:20:00.000Z</published>
    <updated>2023-02-04T07:11:43.497Z</updated>
    
    <content type="html"><![CDATA[<h1 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h1><p>概述：最常见的查找算法有两种，一种是顺序查找，另一种是二分查找。</p><ul><li>顺序查找的特点：适用范围广，可以查找像数组和链表这两种数据结构并且数据元素可以无序的，但查询效率低，时间复杂度O(n)</li><li>二分查找的特点：适用范围相对顺序查找小，只能查找像数组这样的数据结构并且要求数据必须是有序，查询效率高，时间复杂度O(logn)，那么以下代码是这两种算法的实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  顺序查找算法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderSearch</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        System.out.println(orderSortMulti(arr,<span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 只要查找到第一个目标元素就返回</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 从该数组中查找目标元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target 目标元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 目标元素所在的下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">orderSort</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">// 顺序遍历查找即可</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 查询不到返回-1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  若目标元素在数组中有多个，例如&#123;5,1,4,5,6,7,2,0&#125; 在这一数组中要找目标为5，那要如何实现呢？</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">orderSortMulti</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(target == arr[i]) &#123;</span><br><span class="line">                result.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  二分查找</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinarySearch</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] array = &#123;<span class="number">1</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>,<span class="number">26</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> binarySearch(array, <span class="number">19</span>,<span class="number">0</span>,array.length);</span><br><span class="line">        System.out.println(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//二分查找实现方法 -- 迭代方式  前提:有已排序数组A（假设已经做好)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">//1. 定义左边界和右边界</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="comment">//2.获取中间索引mid = Floor((L+R)/2)</span></span><br><span class="line">        <span class="type">int</span> mid;</span><br><span class="line">        <span class="comment">//循环</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123; <span class="comment">//4.当left&gt;right时，表示没有找到，应结束循环</span></span><br><span class="line">            mid = left + (left - right) / <span class="number">2</span>; <span class="comment">//解决整数溢出问题</span></span><br><span class="line">            <span class="comment">//5.中间索引的值 A[M]与待搜索的值T进行比较</span></span><br><span class="line">            <span class="keyword">if</span>(arr[mid] &gt; target) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 未找到目标值的下标</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//二分查找方法 -- 递归方式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> target,<span class="type">int</span> left,<span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="comment">//判断是否已经结束</span></span><br><span class="line">        <span class="keyword">if</span>(left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//1. 判断中间值是否大于目标值</span></span><br><span class="line">        <span class="keyword">if</span>(arr[mid] &gt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span> binarySearch(arr,target,left,mid - <span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[mid] &lt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span> binarySearch(arr,target,mid + <span class="number">1</span>,right);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//2. 相等直接返回下标即可</span></span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的代码有一个毛病，就是二分查找若数组中有多个目标数据，例如在{1,2,4,5,6,6,6,6,7,8,9}中查找6这个目标数据所在的下标，那应该如何实现呢？</p><h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="冒泡排序算法"><a href="#冒泡排序算法" class="headerlink" title="冒泡排序算法"></a>冒泡排序算法</h2><p>概述：冒泡排序是比较排序，<strong>以升序为主</strong>，即给定一个无序的数组，每轮排序所有相邻的元素都会进行一个比较，若前一个数与后一个数大则进行数交换位置的操作，最后将最大的那个数排到数组最后一个位置，这就是冒泡排序，以下是冒泡排序的实现代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  冒泡排序算法的实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BubbleSort</span> &#123;</span><br><span class="line">    <span class="comment">// 记录循环的次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">24</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        bubbleSort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="comment">// 因为是每次两个数进行比较，所以总的排序次数是arr.length - 1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">           <span class="comment">// 注意arr.length - 1 - i这里的-i是将冒泡的最后有序部分剔除掉，避免重复无效的排序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="comment">// 说明两个相邻的数，左边的数比右边的大就进行交换操作</span></span><br><span class="line">                    swap(arr,j,j+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                count ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;总的循环次数为：&quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数交换</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 无序数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i 相邻两个数的左边下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j 相邻两个数的右边下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230117195938657.png" alt="image-20230117195938657"></p><p>在以上的冒泡排序算法中还存在一个问题，那就是若本来就有序的数组还是会重复无效的进行比较排序，这样就显得多此一举，故我们可以定义一个标志位进行一个判断，若一个数组已经是处于一个有序状态，则就可以提前结束循环，从而避免无效的排序循环。具体实现如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  冒泡排序算法的实现--优化version1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BubbleSort</span> &#123;</span><br><span class="line">    <span class="comment">// 记录循环的次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        bubbleSort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="comment">// 标志位</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 因为是每次两个数进行比较，所以总的排序次数是arr.length - 1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 改变标志位，说明该轮循环有进行交换操作</span></span><br><span class="line">                  flag = <span class="literal">true</span>;</span><br><span class="line">                   <span class="comment">// 说明两个相邻的数，左边的数比右边的大就进行交换操作</span></span><br><span class="line">                    swap(arr,j,j+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                count ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!flag) &#123;</span><br><span class="line">                <span class="comment">// 在某一轮未进行比较操作，则可以说明该数组已经处于有序状态了</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;总的循环次数为：&quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数交换</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 无序数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i 相邻两个数的左边下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j 相邻两个数的右边下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>冒泡排序总结</strong></p><p>主要核心思想是：依次比较数组中相邻的两个元素，若前面的元素比后面的元素大，则需要进行交换，最后会将最大的数放到数组的最后位置。重复此操作最后数组就会变成有序的。时间复杂度是O(n^2)，空间复杂度是O(n)，并且是稳定排序。</p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>概述：在选择排序中数组分为有序部分和无序部分，每轮的排序都会将无序部分中最小的值排到有序部分上，例如，数组[8,2,1,4,5]，会先假定第一个值8为最小值，然后跟8后面的部分（无序部分）进行比较，若发现有比8还小的值（无序部分中最小的值），则将最小的值和8的位置进行交换，第二轮会假定2为最小值，以此类推，最终都会变得有序，以下是具体代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  选择排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">8</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        selectionSort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">selectionSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 先假定数组的第一个为最小的值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">minIndex</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="comment">// 在遍历寻找minIndex后边的值，是否存在比当前的值还小，若存在，则需要进行交换</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> minIndex + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[minIndex] &gt; arr[j]) &#123;</span><br><span class="line">                    minIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(minIndex != i) &#123;</span><br><span class="line">                <span class="comment">//说明在minIndex后边存在比当前的值还小，进行交换</span></span><br><span class="line">                swap(arr,minIndex,i);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Arrays.toString(arr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 数据元素交换，将i所在位置和j所在位置进行交换</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230117220509754.png" alt="image-20230117220509754"></p><p><strong>选择排序的总结</strong></p><p>选择排序的时间复杂度是O(n^2)，空间复杂度O(n)，是属于不稳定排序算法。</p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>概述：插入排序也分为有序部分和无序部分，有序部分会不断扩大，最终都将变成有序的数组，具体代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsertSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">9</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">        insertSort(arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 插入排序的实现方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="comment">// 首先从无序部分开始遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i]; <span class="comment">// 先暂时保存无序部分的第一个值，为后续的插入做准备</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - <span class="number">1</span>; <span class="comment">//有序部分的最后一个元素的索引</span></span><br><span class="line">            <span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; j--) &#123; <span class="comment">// temp依次比较有序部分的值，找到自己的合适位置</span></span><br><span class="line">                <span class="keyword">if</span>(temp &lt; arr[j]) &#123;</span><br><span class="line">                    <span class="comment">// 说明temp的值与当前的值小，当前的值需要往后移一位</span></span><br><span class="line">                    arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 说明temp值已经找到了合适的位置，结束循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前面的循环出来后，j + 1所在的索引就是temp值所在的位置</span></span><br><span class="line">            arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            System.out.println(Arrays.toString(arr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>插入排序的总结</strong></p><p>插入排序分为有序区域和无序区域，每轮排序都会从无序区域的第一个元素插入到有序区域的合适位置上（在有序部分碰到比temp值小的就可以确定temp的值所插入的位置），需要保证有序区域的有序性，重复以上步骤最终可以得到整体有序的数组。时间复杂度为O(n^2)，是稳定排序。<strong>执行的效率：插入排序 &gt; 选择排序 &gt; 冒泡排序</strong></p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>概述：快速排序是需要选择一个基准点pivot，然后进行每轮的排序，基准点的左边的值都比基准点本身的值小，右边的值都比基准点本身的值大，每次都会进行一个分区比较，每个区中都有一个基准点，最终分区的元素为0时，说明数组已经是基于有序了。这里体现的是分而治之的思想。以下代码是快速排序的实现过程（两种方式）</p><ul><li>单边循环快排</li></ul><p>在单边循环中一般选择数组最右边的元素作为基准点，这里实现的代码有两个指针<strong>i和j</strong>，<strong>i</strong>代表的是维护比基准点值小的左边界和每次交换的目标索引，<strong>j</strong>代表的是寻找比基准点还小的值与<strong>i</strong>所在的位置进行交换，最后<strong>i</strong>会和基准点进行交换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  快速排序--单边</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">5</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        quickSort(arr,<span class="number">0</span>,arr.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> left,<span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right) &#123;</span><br><span class="line">            <span class="comment">// 没有元素可以再进行分区，结束递归分区</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1. 进行一个分区并返回分区后基准点所在的索引位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivotIndex</span> <span class="operator">=</span> portion(arr, left, right);</span><br><span class="line">        <span class="comment">// 2. 根据基准点所在的位置对基准点左边在进行分区</span></span><br><span class="line">        quickSort(arr, left, pivotIndex - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 3. 根据基准点所在的位置对基准点右边进行分区</span></span><br><span class="line">        quickSort(arr, pivotIndex + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 待排序的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left 数组左边的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right 数组右边的所有</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 经过分区后i指针所在的位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">portion</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="comment">// 最右边的元素作为基准点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[right];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="comment">// j指针寻找比pivot小的值所在的位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> left; j &lt; right; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &lt; pivot) &#123;</span><br><span class="line">                <span class="comment">// 说明找到了，就与i进行交换</span></span><br><span class="line">                swap(arr,i,j);</span><br><span class="line">                i ++; <span class="comment">// i需要右移一位</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后将i与基准点所在位置进行交换</span></span><br><span class="line">        swap(arr,i,right);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数交换</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 无序数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i 相邻两个数的左边下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j 相邻两个数的右边下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230118150315998.png" alt="image-20230118150315998"></p><ul><li>双边循环快排</li></ul><p>概述：双边循环也称为双指针循环，一般数组的最左边元素是作为基准点，在双指针中假设是i和j，i的职责是从左往右寻找比级基准点大的元素，j的职责是从右往左寻找比基准点小的元素，若ij分别找到各自的元素则进行交换，最后i和j相交时则结束寻找，此时的i就是分区的位置，最后i和基准点需要进行一次交换。</p><p><strong>细节问题</strong>：在i和j指针寻找的顺序，必须先寻找小的值，然后再寻找大的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  快速排序--双边循环</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">5</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">        quickSort(arr,<span class="number">0</span>,arr.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> left,<span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right) &#123;</span><br><span class="line">            <span class="comment">// 没有元素可以再进行分区，结束递归分区</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1. 进行一个分区并返回分区后基准点所在的索引位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivotIndex</span> <span class="operator">=</span> portion(arr, left, right);</span><br><span class="line">        <span class="comment">// 2. 根据基准点所在的位置对基准点左边在进行分区</span></span><br><span class="line">        quickSort(arr, left, pivotIndex - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 3. 根据基准点所在的位置对基准点右边进行分区</span></span><br><span class="line">        quickSort(arr, pivotIndex + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">portion</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> left,<span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="comment">// 选择最左边的作为基准点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[left];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; <span class="comment">// 负责找比基准点大的元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> right;<span class="comment">// 负责找比基准点小的元素</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">           <span class="comment">// 先找小的值</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt; pivot) &#123;</span><br><span class="line">                j --;</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="comment">// 再找大的值</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt;= pivot ) &#123;</span><br><span class="line">                i ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// i 和 j 进行交换</span></span><br><span class="line">            swap(arr,i,j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后i和基准点进行交换</span></span><br><span class="line">        swap(arr,i,left);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数交换</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr 无序数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i 相邻两个数的左边下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j 相邻两个数的右边下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>快速排序的总结</strong></p><p>平均时间复杂度O(nlog2n)，最坏的时间复杂度O(n^2)，对于数据量比较大时使用该算法会有比较明显的优势，是不稳定排序</p><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><h2 id="ArrayList的扩容机制"><a href="#ArrayList的扩容机制" class="headerlink" title="ArrayList的扩容机制"></a>ArrayList的扩容机制</h2><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230118160852310.png" alt="image-20230118160852310"></p><h2 id="LinkedList和ArrayList的比对"><a href="#LinkedList和ArrayList的比对" class="headerlink" title="LinkedList和ArrayList的比对"></a>LinkedList和ArrayList的比对</h2><p><strong>LinkedList</strong></p><ul><li>LinkedList底层是双向链表实现，无需连续内存空间，随机访问慢，头尾插入和删除操作的效率高（因为链表的插入和删除操作不用移动元素），但在插入和删除中间的元素时性能较低（若只考虑插入和删除的操作，则效率高，若考虑定位查找到目标数据或目标位置然后再进行增删操作，则总体的效率低），占用内存大。</li></ul><p><strong>ArrayList</strong></p><ul><li>ArrayList底层是基于数组实现的，需要连续的内存空间来存储数据，可以通过计算来确定数组的下标，从而确定需要访问的目标数据，故随机访问速度快。在一定长度的数组头部和中间数据进行增删操作效率比LinkedList低，但在尾部进行插入和删除的效率比LinkedList高。可以利用CPU缓存和局部性原理（CPU每次读取数据进行计算时都会读取目标数据的相邻元素一起读到缓存中）。占用内存小</li></ul><h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><p>HashMap的底层数据结构JDK1.7和JDK1.8版本有什么区别？</p><ul><li><strong>在JDK1.7版本中HashMap是采用数组+链表，在JDK1.8是数组 +（链表 | 红黑树）</strong></li></ul><p>如何解决HashMap底层的链表过长问题？</p><ul><li><strong>通过给HashMap的数组扩容，但在某个特殊的情况下并不能有效的解决。</strong></li><li><strong>通过树化链表可以有效解决，前提条件是在HashMap的数组长度达到（&gt;&#x3D;64）才能触发树化效果并且在某个数组下的节点大到8个节点</strong></li></ul><p>为何需要使用红黑树？为什么不是一上来就树化？</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230119150749106.png" alt="image-20230119150749106"></p><p>HashMap的索引计算？</p><ul><li><strong>通过调用hash的方法来计算对象的HashCode，然后再模于数组的长度 - 1，&gt;&gt; 公式：hash值 mod 数组长度 - 1</strong></li></ul><p>为何需要进行二次的hashCode的计算？</p><ul><li><strong>二次hashCode的计算是为了综合高位数据，使得哈希分布更为均匀。</strong></li></ul><p>数组容量为何是2的n次幂？</p><ul><li><strong>因为2的n次幂可以通过位与运算得到取模运算同样的结果，并且位与运算效率更高，扩容时若 hash &amp; 旧容量长度 &#x3D;&#x3D; 0，则元素的位置不变，否则新位置&#x3D;旧位置+旧容量的长度。</strong></li></ul><p>HashMap_put()的流程？</p><ul><li><strong>HashMap是懒惰创建数组的，首次使用才创建数组计算索引（桶下标)</strong></li><li><strong>如果桶下标还没人占用，创建Node占位返回</strong></li><li><strong>如果桶下标已经有人占用</strong><ul><li><strong>已经是TreeNode走红黑树的添加或更新逻辑</strong></li><li><strong>是普通Node，走链表的添加或更新逻辑，如果链表长度超过树化阈值，走树化逻辑</strong></li></ul></li><li><strong>返回前检查容量是否超过阈值，一旦超过进行扩容不同</strong></li></ul><p>HashMap_put()在JDK1.7和JDK1.8的不同？</p><ol><li><strong>链表插入节点时，1.7是头插法，1.8是尾插法。</strong></li><li><strong>1.7是大于阈值（数组长度 * 负载因子(0.75)）且没有空位才进行扩容，1.8是大于阈值就进行扩容。</strong></li><li><strong>1.8比1.7的效率更高。</strong></li></ol><p>加载（负载）因子为何是0.75？</p><ul><li><strong>在空间占用与查询时间之间取得较好的权衡</strong></li><li><strong>大于这个值，空间节省了，但链表就会比较长影响性能</strong></li><li><strong>小于这个值，冲突减少了，但扩容就会更频繁，空间占用多</strong></li></ul><p>多线程下HashMap会出现什么问题（在JDK1.7版本下发生）？</p><ol><li><p><strong>并发丢失数据。</strong></p></li><li><p><strong>由于头插法导致并发下扩容死链问题。</strong></p></li></ol><p>HashMap中的key是否可以为null，作为key的对象有和要求？</p><ol><li><strong>HashMap中的key是可以为null的，但在其它的map集合中是不可以为null的，例如HashTable。</strong></li><li><strong>作为key的对象，必须实现hashCode和equals的方法，并且key对象是不可修改的。</strong></li></ol><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230119203801278.png" alt="image-20230119203801278"></p><h1 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h1><p>以下是单例模式的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> a_based_item1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  饿汉式单例--在该类初始化的时候就创建实例对象，线程是安全的。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 预防反射破坏单例</span></span><br><span class="line">        <span class="keyword">if</span>(INSTANCE != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;单例不可重复创建&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Singleton单例模式初始化。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">otherMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;otherMethod其它方法执行。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>单例被破坏的三最种情况</strong></p><ol><li>反射破坏单例，这是可以预防的，如上代码。</li><li>反序列化破坏单例（可解决）</li><li>unsafe破坏单例（不可解决）</li></ol><p>以下是懒汉式单例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  懒汉式单例--类在加载时不实例化对象，只有等到第一次用的时候才去实例化。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;懒汉式单例初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton2</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 创建实例</span></span><br><span class="line">            INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton2</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在多线程序会破坏单例的证明如下测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  多线程下破坏懒汉式单例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonTest2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建10个线程</span></span><br><span class="line">        creatThreadByNum(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">creatThreadByNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="type">Singleton2</span> <span class="variable">instance</span> <span class="operator">=</span> Singleton2.getInstance();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;&gt;&gt;&quot;</span> + instance);</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.setName(<span class="string">&quot;线程&quot;</span> + (i + <span class="number">1</span>));</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230120144155537.png" alt="image-20230120144155537"></p><p><strong>以下代码是解决多线程下破坏懒汉式单例的方案DCL（Double Check Lock）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  懒汉式单例--DCL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;懒汉式单例初始化&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 需要加volatile，可以解决共享变量的可见性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">Singleton2</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 加锁，防止多线程同时满足条件，同时进行创建实例的代码块</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton2.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton2</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230120144624401.png" alt="image-20230120144624401"></p><h1 id="并发篇"><a href="#并发篇" class="headerlink" title="并发篇"></a>并发篇</h1><h2 id="Java线程的六种状态"><a href="#Java线程的六种状态" class="headerlink" title="Java线程的六种状态"></a>Java线程的六种状态</h2><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230120150100666.png" alt="image-20230120150100666"></p><p><strong>下图是操作系统中的线程状态</strong></p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230121140706806.png" alt="image-20230121140706806"></p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p><strong>java.util.concurrent.ThreadPoolExecutor</strong></p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230121142617613.png" alt="image-20230121142617613"></p><h2 id="Wait-VS-Sleep"><a href="#Wait-VS-Sleep" class="headerlink" title="Wait VS Sleep"></a>Wait VS Sleep</h2><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230121150713734.png" alt="image-20230121150713734"></p><h2 id="Lock-VS-Synchronized"><a href="#Lock-VS-Synchronized" class="headerlink" title="Lock VS Synchronized"></a>Lock VS Synchronized</h2><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230121152148928.png" alt="image-20230121152148928"></p><p><strong>公平锁与非公平锁的区别？</strong></p><ul><li>公平锁是在阻塞队列中的线程分别以先进先出的形式依次执行线程</li><li>非公平锁不是以先进先出的形式出现，有可能出现其他线程插队的情况。</li></ul><h2 id="Volatile关键字"><a href="#Volatile关键字" class="headerlink" title="Volatile关键字"></a>Volatile关键字</h2><p><strong>线程安全包括三个方面：可见性、有序性、原子性</strong></p><ul><li>可见性：是一个线程对某个变量进行修改，其它线程是能看到最新的结果</li><li>有序性：一个线程中的代码是按照编码顺序执行的</li><li>原子性：一个线程中的代码是以一个整体运行的，在运行期间不可以有其它线程代码插队</li></ul><p><strong>Volatile关键字可以保证可见性和有序性，不能保证原子性</strong></p><h2 id="乐观锁VS悲观锁"><a href="#乐观锁VS悲观锁" class="headerlink" title="乐观锁VS悲观锁"></a>乐观锁VS悲观锁</h2><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230124144738446.png" alt="image-20230124144738446"></p><h2 id="HashTable-VS-ConcrrentHashMap"><a href="#HashTable-VS-ConcrrentHashMap" class="headerlink" title="HashTable VS ConcrrentHashMap"></a>HashTable VS ConcrrentHashMap</h2><ol><li>HashTable和ConcrrentHashMap都是线程安全的（相同点）。</li><li>HashTable由于底层是用同一把锁，则每次只能有一个线程操作，则并发度较低。</li><li>ConcrrentHashMap在JDK1.8版本之前采用segment+数组+链表，每个segment对应一把锁，多个线程访问时都会获取不同的锁，则不会冲突。</li><li>在JDK1.8之后ConcrrentHashMap采用头节点作为锁，若多个线程访问不同的头节点，则不会冲突。</li></ol><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><ol><li>ThreadLocal是可以实现【资源对象】的线程隔离，让每个线程都用自己的【资源对象】，从而避免线程安全的问题。</li><li>ThreadLocal可以实现同个线程间资源共享。</li></ol><p>以下代码是证明以上ThreadLocal的特点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> Integer age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  ThreadLocal证明测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalTest</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  ThreadLocal是底层是基于map实现的，是key-value结构</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;User&gt; tl = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        testOne();</span><br><span class="line">        testTwo(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  测试一：【同个线程间】在从ThreadLocal获取资源对象是否相同？</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testOne</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            tl.set(<span class="keyword">new</span> <span class="title class_">User</span>());</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：&quot;</span> + tl.get());</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：&quot;</span> + tl.get());</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：&quot;</span> + tl.get());</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  测试二：【不同线程间】从ThreadLocal获取资源对象是否相同？</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testTwo</span><span class="params">(<span class="type">int</span> threadNum)</span> &#123;</span><br><span class="line">        <span class="comment">// 根据threadNum创建线程数量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadNum; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                tl.set(<span class="keyword">new</span> <span class="title class_">User</span>());</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：&quot;</span> + tl.get());</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230126135721217.png" alt="image-20230126135721217"></p><p><strong>ThreadLocal的原理</strong></p><p>ThreadLocal类中存在成员变量ThreadLocalMap，ThreadLocalMap本质上还是key-value结构，用于存储资源对象</p><ul><li>当调用set方法是需要存储两个值的，ThreadLocal本身是作为key，资源对象是作为value存储的。</li><li>当调用get方法是根据ThreadLocal本身去寻找value值。</li><li>调用remove方法，是以ThreadLocal本身作为key去移除相关的资源值。</li></ul><p><strong>为什么ThreadLocalMap的key（即ThreadLocal）是弱引用？</strong></p><ol><li>因为ThreadLocal可能会长时间存在线程中，若key不需要再使用，则会在内存不足时将该key释掉。</li><li>第一步只是让key释放掉，但其value未被释放，还需要进一步的根据key是否为null来释放值的内存，释放的时机有如下<ol><li>获取key时发现为null</li><li>set key时，会使用启发式扫描，清除临近的null key，启发次数与元素个数，是否发现 null key有关</li><li>remove时(推荐)，因为一般使用ThreadLocal时都把它作为静态变量，因此GC（jvm的垃圾回收机制）无法回收</li></ol></li></ol><h1 id="JVM虚拟机"><a href="#JVM虚拟机" class="headerlink" title="JVM虚拟机"></a>JVM虚拟机</h1><ul><li>程序私有：程序计数器（记录CPU已经执行到哪行代码）、虚拟机栈</li><li>程序共有：堆、方法区</li></ul><p><em><strong>下图是JVM虚拟机执行java程序代码的整体概况</strong></em></p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230126142916151.png" alt="image-20230126142916151"></p><p>不会出现内存溢出的区域：程序计数器</p><p><strong>出现OutOfMemoryError（OOM）的情况</strong></p><ul><li>堆内存耗尽：对象越来越多且一直在使用，无法被垃圾回收</li><li>方法区内存耗尽：加载的类越来越多，很多框架在启动时会动态的加载所需要的类</li><li>虚拟机栈积累：每个线程最多占用1M的内存，线程个数越来越多，而又长时间不销毁</li></ul><p><strong>出现OutOverflowError的情况</strong></p><ul><li>虚拟机栈内部：方法调用次数过多</li></ul><h2 id="JVM中的内存参数"><a href="#JVM中的内存参数" class="headerlink" title="JVM中的内存参数"></a>JVM中的内存参数</h2><p>对于JVM内存参数有：-Xmx10240m、-Xms10240m、-Xmn5120m、-XX:SurvivoRatio&#x3D;3、其最小内存值和Survivo区总大小分别是？</p><ul><li>-Xmx10240m是代表最大内存10G，-Xms10240m是代表最小内存10G</li><li>-Xmn5120m代表新生代的内存是5G，那么老年代是占用5G</li><li>-XX:SurvivoRatio&#x3D;3代表在新生代内存的比例</li></ul><h2 id="JVM中的垃圾回收算法"><a href="#JVM中的垃圾回收算法" class="headerlink" title="JVM中的垃圾回收算法"></a>JVM中的垃圾回收算法</h2><p><strong>标记清理、标记整理、标记复制这三种垃圾回收算法</strong></p><p>下图是标记清理，清理未标记的类对象，该垃圾回收算法是有缺点的，在白色区域是代表已清理的类对象所遗留下的内存空间，有些内存空间被可用的类对象所隔离开来，就产生了内存碎片。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230126201031183.png" alt="image-20230126201031183"></p><p><strong>标记整理</strong>是为了解决标记清理算法缺点，每次清理完成后都会对可用的类对象进行一个整理，这样就避免了产生内存碎片，但多了一步整理的操作，故效率就会降低。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230126201517144.png" alt="image-20230126201517144"></p><p><strong>标记复制</strong>是需要两个存储空间A和B，假如A需要进行对象清理操作，就可以把在A区域标记的对象复制到B的空闲区域中，然后将A区域的所有空间都清理掉即可，缺点是需要额外的空间。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230126201758602.png" alt="image-20230126201758602"></p><h2 id="GC和分代回收算法"><a href="#GC和分代回收算法" class="headerlink" title="GC和分代回收算法"></a>GC和分代回收算法</h2><p>GC存在的目标是无用对象自动释放、减少内存碎片、加快分配速度。以下是GC的要点</p><ol><li>回收区域是堆内存，不包括虚拟机栈，在方法调用结束会自动释放方法</li><li>占用内存判断无用对象，使用<strong>可达性分析算法</strong>，<strong>三色标记法</strong>标记存活对象，回收未标记对象</li><li>GC具体的实现称为<strong>垃圾回收器</strong></li><li>GC大都采用了分代回收思想，理论依据是大部分对象朝生夕灭，用完立刻就可以回收，另有少部分对象会长时间存活，每次很难回收，根据这两类对象的特性将回收区域分为新生代和老年代，不同区域应用不同的回收策略</li><li>根据GC的规模可以分成 Minor GC，Mixed GC,Full Gc</li></ol><h2 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h2><p><strong>伊甸园(eden)：</strong>最初的对象分配在此区域，与幸存区合成称为新生代。</p><p><strong>幸存区(survivor)：</strong>当伊甸园的内存不足时，触发垃圾回收后的幸存对象分配到此区域，分为from和to区域，采用标记复制法</p><p><strong>老年代(old)：</strong>但幸存区对象熬过几次的垃圾回收（最多15次）后就会晋升为老年代</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230127135449616.png" alt="image-20230127135449616"></p><p><strong>GC的规模</strong></p><p>​Minor GC发生在新生代的垃圾回收，暂停时间短</p><p>​Mixed GC新生代＋老年代部分区域的垃圾回收，G1收集器特有</p><p>​Full GC新生代＋老年代完整垃圾回收，暂停时间长，应尽力避免</p><p><strong>三色标记</strong></p><ol><li>黑色：已标记</li><li>灰色：标记中</li><li>白色：还未标记</li></ol><h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><p>介绍三种垃圾回收器的特点？</p><p><strong>Parallel GC(并行垃圾回收器)</strong></p><ol><li>eden内存不足发生Minor GC，标记复制STW</li><li>old内存不足发生Full GC，标记整理STW</li><li>注重吞吐量</li></ol><p><strong>ConcurrentMarkSweep GC(并发垃圾回收器)</strong></p><ol><li>old并发标记，重新标记时需要STW，并发清除</li><li>Failback Full GC（当总内存不足时会触发回退机制）</li><li>注重响应时间</li></ol><p><strong>G1 GC</strong></p><ol><li>响应时间与吞吐量兼顾</li><li>划分成多个区域，每个区域都可以充当eden,survivor, old,humongous</li><li>新生代回收：eden内存不足，标记复制STW(Stop The Word 是GC事件发生过程中，会产生应用程序的停顿)</li><li>并发标记：old并发标记，重新标记时需要STW</li><li>混合收集：并发标记完成，开始混合收集，参与复制的有eden、survivor、old，其中old会根据暂停时间目标，选择部分回收价值高的区域，复制时STW</li><li>Failback ull GC(回退)</li></ol><h2 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h2><p>概述：大部分的内存溢出是出现在误用了错误的线程池而出现的OutOfMemoryError保错，那么以下是误用线程池的例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  内存溢出测试</span></span><br><span class="line"><span class="comment"> *  -Xmx64m</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OutOfMemoryTest</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个线程池，初始化线程数2</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        generousCreateThread();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  测试线程数创建过多而导致的内存溢出问题</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">generousCreateThread</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 死循环</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            threadPool.submit(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">30</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">                count ++;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230127145448373.png" alt="image-20230127145448373"></p><p><strong>线程创建过多：</strong>造成以上错误的原因是使用了 Executors.newFixedThreadPool()创建线程池，而这种方式创建最大的线程数是Integer.MAX_VALUE的最大值，但线程数超过了最大值必然会出现内存溢出的错误，那么如何解决这种错误呢？根据alibaba的开发手册，在开发中尽量不使用Executors.newFixedThreadPool()创建线程池，一般使用ThreadPoolExecutor创建，自己定义线程池的配置参数。在此文章的并发篇有说到ThreadPoolExecutor创建线程池的配置参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  使用ThreadPoolExecutor创建线程池，看是否会出现内存溢出错误？</span></span><br><span class="line"><span class="comment"> *  -Xmx64m</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OutOfMemoryTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化容量为5的堵塞队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ArrayBlockingQueue&lt;Runnable&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">2</span>,<span class="number">4</span>,<span class="number">0</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">            queue);</span><br><span class="line">    <span class="comment">// 记录线程的名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; records = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        generousCreateThread();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  测试线程数创建过多而导致的内存溢出问题</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">generousCreateThread</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 死循环</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                threadPool.submit(() -&gt; &#123;</span><br><span class="line">                    records.add(Thread.currentThread().getName());</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String name: records) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程名称：&quot;</span> + name);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;提交线程任务的次数：&quot;</span> +  records.size() );</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230127151428616.png" alt="image-20230127151428616"></p><p><strong>每次从数据库查询的数据量过多也会导致内存溢出问题，所以说在查询数据库时需要加上limit条件，避免数据查询过多</strong></p><p><strong>加载的类太多也会导致内存溢出，溢出的是元空间的区域</strong></p><h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><p><strong>加载阶段</strong></p><ol><li>将类的字节码载入方法区，并创建类.class对象</li><li>如果此类的父类还未加载，则先加载父类</li><li>加载是懒惰执行方式（真正用到此类才进行初始化）</li></ol><p><strong>链接阶段</strong></p><ol><li>验证：验证加载的Class对象是否规范、合法性和安全检查</li><li>准备：为static变量分配空间和设置默认值</li><li>解析：将常量池的符号引用解析为直接引用</li></ol><p><strong>初始化</strong></p><ol><li>执行静态代码块和非final的变量赋值</li><li>初始化为懒惰执行</li></ol><h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><p>双亲委派：类加载是优先委派上级类加载器加载，存在以下两种情况</p><ul><li>若在上级加载器中能找到目标类，则由上级类加载器加载，加载的类对下级类加载器可见。</li><li>若上级加载器未找到目标类，则下级加载器才有资格执行加载。</li></ul><h2 id="对象的引用类型有几种"><a href="#对象的引用类型有几种" class="headerlink" title="对象的引用类型有几种"></a>对象的引用类型有几种</h2><p><strong>强引用</strong></p><ol><li><p>普通变量赋值即为强引用，例如：A a &#x3D; new A();</p></li><li><p>通过GC root 引用链的强引用用不到该对象，则会被垃圾回收，若该对象还再被使用，则不能被回收</p></li></ol><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230128142606197.png" alt="image-20230128142606197"></p><p><strong>软引用</strong></p><ol><li>例如：SoftReference s &#x3D; new SoftReference (new A());</li><li>如果仅有软引用该对象时，首次垃圾回收不会回收该对象，当内存不足时垃圾回收会将该对象回收</li><li>在垃圾回收时需要配合引用队列来释放</li><li>典型例子是反射数据</li></ol><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230128142908493.png" alt="image-20230128142908493"></p><p><strong>弱引用</strong></p><ol><li>例如：WeakReference w &#x3D; new WeakReference (new A());</li><li>只要发生垃圾回收，就会将弱引用的对象回收</li><li>在垃圾回收时需要配合引用队列来释放</li><li>典型例子是ThreadLocalMap中的Entry对象</li></ol><p><strong>虚引用</strong></p><ol><li><p>例如：PhantomReference p &#x3D;  new PhantomReference (new A());</p></li><li><p>必须配合引用队列一起使用，当虚引用引用的对象被回收时，会将虚引用对象入队，由Reference Handler线程释放其关联的外部资源</p></li></ol><h2 id="ThreadLocalMap的弱引用"><a href="#ThreadLocalMap的弱引用" class="headerlink" title="ThreadLocalMap的弱引用"></a>ThreadLocalMap的弱引用</h2><p>在文章的并发篇有写到ThreadLocal的特点，在日常开发中也经常用到ThreadLocal来存储用户的信息并且保证了每个线程中都有自己所属的用户信息，保证了线程安全，但ThreadLocal的ThreadLocalMap中的Entry是弱引用，一旦发生垃圾回收就会将其的key给回收掉，而值value并未被回收，这样就造成了内存泄露，以前是主动调用ThreadLocal类提供的remove方法删除掉value数据来解决，那么以下例子是从另一种方法解决的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  ThreadLocalMap，使用引用队列解决内存泄露问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalMapTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">MyWeakReference</span> <span class="variable">wr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyWeakReference</span>();</span><br><span class="line">        <span class="comment">// 存键值new String是引用</span></span><br><span class="line">        wr.put(<span class="number">0</span>,<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>),<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        <span class="comment">// 第二个的数据是强引用</span></span><br><span class="line">        wr.put(<span class="number">1</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        wr.put(<span class="number">2</span>,<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;c&quot;</span>),<span class="string">&quot;hi~~&quot;</span>);</span><br><span class="line">        wr.put(<span class="number">3</span>,<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;d&quot;</span>),<span class="string">&quot;hehehe&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;还未进行垃圾回收的结果：&quot;</span> + wr);</span><br><span class="line">        <span class="comment">// 启用垃圾回收机制</span></span><br><span class="line">        System.gc();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;垃圾回收后的结果：&quot;</span> + wr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用clean方法将值处理掉</span></span><br><span class="line">        wr.clean();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;清除key为null数据后的结果：&quot;</span> + wr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyWeakReference</span> &#123;</span><br><span class="line">        <span class="comment">// 创建引用队列，当若引用被回收是，会放到引用队列中</span></span><br><span class="line">        <span class="keyword">static</span> ReferenceQueue&lt;Object&gt; queue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 创建一个Entry继承弱引用</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;String&gt; &#123;</span><br><span class="line">            String value;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="title function_">Entry</span><span class="params">(String key,String value)</span> &#123;</span><br><span class="line">               <span class="built_in">super</span>(key,queue);</span><br><span class="line">               <span class="built_in">this</span>.value = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 定义一个数组长度为4</span></span><br><span class="line">        Entry[] table = <span class="keyword">new</span> <span class="title class_">Entry</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  该方法的作用是在垃圾回收时，将回收的key对应的value清除掉</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clean</span><span class="params">()</span> &#123;</span><br><span class="line">            Object temp;</span><br><span class="line">            <span class="keyword">while</span> ((temp = queue.poll()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 说明有弱引用的对象被回收，则从该队列中取出对象置为null即可</span></span><br><span class="line">               <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; table.length; i++) &#123;</span><br><span class="line">                   <span class="keyword">if</span>(table[i] == temp) &#123;</span><br><span class="line">                       <span class="comment">// 说明两个是同个对象，且key已经被回收了</span></span><br><span class="line">                       table[i] = <span class="literal">null</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 编写存入数据的方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> index,String key,String value)</span> &#123;</span><br><span class="line">            table[index] = <span class="keyword">new</span> <span class="title class_">Entry</span>(key,value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Entry entry : table) &#123;</span><br><span class="line">                <span class="keyword">if</span> (entry != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">k</span> <span class="operator">=</span> entry.get();</span><br><span class="line">                    <span class="keyword">if</span> (k != <span class="literal">null</span> &amp;&amp; k.equals(key)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> entry.value;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            str.append(<span class="string">&quot;[  &quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (Entry e: table) &#123;</span><br><span class="line">                <span class="keyword">if</span>(e != <span class="literal">null</span>) &#123;</span><br><span class="line">                    str.append(<span class="string">&quot;key:&quot;</span>).append(e.get()).append(<span class="string">&quot; value:&quot;</span>).append(e.value).append(<span class="string">&quot; | &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            str.deleteCharAt(str.lastIndexOf(<span class="string">&quot;|&quot;</span>));</span><br><span class="line">            str.append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> str.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230128160434391.png" alt="image-20230128160434391"></p><h1 id="框架篇"><a href="#框架篇" class="headerlink" title="框架篇"></a>框架篇</h1><h2 id="Refresh的工作流程"><a href="#Refresh的工作流程" class="headerlink" title="Refresh的工作流程"></a>Refresh的工作流程</h2><p>概述：本篇文章是针对spring的加载过程的核心方法refresh各个功能进行梳理，refresh方法是初始化ioc容器的核心方法，<strong>Spring</strong>容器创建之后，会调用它的refresh<strong>方法刷新</strong>Spring应用的上下文。</p><p><strong>Refresh方法下的其它12个方法的名称如下</strong></p><ol><li><p>prepareRefresh（刷新前的准备工作）</p></li><li><p>prepareBeanFactory（Bean工厂的准备）</p></li><li><p>obtainFreshBeanFactory（获得新Bean工厂）</p></li><li><p>postProcessBeanFactory（处理后的Bean工厂）</p></li><li><p>invokeBeanFactoryPostProcessors（执行BeanFactory后置处理器）</p></li><li><p>registerBeanPostProcessors（注册bean后置处理器）</p></li><li><p>initMessageSource（初始化信息资源、国际化）</p></li><li><p>initApplicationEventMulticaster（初始化app事件发布器）</p></li><li><p>onRefresh（空方法，留给子类扩展，在容器刷新时重写可以进行一些操作）</p></li><li><p>registerListeners（注册监听器，接收来自app事件发布器发布的事件）</p></li><li><p>finishBeanFactoryInitialization（完成bean工厂的初始化）</p></li><li><p>finishRefresh（完成bean创建和初始化过程，通知生命周期处理器 lifecycleProcessor 刷新过程，同时发出 ContextRefreshEvent 通知。）</p></li></ol><h3 id="prepareRefresh"><a href="#prepareRefresh" class="headerlink" title="prepareRefresh"></a>prepareRefresh</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">prepareRefresh</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//记录时间</span></span><br><span class="line">    <span class="built_in">this</span>.startupDate = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">//设置当前容器未关闭</span></span><br><span class="line">    <span class="built_in">this</span>.closed.set(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">//设置当前容器已激活</span></span><br><span class="line">    <span class="built_in">this</span>.active.set(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.logger.isInfoEnabled()) &#123;</span><br><span class="line">    <span class="comment">//打印容器刷新日志</span></span><br><span class="line">        <span class="built_in">this</span>.logger.info(<span class="string">&quot;Refreshing &quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//初始化一下属性(该方法默认是空的,是提供给子类来实现的,</span></span><br><span class="line"><span class="comment">//假设我们有些工作需要在初始化bean以前就要加载设置等,可以通过重写这个方法来完成)</span></span><br><span class="line">    <span class="built_in">this</span>.initPropertySources();</span><br><span class="line">    <span class="comment">//校验设置的属性是否合法</span></span><br><span class="line">    <span class="built_in">this</span>.getEnvironment().validateRequiredProperties();</span><br><span class="line">    <span class="comment">//初始化一个集合属性,提供用来保存后面创建的事件,如果有事件发生会放入这个集合中</span></span><br><span class="line">    <span class="built_in">this</span>.earlyApplicationEvents = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="obtainFreshBeanFactory（获取Bean工厂）"><a href="#obtainFreshBeanFactory（获取Bean工厂）" class="headerlink" title="obtainFreshBeanFactory（获取Bean工厂）"></a>obtainFreshBeanFactory（获取Bean工厂）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title function_">obtainFreshBeanFactory</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//刷新bean工厂,创建一个 DefaultListableBeanFactory类型的 bean工厂</span></span><br><span class="line"><span class="comment">//赋值给 beanFactory 属性,对创建的这个 beanFactory 设置一个序列号</span></span><br><span class="line">        <span class="built_in">this</span>.refreshBeanFactory();</span><br><span class="line">        <span class="comment">//获取beanFactory,就上将上一步设置好序列号的的beanFactory返回回来</span></span><br><span class="line">        <span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="built_in">this</span>.getBeanFactory();</span><br><span class="line">        <span class="comment">//打印日志</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.logger.debug(<span class="string">&quot;Bean factory for &quot;</span> + <span class="built_in">this</span>.getDisplayName() + <span class="string">&quot;: &quot;</span> + beanFactory);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//将创建好的 beanFactory 返回</span></span><br><span class="line">        <span class="keyword">return</span> beanFactory;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ol><li>BeanFactory是负责将Bean创建、依赖注入和初始化工作</li><li>BeanDefinition是Bean的设计蓝图，其规定了Bean的单例多例、依赖关系和创建销毁</li><li>BeanDefinition所获取的Bean来源有xml、配置类、组件扫描等等</li></ol><h3 id="prepareBeanFactory（Bean工厂的准备）"><a href="#prepareBeanFactory（Bean工厂的准备）" class="headerlink" title="prepareBeanFactory（Bean工厂的准备）"></a>prepareBeanFactory（Bean工厂的准备）</h3><p>因为上一步获取Bean工厂是空的工厂，还未进行设置，那么这一步是为了上一步获取的工厂进行预处理设置，由于源码很多，以下的代码是简化的代码，整体思路是跟源码一样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;</span><br><span class="line">   <span class="comment">// 设置类加载器</span></span><br><span class="line">    beanFactory.setBeanClassLoader(<span class="built_in">this</span>.getClassLoader());</span><br><span class="line">   <span class="comment">// 设置语言解析器，例如解析#、&amp;等</span></span><br><span class="line">    beanFactory.setBeanExpressionResolver(<span class="keyword">new</span> <span class="title class_">StandardBeanExpressionResolver</span>(beanFactory.getBeanClassLoader()));</span><br><span class="line">    beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> <span class="title class_">ResourceEditorRegistrar</span>(<span class="built_in">this</span>, <span class="built_in">this</span>.getEnvironment()));</span><br><span class="line">   <span class="comment">// 添加Bean的后置处理器 </span></span><br><span class="line">   beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">ApplicationContextAwareProcessor</span>(<span class="built_in">this</span>));</span><br><span class="line">   <span class="comment">// 忽略自动装配的接口，就是在实现这些接口中不能自动注入</span></span><br><span class="line">    beanFactory.ignoreDependencyInterface(EnvironmentAware.class);</span><br><span class="line">    beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);</span><br><span class="line">   <span class="comment">//注册解析依赖，可以自动解析</span></span><br><span class="line">    beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);</span><br><span class="line">    beanFactory.registerResolvableDependency(ResourceLoader.class, <span class="built_in">this</span>);</span><br><span class="line">   <span class="comment">// 添加一个ApplicationListenerDetector后置处理器</span></span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">ApplicationListenerDetector</span>(<span class="built_in">this</span>));</span><br><span class="line">   <span class="comment">// 根据beanFactory中是否符合以下名称的Bean，根据是否存在进行注册或者添加</span></span><br><span class="line">    <span class="keyword">if</span> (beanFactory.containsBean(<span class="string">&quot;loadTimeWeaver&quot;</span>)) &#123;</span><br><span class="line">        beanFactory.addBeanPostProcessor(<span class="keyword">new</span> <span class="title class_">LoadTimeWeaverAwareProcessor</span>(beanFactory));</span><br><span class="line">        beanFactory.setTempClassLoader(<span class="keyword">new</span> <span class="title class_">ContextTypeMatchClassLoader</span>(beanFactory.getBeanClassLoader()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.containsLocalBean(<span class="string">&quot;environment&quot;</span>)) &#123;</span><br><span class="line">        beanFactory.registerSingleton(<span class="string">&quot;environment&quot;</span>, <span class="built_in">this</span>.getEnvironment());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="postProcessBeanFactory（处理后的Bean工厂）"><a href="#postProcessBeanFactory（处理后的Bean工厂）" class="headerlink" title="postProcessBeanFactory（处理后的Bean工厂）"></a>postProcessBeanFactory（处理后的Bean工厂）</h3><p>这步是空方法，留给子类进行实现的<strong>（体现了设计模式的模板方法）</strong>，是作为BeanFactory的扩展点，以上的步骤可以看成是BeanFactory的创建及预准备阶段。</p><h3 id="invokeBeanFactoryPostProcessors（执行BeanFactory后置处理器）"><a href="#invokeBeanFactoryPostProcessors（执行BeanFactory后置处理器）" class="headerlink" title="invokeBeanFactoryPostProcessors（执行BeanFactory后置处理器）"></a>invokeBeanFactoryPostProcessors（执行BeanFactory后置处理器）</h3><p>在原始的BeanFactory中的功能并不是很多，很多的功能都要靠此方法进行一个扩展，像@Configuration、@Bean 等注解是无法解析的，那需要调用此方法进行一个扩展，执行ConfigurationClassPostProcessor即可解析像@Configuration、@Bean、@lmport、@PropertySource的注解进行解析。</p><h3 id="registerBeanPostProcessors（注册bean后置处理器）"><a href="#registerBeanPostProcessors（注册bean后置处理器）" class="headerlink" title="registerBeanPostProcessors（注册bean后置处理器）"></a>registerBeanPostProcessors（注册bean后置处理器）</h3><p>registerBeanPostProcessors是往BeanFactory中注册后置处理器，例如往BeanFactory中注册一下的后置处理器可以解析对应的注解。</p><ul><li><p>AutowiredAnnotationBeanPostProcessor功能有：解析@Autowired，@Value注解</p></li><li><p>CommonAnnotationBeanPostProcessor功能有：解析@Resource，@PostConstruct，@preDestroy</p></li><li><p>AnnotationAwareAspectJAutoProxyCreator功能有：为符合切点的目标bean自动创建代理</p></li></ul><h2 id="Spring-Bean的生命周期"><a href="#Spring-Bean的生命周期" class="headerlink" title="Spring Bean的生命周期"></a>Spring Bean的生命周期</h2><p><strong>阶段1：处理别名，检查缓存</strong></p><ul><li>先把Bean的别名解析实际的名称</li><li>若要BeanFactory本身需要加&amp;符号进行获取</li><li>singletonObjects（一级缓存）：放单例成品对象</li><li>earlySingletonObjects（二级缓存）：放单例工厂的产品</li><li>singletonFactories（三级缓存）：放单例工厂</li></ul><p><strong>阶段2：处理父子容器</strong></p><ul><li>父子容器中的bean名称可以一样</li><li>优先从子容器中找找bean，找到了直接返回，找不到再继续从父容器找</li></ul><p><strong>阶段3：dependOn</strong></p><ul><li>dependOn可以控制Bean的创建次顺</li></ul><p><strong>阶段4：按照scope创建</strong></p><ul><li>singleton Scope从单例池中获取bean对象，若没有，则新创建bean对象放到单例池中</li><li>prototype Scope表示从不缓存bean对象，每次都创建新的bean</li></ul><p><strong>阶段5-1：创建bean（创建阶段）</strong></p><p>AutowiredAnnotationBeanPostProcessor选择构造</p><ul><li>优先选择带@Autowired注解的构造</li><li>若有唯一的带参构造，也会入选</li></ul><p>采用默认构造</p><ul><li>若上面未找到符合条件的，则会采用默认构造器，即使是私有的构造方法也会进行暴力反射进行构造</li></ul><p><strong>阶段5-2：依赖注入</strong></p><ul><li>注解匹配注入：会根据@Autowired、@Value和@Resource进行注入</li><li>根据bean名字和成员方法名称（就是setXxx后面的Xxx进行匹配）进行注入</li><li>根据bean类型进行注入</li></ul><p><strong>阶段5-3：初始化</strong></p><p><strong>阶段5-4：注册可销毁的bean</strong></p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230129165105425.png" alt="image-20230129165105425"></p><p><strong>阶段6：类型转换</strong></p><ul><li>bean会根据实际类型进行转换</li></ul><p><strong>阶段7：销毁Bean</strong></p><h2 id="Spring事务失效场景"><a href="#Spring事务失效场景" class="headerlink" title="Spring事务失效场景"></a>Spring事务失效场景</h2><p><strong>场景一：</strong>抛出检查异常，导致事务不能回滚</p><ul><li>原因：spring的事务默认回滚非检查异常</li><li>解决：配置@Transactional注解的属性rollbackFor</li></ul><p><strong>场景二：</strong>在业务方法内部使用try-catch处理掉异常</p><ul><li>原因：事务通知只有捉到目标所抛出的异常，才会进行回滚，但你使用try-catch处理异常且并未抛出异常，那么事务通知无法悉知</li><li>解决1：当捕捉到异常时再抛出原异常。</li><li>解决2：在catch代码块中手动设置TransactionStatus.setRollbackOnly();</li></ul><p><strong>场景三：</strong>aop切面顺序导致事务不能正确回滚</p><ul><li>原因：事务切面优先级最低，但如果自定义的切面方法优先级高于事务切面且在此切面中有异常产生而并未抛出导致的</li><li>解决：同场景二的解决方一样，在自定义切面方法中将异常原样抛出</li></ul><p><strong>场景四：</strong>在加上注解@Transactional的方法不是public修饰的</p><ul><li><p>原因：spring创建事务代理、添加事务通知的前提条件方法是public</p></li><li><p>解决：将方法改为public修饰的</p></li></ul><p><strong>场景五：</strong>父子容器导致的事务失效</p><ul><li>原因：子容器的组件扫描范围过大，导致未加事务配置的service被扫描进来</li><li>解决：将所有的bean放在同一个容器中</li></ul><p><strong>场景六：</strong>调用本类的方法导致的事务失效</p><ul><li>原因：本类方法调用不经过代理，因此spring框架无法完成事务增强操作</li><li>解决1：通过@Autowird注入本类的代理对象，通过代理对象调用本类的方法</li><li>解决2：使用AopContext.currentProxy拿到本类的代理对象进行调用</li></ul><p><strong>场景七：</strong>@Transactional注解不能保证业务操作的原子性</p><ul><li>原因：事务的原子性仅涵盖insert update delete select … for update这种的SQL语句中</li></ul><p><strong>场景八：</strong>在并发情况下@Transactional会导致的Synchronized锁失效</p><ul><li>原因：若Synchronized仅能保证目标方法的原子性，加上@Transactional的方法会经过代理增强进行事务的控制，而代理方法并未在Syn范围内。</li><li>解决1：Synchronized锁范围应扩大到代理方法调用</li><li>解决2：使用insert update delete select … for update语句进行数据库CRUD操作</li></ul><h2 id="Spring-MVC的执行流程"><a href="#Spring-MVC的执行流程" class="headerlink" title="Spring MVC的执行流程"></a>Spring MVC的执行流程</h2><p><strong>初始化阶段</strong></p><ol><li>当Web容器第一次用的DispatcherServlet会创建其对象并调用init方法</li><li>init方法内部会创建Spring Web容器，并调用容器的refresh方法</li><li>refresh方法会初始化Spring Mvc的重要组件，例如：HandlerMapping、MultipartResolver、HandlerAdapter等</li><li>容器初始化成功后会将上一步初始化好的重要组件赋值给DispatcherServlet的成员变量，以待后用</li></ol><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230201100033499.png" alt="image-20230201100033499"></p><p><strong>匹配阶段</strong></p><ol><li><p>用户发送的请求统一到达前端控制器 DispatcherServlet</p></li><li><p>DispatcherServlet遍历所有HandlerMapping，找到与路径匹配的处理器</p></li><li><p>将HandlerMethod 连同匹配到的拦截器，生成调用链对象HandlerExecutionChain返回</p></li><li><p>遍历HandlerAdapter 处理器适配器，找到能处理HandlerMethod的适配器对象，开始调用</p></li></ol><p> <strong>执行阶段</strong></p><ol><li>执行拦截器preHandle</li><li>由HandlerAdapter 调用HandlerMethod</li><li>若没有异常，则返回ModeAndView对象，执行拦截器的preHandle方法，解析视图得到view对象，进行视图渲染</li><li>若有异常，进入HandlerExceptionResolve异常处理逻辑</li><li>最后执行拦截器afterCompletion方法</li><li>如果控制器方法标注了@ResponseBody，则在第二步生成json对象，不会进行视图渲染</li></ol><p><strong>整体流程如下</strong></p><ol><li>用户点击某个请求路径，发起一个 HTTP request 请求，该请求会被提交到 DispatcherServlet（前端控制器）；</li><li>由 DispatcherServlet 请求一个或多个 HandlerMapping（处理器映射器），并返回一个执行链（HandlerExecutionChain）。</li><li>DispatcherServlet 将执行链返回的 Handler 信息发送给 HandlerAdapter（处理器适配器）；</li><li>HandlerAdapter 根据 Handler 信息找到并执行相应的 Handler（常称为 Controller）；</li><li>Handler 执行完毕后会返回给 HandlerAdapter 一个 ModelAndView 对象（Spring MVC的底层对象，包括 Model 数据模型和 View 视图信息）；</li><li>HandlerAdapter 接收到 ModelAndView 对象后，将其返回给 DispatcherServlet ；</li><li>DispatcherServlet 接收到 ModelAndView 对象后，会请求 ViewResolver（视图解析器）对视图进行解析；</li><li>ViewResolver 根据 View 信息匹配到相应的视图结果，并返回给 DispatcherServlet；</li><li>DispatcherServlet 接收到具体的 View 视图后，进行视图渲染，将 Model 中的模型数据填充到 View 视图中的 request 域，生成最终的 View（视图）；</li><li>视图负责将结果显示到浏览器（客户端）。</li></ol><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/1139441444-0.png" alt="Spring MVC执行流程"></p><h2 id="SpringBoot的自动装配"><a href="#SpringBoot的自动装配" class="headerlink" title="SpringBoot的自动装配"></a>SpringBoot的自动装配</h2><p>自动装配是由核心注解是@SpringBootApplication，而@SpringBootApplication<strong>主要</strong>是由@SpringBootConfiguration、@ComponentScan、@EnableAutoConfiguration这三个注解组成的，下面就依次介绍这三个注解的作用。</p><p><strong>@SpringBootConfiguration：</strong>该注解内部包含@Configuration，可以作为配置类，同时也标记着SpringBoot的启动入口。</p><p><strong>@ComponentScan：</strong>是用于扫描子包下的或者指定包下的组件，类上有加@Component、@Service、@Mapper等注解都会被其扫描到并加载成Bean。</p><p><strong>@EnableAutoConfiguration：</strong>有以下两个注解组成</p><ul><li>@AutoConfigurationPackage：用来记住扫描的起始包</li><li>@lmport(AutoConfigurationImportSelector.class)：用来加载META-INF&#x2F;spring.factories中的自动配置类</li></ul><h2 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h2><p>概述：Bean的循环依赖有三个发生场景，分别是自己依赖注入自己的Bean实例、两个类互相依赖对方的Bean对象、三个类依赖对方的Bean对象，下图是对以上叙述的场景图</p><p><strong>BeanA和BeanB的相互依赖图如下</strong></p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230204130449677.png" alt="image-20230204130449677"></p><p><strong>自己依赖自己</strong></p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230204131401160.png" alt="image-20230204131401160"></p><p><strong>三个类依赖对方的Bean对象</strong></p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230204132206960.png" alt="image-20230204132206960"></p><p>那么如何解决以上所展示的问题呢？在Spring中使用三级缓存来解决循环依赖的问题，以下是三级缓存的详情介绍。</p><p><em><strong>一级缓存的作用：限制每个Bean实例在BeanFactory中只存在一份（单例）</strong></em></p><p>​下图是一级缓存的原理图：singletonObjects是一级缓存池，getBean的流程是第一次在singletonObjects池中获取目标Bean，获取不到目标Bean则表示池中还未存在该Bean，需要建立目标Bean存入singletonObjects池中，当第二次从singletonObjects池中获取时就会存在目标Bean，就直接返回即可，这样就避免了重复创建相同的Bean了。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230204132758724.png" alt="image-20230204132758724"></p><p><strong>一级缓存不能解决循环依赖问题，下图可以证明这一点</strong></p><p>​A和B相互依赖时，但A第一次从缓存池中获取自身Bean时，由于第一次缓存中未存在A的Bean所以需要创建A的Bean放入缓存池中，当走到a.setB(?)时，需要调用B的getBean()方法，B也是从缓存池中第一次获取自己的Bean，也获取不到需要创建B的Bean放入到缓存池中，当走到b.setA(?)时又调用了A的getBean()方法，由于创建的A还未放入到缓存池中这样就会导致一直重复以上操作，1红线的箭头和2红线箭头就是一个死循环。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230204133755849.png" alt="image-20230204133755849"></p><p><em><strong>二级缓存（在Spring中是三级缓存）作用：解决两个类相互依赖问题</strong></em></p><p>​三级缓存执行流程：其中singtonFactories是三级级缓存池，A先从singletonObjects池中获取目标Bean，第一次获取不到目标则需要创建A的Bean先放入到三级级缓存池（singtonFactories）中，执行到a.setB(?)时进行B的getBean操作，首先将B的Bean放入singtonFactories池中，当Bean的执行到b.setA(?)时是从三级缓存池（singtonFactories）中获取到a，然后就可以执行b的初始化和singletons.put(b)放入一级缓存池中，最后在执行A的a.setB(?)操作也是先从singtonFactories池中获取到b，将b赋值给A就可以执行a.init和singletons.put(a)的操作了。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230204135810407.png" alt="image-20230204135810407"></p><p><strong>二级缓存不能解决循环依赖中有代理的情况</strong></p><p>​执行流程和上面的一样，唯一不同的是b.setA(?)操作是从singtonFactories中获取的原始对象复值给B的，而我们是需要使用代理对象来进行操作的，这样就造成了两个类相互依赖其中的一方会拿不到目标代理对象。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230204141057848.png" alt="image-20230204141057848"></p><p><em><strong>三级缓存（Spring中叫它二级缓存）解决循环依赖中代理创建过晚问题</strong></em></p><p>​其中ealySingletonObjects是二级缓存，执行流流跟以上的流程差不多，关键的点在于singletonFactories池中是存储创建Bean的工厂对象，在工厂对象中会创建出代理对象。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230204142740445.png" alt="image-20230204142740445"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;查找算法&quot;&gt;&lt;a href=&quot;#查找算法&quot; class=&quot;headerlink&quot; title=&quot;查找算法&quot;&gt;&lt;/a&gt;查找算法&lt;/h1&gt;&lt;p&gt;概述：最常见的查找算法有两种，一种是顺序查找，另一种是二分查找。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;顺序查找的特点：适用范围广，可以</summary>
      
    
    
    
    
    <category term="面试" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>线上商城开发</title>
    <link href="http://example.com/2023/01/01/%E5%A4%A7%E5%9E%8B%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"/>
    <id>http://example.com/2023/01/01/%E5%A4%A7%E5%9E%8B%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/</id>
    <published>2023-01-01T07:05:00.000Z</published>
    <updated>2023-02-17T02:59:17.476Z</updated>
    
    <content type="html"><![CDATA[<h1 id="商品服务业务开发"><a href="#商品服务业务开发" class="headerlink" title="商品服务业务开发"></a>商品服务业务开发</h1><h2 id="三级分类查询"><a href="#三级分类查询" class="headerlink" title="三级分类查询"></a>三级分类查询</h2><ol><li>需求：更具数据id查询出所有的商品分类名称并以树型结构返回，原因是每个分类都有自己的子分类，所以需要递归算法进行划分，具体代码如下，根据数据库的字段parent_cid和cat_id进行筛选。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 所有的分类标签</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;CategoryEntity&gt; <span class="title function_">listWithTree</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//1. 查找出所有的分类</span></span><br><span class="line">    List&lt;CategoryEntity&gt; categorys = <span class="built_in">this</span>.getBaseMapper().selectList(<span class="literal">null</span>);</span><br><span class="line">    <span class="comment">//2. 根据ParentCid进行筛选分类</span></span><br><span class="line">    <span class="comment">//2.1 先筛选出父类分类</span></span><br><span class="line">    List&lt;CategoryEntity&gt; parents = categorys.stream().</span><br><span class="line">            filter(category -&gt; category.getParentCid() == <span class="number">0</span>).</span><br><span class="line">            collect(Collectors.toList());</span><br><span class="line">    <span class="comment">//2.2 筛选各父类对应子分类</span></span><br><span class="line">    List&lt;CategoryEntity&gt; level1Menu = parents.stream()</span><br><span class="line">            .map(parent -&gt; &#123;</span><br><span class="line">                <span class="comment">//通过递归的方式查询出每个父类的孩子</span></span><br><span class="line">                parent.setChildren(findChildren(parent,categorys));</span><br><span class="line">                <span class="keyword">return</span> parent;</span><br><span class="line">            &#125;).sorted((m1,m2) -&gt; &#123;</span><br><span class="line">                <span class="comment">//排序，三目运算符是为避免空指针异常</span></span><br><span class="line">                <span class="keyword">return</span> (m1.getSort()==<span class="literal">null</span>?<span class="number">0</span>:m1.getSort()) - (m2.getSort()==<span class="literal">null</span>?<span class="number">0</span>:m2.getSort());</span><br><span class="line">            &#125;)</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    <span class="keyword">return</span> level1Menu;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> List&lt;CategoryEntity&gt; <span class="title function_">findChildren</span><span class="params">(CategoryEntity root,List&lt;CategoryEntity&gt; all)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> all.stream().filter(child -&gt; Objects.equals(root.getCatId(), child.getParentCid()))</span><br><span class="line">            .map(child -&gt; &#123;</span><br><span class="line">                <span class="comment">//给该孩子找自己的孩子分类</span></span><br><span class="line">                child.setChildren(findChildren(child,all));</span><br><span class="line">                <span class="keyword">return</span> child;</span><br><span class="line">            &#125;).sorted((m1,m2) -&gt; &#123;</span><br><span class="line">                <span class="comment">//排序，三目运算符是为避免空指针异常</span></span><br><span class="line">                <span class="keyword">return</span> (m1.getSort()==<span class="literal">null</span>?<span class="number">0</span>:m1.getSort()) - (m2.getSort()==<span class="literal">null</span>?<span class="number">0</span>:m2.getSort());</span><br><span class="line">            &#125;)</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>前后端接口的对接，将后端查询的数据返回给前端。</li></ol><h2 id="品牌管理"><a href="#品牌管理" class="headerlink" title="品牌管理"></a>品牌管理</h2><p>文件上传至oss服务业务</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230106162733180.png" alt="image-20230106162733180"></p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230106162807740.png" alt="image-20230106162807740"></p><p>将图片上传到aliyun的oss中，步骤如下</p><ol><li>导入alicloud的坐标</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- oss上传接口 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alicloud-oss<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>在aliyun中创建一个子用户，用于文件上传</p></li><li><p>配置上传的参数</p></li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="comment"># 配置oss的上传服务</span></span><br><span class="line">    <span class="attr">alicloud:</span></span><br><span class="line">      <span class="attr">access-key:</span> <span class="string">LTAI5tNB6qQmFB8MpUfdf4K7</span> <span class="comment"># 创建子用户时这里都会有显示</span></span><br><span class="line">      <span class="attr">secret-key:</span> <span class="string">UDYX1WJttRuBLKf4qYRWHLxAMNS6xa</span></span><br><span class="line">      <span class="attr">oss:</span></span><br><span class="line">        <span class="attr">endpoint:</span> <span class="string">oss-cn-hangzhou.aliyuncs.com</span> <span class="comment"># 选择一个oss的Bucket名称即可</span></span><br></pre></td></tr></table></figure><ol start="4"><li>编写第三方的模块服务，用户上传图片时会请求该服务模块获取上传到aliyun的资格，获取成功后可以直接上传到aliyun，不用在经过服务器，以上是获取资格的aliyun官方代码对其进行修改即可</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Endpoint以华东1（杭州）为例，其它Region请按实际情况填写。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">endpoint</span> <span class="operator">=</span> <span class="string">&quot;https://oss-cn-hangzhou.aliyuncs.com&quot;</span>;</span><br><span class="line"><span class="comment">// 阿里云账号AccessKey拥有所有API的访问权限，风险很高。强烈建议您创建并使用RAM用户进行API访问或日常运维，请登录RAM控制台创建RAM用户。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">accessKeyId</span> <span class="operator">=</span> <span class="string">&quot;yourAccessKeyId&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">accessKeySecret</span> <span class="operator">=</span> <span class="string">&quot;yourAccessKeySecret&quot;</span>;</span><br><span class="line"><span class="comment">// 填写Bucket名称，例如examplebucket。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">bucketName</span> <span class="operator">=</span> <span class="string">&quot;examplebucket&quot;</span>;</span><br><span class="line"><span class="comment">// 填写Object完整路径，完整路径中不能包含Bucket名称，例如exampledir/exampleobject.txt。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">objectName</span> <span class="operator">=</span> <span class="string">&quot;exampledir/exampleobject.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建OSSClient实例。</span></span><br><span class="line"><span class="type">OSS</span> <span class="variable">ossClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OSSClientBuilder</span>().build(endpoint, accessKeyId, accessKeySecret);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 填写Byte数组。</span></span><br><span class="line">    <span class="type">byte</span>[] content = <span class="string">&quot;Hello OSS, 你好世界&quot;</span>.getBytes();</span><br><span class="line">    <span class="comment">// 创建PutObjectRequest对象。</span></span><br><span class="line">    <span class="type">PutObjectRequest</span> <span class="variable">putObjectRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PutObjectRequest</span>(bucketName, objectName, <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(content));</span><br><span class="line">    <span class="comment">// 设置该属性可以返回response。如果不设置，则返回的response为空。</span></span><br><span class="line">    putObjectRequest.setProcess(<span class="string">&quot;true&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建PutObject请求。</span></span><br><span class="line">    <span class="type">PutObjectResult</span> <span class="variable">result</span> <span class="operator">=</span> ossClient.putObject(putObjectRequest);</span><br><span class="line">    <span class="comment">// 如果上传成功，则返回200。</span></span><br><span class="line">    System.out.println(result.getResponse().getStatusCode());</span><br><span class="line">&#125; <span class="keyword">catch</span> (OSSException oe) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Caught an OSSException, which means your request made it to OSS, &quot;</span></span><br><span class="line">            + <span class="string">&quot;but was rejected with an error response for some reason.&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;Error Message:&quot;</span> + oe.getErrorMessage());</span><br><span class="line">    System.out.println(<span class="string">&quot;Error Code:&quot;</span> + oe.getErrorCode());</span><br><span class="line">    System.out.println(<span class="string">&quot;Request ID:&quot;</span> + oe.getRequestId());</span><br><span class="line">    System.out.println(<span class="string">&quot;Host ID:&quot;</span> + oe.getHostId());</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClientException ce) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Caught an ClientException, which means the client encountered &quot;</span></span><br><span class="line">            + <span class="string">&quot;a serious internal problem while trying to communicate with OSS, &quot;</span></span><br><span class="line">            + <span class="string">&quot;such as not being able to access the network.&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;Error Message:&quot;</span> + ce.getMessage());</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ossClient != <span class="literal">null</span>) &#123;</span><br><span class="line">        ossClient.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SKU-amp-SPU的属性分组"><a href="#SKU-amp-SPU的属性分组" class="headerlink" title="SKU&amp;SPU的属性分组"></a>SKU&amp;SPU的属性分组</h2><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230108115618524.png" alt="image-20230108115618524"></p><h2 id="商品管理–SKU检索"><a href="#商品管理–SKU检索" class="headerlink" title="商品管理–SKU检索"></a>商品管理–SKU检索</h2><h2 id="仓储管理"><a href="#仓储管理" class="headerlink" title="仓储管理"></a>仓储管理</h2><p><strong>合并采购单业务流程</strong></p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230114162049536.png" alt="image-20230114162049536"></p><p><strong>采购单领取业务开发</strong></p><p>采购单通常有5种状态分别是：创建、已分配、已领取、已完成、有异常。而领取采购单只能是从创建、已分配这两种状态中是可以领取的，其它状态是不可被领取的。所以在业务中需要将其它状态的采购单给过滤掉。</p><h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><h2 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h2><p>官方英文：[Elasticsearch Guide <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html">8.6] | Elastic</a></p><p>官方中文：<a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/foreword_id.html">序言 | Elasticsearch: 权威指南 | Elastic</a></p><p>ElasticSearch的基本概念：</p><ol><li>Index（索引）：用于存储表，相当于Mysql中的Database</li><li>Type（类型）：相当于Mysql中的Table，用于存储数据</li><li>Document（文档）：某个Type下的一个数据，是以Json格式存贮的，相当于Mysql中的Table下的数据</li></ol><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20230117125025796.png" alt="image-20230117125025796"></p><p>ElasticSearch的强大搜索功能是基于倒排索引机制的。</p><p><strong>使用docker下载ElasticSearch的镜像命令</strong></p><ol><li>docker pull elasticsearch:版本号  &gt;&gt;  用于存储和检索数据</li><li>docker pull kibana:版本号 &gt;&gt; 可视化界面</li></ol><p><strong>创建一个docker运行镜像</strong></p><ol><li>自行创建两个挂载文件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p 文件目录/文件名称</span><br><span class="line">mkdir -p /root/mydata/elasticsearch/data </span><br><span class="line">mkdir -p /root/mydata/elasticsearch/config</span><br></pre></td></tr></table></figure><ol start="2"><li>做好一个小配置</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo echo &quot;http.host: 0.0.0.0&quot; &gt;&gt; /mydata/elasticsearch/config/elasticsearch.yml</span><br></pre></td></tr></table></figure><ol start="3"><li>提升挂载文件的权限</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod -R 777 /root/mydata/elasticsearch</span><br></pre></td></tr></table></figure><ol start="4"><li>使用docker的运行命令</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run --name elasticsearch -p 9200:9200 -p 9300:9300 \</span><br><span class="line">-e discovery.type=&quot;single-node&quot; \</span><br><span class="line">-e ES_JAVA_OPTS=&quot;-Xms64m -Xmx128m&quot; \</span><br><span class="line">-v /root/mydata/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml \</span><br><span class="line">-v /root/mydata/elasticsearch/data:/usr/share/elasticsearch/data \</span><br><span class="line">-v /root/mydata/elasticsearch/plugins:/usr/share/elasticsearch/plugins \</span><br><span class="line">-d elasticsearch:7.4.2</span><br></pre></td></tr></table></figure><p><strong>运行可视化界面Kibana</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name kibana -e ELASTICSEARCH_HOSTS=http://192.168.177.130:9200 -p 5601:5601 -d kibana:7.4.2</span><br></pre></td></tr></table></figure><h3 id="初步检索"><a href="#初步检索" class="headerlink" title="初步检索"></a>初步检索</h3><p><strong>查看_cat</strong></p><p>利用postman发送http请求即可对其检索</p><ol><li><p><a href="http://192.168.177.130:9200/_cat/nodes%EF%BC%9A%E6%9F%A5%E7%9C%8B%E6%89%80%E6%9C%89%E8%8A%82%E7%82%B9GET">http://192.168.177.130:9200/_cat/nodes：查看所有节点GET</a></p></li><li><p><a href="http://192.168.177.130:9200/_cat/health%EF%BC%9A%E6%9F%A5%E7%9C%8Bes%E5%81%A5%E5%BA%B7%E7%8A%B6%E5%86%B5GET">http://192.168.177.130:9200/_cat/health：查看es健康状况GET</a></p></li><li><p><a href="http://192.168.177.130:9200/_cat/master%EF%BC%9A%E6%9F%A5%E7%9C%8B%E4%B8%BB%E8%8A%82%E7%82%B9GET">http://192.168.177.130:9200/_cat/master：查看主节点GET</a></p></li><li><p><a href="http://192.168.177.130:9200/_cat/indices%EF%BC%9A%E6%9F%A5%E7%9C%8B%E6%89%80%E6%9C%89%E7%B4%A2%E5%BC%95GET">http://192.168.177.130:9200/_cat/indices：查看所有索引GET</a></p></li></ol><p><strong>新增操作</strong></p><p>REST_API的格式：<a href="http://192.168.177.130:9200/index%E5%90%8D%E7%A7%B0/type%E5%90%8D%E7%A7%B0/ID">http://192.168.177.130:9200/index名称/type名称/ID</a></p><ul><li>Post请求：指定ID，若存在该数据则修改操作，否则是新增操作，不指定ID，则都是新增操作</li><li>Put请求：必须指定ID，否则会保错，一般是用于修改操作</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;商品服务业务开发&quot;&gt;&lt;a href=&quot;#商品服务业务开发&quot; class=&quot;headerlink&quot; title=&quot;商品服务业务开发&quot;&gt;&lt;/a&gt;商品服务业务开发&lt;/h1&gt;&lt;h2 id=&quot;三级分类查询&quot;&gt;&lt;a href=&quot;#三级分类查询&quot; class=&quot;headerli</summary>
      
    
    
    
    
    <category term="springcloud" scheme="http://example.com/tags/springcloud/"/>
    
  </entry>
  
  <entry>
    <title>java反射机制</title>
    <link href="http://example.com/2022/12/16/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
    <id>http://example.com/2022/12/16/java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</id>
    <published>2022-12-15T16:00:00.000Z</published>
    <updated>2022-12-17T08:54:32.540Z</updated>
    
    <content type="html"><![CDATA[<p>概述：反射是jvm中非常重要的机制，在spring系列所有的框架中底层都有涉及到反射机制，若java没有反射的话，那么也就没有如今的spring系列的框架，而且反射可以实现在不修改源码情况下来控制程序，符合了设计模式中的ocp原则（开闭原则），同时也是实现动态代理的前提。</p><p><strong>传统方式创建对象VS反射机制创建对象</strong> </p><p>在java中传统的创建对象是new 类()，而反射中是从堆中取出Class对象并通过Class来反射到具体的类中，对具体的类成员方法、成员属性、成员变量等类中的所有成员进行创建、调用等操作。单单看文字很难理解，以下是反射的原理图（来自B站韩孙平的反射讲解）。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221216211655077.png" alt="image-20221216211655077"></p><p>对上图的理解：java程序有三个阶段，第一是编译阶段，在这一阶段是通过jvm虚拟机进行java代码进行编译，形成了class的字节码文件，在jvm中在通过ClassLoader（类加载器）将class的字节码文件读取到第二阶段（加载阶段）并在堆中创建Class对象，在运行阶段是可以通过new 类() 方式从堆中将Class对象创建出来，便可以对此类的成员进行操作，而反射的方式创建对象并不是如此，反射是通过具体的对象去获取具体类的结构，然后再去进行操作。</p><p><strong>代码演示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反射演示过程--&gt;传统方式创建对象VS反射机制创建对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> mysticBoy</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * 反射常用的API有：</span></span><br><span class="line"><span class="comment"> *      java.lang.Class:代表一个类,Class对象表示某个类加载后在堆T</span></span><br><span class="line"><span class="comment"> *      java.lang.reflect.Method:代表类的方法,Method对象表示某个类的方法</span></span><br><span class="line"><span class="comment"> *      java.lang.reflect.Field:代表类的成员变量, Field对象表示某个类的成员变量</span></span><br><span class="line"><span class="comment"> *      java.lang.reflect.Constructor:代表类的构造方法, Constructor对象表示构造器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectionTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException, InstantiationException &#123;</span><br><span class="line">        <span class="comment">//方式一：传统的方式调用Dog类中的成员方法</span></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        dog.hi();</span><br><span class="line">        <span class="comment">//需求：现在我需要根据配置文件去操作Dog中的成员，该如何做？</span></span><br><span class="line">        <span class="comment">//1. 用传统的方法是否可行?</span></span><br><span class="line">        <span class="comment">//(1) 首先需要从配置文件中获取到信息，可以使用Properties类获取</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="comment">//(2) 通过字符输入流读取文件并加载出信息</span></span><br><span class="line">        properties.load(Files.newInputStream(Paths.get(<span class="string">&quot;c_reflection\\profile\\reflection.properties&quot;</span>)));</span><br><span class="line">        <span class="comment">//(3) 获取出类具体和具体的方法</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">allPath</span> <span class="operator">=</span> (String) properties.get(<span class="string">&quot;allPath&quot;</span>); <span class="comment">//c_reflection.Dog 类的引用路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> (String) properties.get(<span class="string">&quot;methodName&quot;</span>);</span><br><span class="line">        <span class="comment">//(4) 现需要调用方hi方法，那么需要先创建对象，那要如何创建呢？</span></span><br><span class="line">        <span class="comment">//new allPath()这样创建是不行的，因为allPath是一个字符串，无法创建对象，故传统的方式是不能满足此需求的</span></span><br><span class="line">        System.out.println(<span class="string">&quot;==========反射机制===========&quot;</span>);</span><br><span class="line">        <span class="comment">//方式二：通过反射创建对象</span></span><br><span class="line">        <span class="comment">//1. 从配置文件读取的类</span></span><br><span class="line">        Class&lt;?&gt; cls = Class.forName(allPath);</span><br><span class="line">        <span class="comment">//2. 实例化类</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> cls.newInstance();</span><br><span class="line">        <span class="comment">//3. 从Class类对象中获取出方法</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> cls.getMethod(methodName);</span><br><span class="line">        <span class="comment">//4. 调用方法 反射的形式：对象.实体类</span></span><br><span class="line">        method.invoke(instance);</span><br><span class="line">       <span class="comment">//  获取成员变量</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> cls.getField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        <span class="comment">// 通过字段获取变量</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">i</span> <span class="operator">=</span> field.get(instance);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        <span class="comment">// 获取构造器</span></span><br><span class="line">        Constructor&lt;?&gt; cts = cls.getConstructor();</span><br><span class="line">        System.out.println(cts);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;哈士奇&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span> &#123;System.out.println(<span class="string">&quot;hello &quot;</span> + name);&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span> &#123;System.out.println(<span class="string">&quot;汪汪汪&quot;</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>反射的优缺点</strong></p><ul><li><p>优点：可以动态的创建和使用对象(也是框架底层核心)，使用灵活，没有反射机制，框架技术就失去底层支撑。</p></li><li><p>缺点：使用反射基本是解释执行，对执行速度有影响.</p></li></ul><p><strong>Class类的特点</strong></p><ul><li>Class也是类，因此也继承Object类</li><li>Class类对象不是new出来的，而是系统创建的</li><li>对于某个类的Class类对象，在内存中只有一份，因为类只加载一次</li><li>每个类的实例都会记得自己是由哪个Class 实例所生成</li><li>通过Class可以完整地得到一个类的完整结构,通过一系列API</li><li>Class对象是存放在堆的</li></ul><p><strong>静态加载VS动态加载</strong></p><p>反射机制是java实现动态语言的关键，也就是通过反射实现类动态加载</p><ol><li>静态加载：编译时加载相关的类，如果没有则报错，依赖性太强</li><li>动态加载：运行时加载需要的类，如果运行时不用该类，即使不存在该类，则不报错，降低了依赖性</li></ol><p><strong>类加载时机</strong></p><ol><li>当创建对象时（静态加载）</li><li>当子类被加载时，父类也加载</li><li>调用类中的静态成员时</li><li>通过反射（动态加载）</li></ol><p><strong>类加载过程图</strong></p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221217161305473.png" alt="image-20221217161305473"></p><p><strong>类加载三阶段的具体流程</strong></p><p>在加载过程和连接过程是由jvm机控制的，而初始化是可以由程序员进行控制，注意这里的初始化是类中的初始静态代码块，而不是创建一个对象。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221217161441058.png" alt="image-20221217161441058"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;概述：反射是jvm中非常重要的机制，在spring系列所有的框架中底层都有涉及到反射机制，若java没有反射的话，那么也就没有如今的spring系列的框架，而且反射可以实现在不修改源码情况下来控制程序，符合了设计模式中的ocp原则（开闭原则），同时也是实现动态代理的前提。&lt;</summary>
      
    
    
    
    
    <category term="java基础" scheme="http://example.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>微服务</title>
    <link href="http://example.com/2022/12/02/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    <id>http://example.com/2022/12/02/%E5%BE%AE%E6%9C%8D%E5%8A%A1/</id>
    <published>2022-12-02T04:31:48.000Z</published>
    <updated>2023-02-06T05:13:32.209Z</updated>
    
    <content type="html"><![CDATA[<h1 id="认识微服务"><a href="#认识微服务" class="headerlink" title="认识微服务"></a>认识微服务</h1><ul><li><p>单体架构：将业务的所有功能集中在一个项目中开发，打成一个包部署。</p><ul><li>优点：架构简单、部署成本低</li><li>缺点：耦合度高、当有一个模块出现BUG，可能会导致整个系统崩溃。</li></ul></li><li><p>分布式架构：根据业务功能对系统进行拆分，每个业务模块作为独立项目开发，称为一个服务。</p><ul><li>优点：降低耦合度、有利于服务的升级和扩展。</li><li>缺点：研发成本高</li></ul></li><li><p>微服务是一种经过良好架构设计的分布式架构方案，微服务架构特征</p><ul><li>单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责，避免重复业务开友</li><li>面向服务：微服务对外暴露业务接口</li><li>自治：团队独立、技术独立、数据独立、部署独立</li><li>隔离性强：服务调用做好隔离、容错、降级、避免出现级联问题</li></ul></li></ul><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221204133958073.png" alt="image-20221204133958073"></p><h2 id="微服务结构"><a href="#微服务结构" class="headerlink" title="微服务结构"></a>微服务结构</h2><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221204134435078.png" alt="image-20221204134435078"></p><h2 id="微服务技术对比"><a href="#微服务技术对比" class="headerlink" title="微服务技术对比"></a>微服务技术对比</h2><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221204135049357.png" alt="image-20221204135049357"></p><h1 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h1><ul><li>SpringCloud集成了各种微服务功能组件，并基于SpringBoot实现了这些组件的自动装配，从而提供了良好的开箱即用体验:</li></ul><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221204135842628.png" alt="image-20221204135842628"></p><h1 id="服务拆分"><a href="#服务拆分" class="headerlink" title="服务拆分"></a>服务拆分</h1><ol><li>不同微服务，不要重复开发相同业务</li><li>微服务数据独立，不要访问其它微服务的数据库</li><li>微服务可以将自己的业务暴露为接口，供其它微服务调用</li></ol><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221204140506901.png" alt="image-20221204140506901"></p><h2 id="微服务远程调用"><a href="#微服务远程调用" class="headerlink" title="微服务远程调用"></a>微服务远程调用</h2><p>概述：在微服务体系架构中，每个业务服务都是一个独立的服务模块，每个模块都有属于自己的数据库，所以要联表查询数据是不能像单体项目一样可以直接进行多表查询，而是要通过每个服务模块暴露出部分接口供给其它服务模块调用。</p><ul><li><p>远程调用的实质：就是给目标服务模块发送一个HTTP的请求，让目标服务进行一个响应并返回数据即可。</p></li><li><p>远程调用的API是RestTemplate，该API应交给Spring的IOC容器管理。</p></li><li><p>服务调用关系（两者身份是相对的）</p><ul><li>服务提供者：暴露接口给其它服务调用。</li><li>服务消费者：调用来自其它服务模块的提供的接口。</li></ul></li></ul><h1 id="Eureka注册中心"><a href="#Eureka注册中心" class="headerlink" title="Eureka注册中心"></a>Eureka注册中心</h1><p>服务调用出现的问题</p><ul><li>服务消费者该如何获取服务提供者的地址信息？</li><li>如果有多个服务提供者，消费者该如何选择？</li><li>消费者如何得知服务提供者的健康状态？</li></ul><p>Eureka介绍：主要作用是记录每个服务提供者的地址信息</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221204153807427.png" alt="image-20221204153807427"></p><p>Eureka架构</p><ol><li><p>EurekaService：服务端，注册中心——专门记录服务信息和服务接口的健康监测。</p></li><li><p>EurekaClient：客户端</p><ul><li>服务提供者：注册服务提供者的信息，并每隔30秒会进行一个监测，保证接口是否可以正常供应</li><li>服务消费者：根据服务名称从EurekaServer拉取服务列表，基于服务列表做负载均衡，选中一个微服务后发起远程调用</li></ul></li></ol><h2 id="搭建EurekaServer"><a href="#搭建EurekaServer" class="headerlink" title="搭建EurekaServer"></a>搭建EurekaServer</h2><p>搭建EurekaServer服务步骤如下</p><ol><li>创建项目，引入spring-cloud-starter-netflix-eureka-server的依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>编写启动类，添加@EnableEurekaServer注解</li><li>添加application.yml文件，编写下面的配置</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8888</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eurekaServer</span></span><br><span class="line"><span class="comment"># 注册信息</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:8888/eureka</span></span><br></pre></td></tr></table></figure><h2 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h2><ol><li>在目标项目中引入坐标spring-cloud-starter-netflix-eureka-client</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--  引入eureka的客户端--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>在application.yml的配置参数如下</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置服务的名称</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">userService</span></span><br><span class="line"><span class="comment"># 注册信息</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:8888/eureka</span></span><br></pre></td></tr></table></figure><h2 id="使用Eureka实现负载均衡"><a href="#使用Eureka实现负载均衡" class="headerlink" title="使用Eureka实现负载均衡"></a>使用Eureka实现负载均衡</h2><ol><li>在RestTemplate加载Bean的方法上加注解@LoadBalanced即可实现。</li><li>在RestTemplate远程调用时可以使用已在eureka服务器中注册的服务名称进行调用，RestTemplate会在eureka服务发现指定的端口并进行远程连接。</li></ol><h1 id="Ribbon负载均衡原理"><a href="#Ribbon负载均衡原理" class="headerlink" title="Ribbon负载均衡原理"></a>Ribbon负载均衡原理</h1><p>​在order-service服务发出了一个请求，若在order-service中加载Bean的RestTemplate方法上有@LoadBalanced时，其发出的请求会被LoadBalancerInterceptor类（负载均衡拦截器）拦截下来，然后到enreka-server（服务中心）根据别名（userservice）查找已注册的服务列表，若存在该服务名称则就返回相关的服务列表到Ribbon中，该返回的列表是真实的ip地址号，在Ribbon中进一步的进行负载均衡的算法。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221210152342658.png" alt="image-20221210152342658"></p><ul><li>Ribbon内部结构图</li></ul><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221210153437529.png" alt="image-20221210153437529"></p><h2 id="负载均衡的策略"><a href="#负载均衡的策略" class="headerlink" title="负载均衡的策略"></a>负载均衡的策略</h2><p>下图是Ribbon负载均衡策略继承关系</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221210153849904.png" alt="image-20221210153849904"></p><p><strong>每个类的含义如下图</strong></p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221210154712521.png" alt="image-20221210154712521"></p><p>调整负载均衡的规则，默认是轮询的方式作为负载均衡</p><ul><li>将需要目标策略加载成Bean即可（作用范围：全局）</li><li>在application.yml配置文件中配置如下参数即可（作用范围：局部，在哪个微服务中配置就作用在其微服务）</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 微服务名称</span></span><br><span class="line"><span class="attr">userService:</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.RandomRule</span> <span class="comment">#负载均衡规则</span></span><br></pre></td></tr></table></figure><p>Ribbon默认是采用懒加载，即第一次访问时才会去创建LoadBalanceClient，请求时间会很长。而饥饿加载则会在项目启动时创建，降低第一次访问的耗时，通过下面配置开启饥饿加载。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="attr">eager-load:</span></span><br><span class="line">    <span class="attr">clients:</span> <span class="string">userService</span>  <span class="comment">#指定对哪个服务进行饥饿加载</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment">#开启饥饿加载</span></span><br></pre></td></tr></table></figure><h1 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h1><p>概述：Nacos是阿里巴巴的产品，现在是SpringCloud中的一个组件。相比Eureka功能更加丰富，在国内受欢迎程度较高。安装自行百度</p><p>在Windows系统下启动Nacos命令：startup.cmd -m standalone</p><p>整合Nacos步骤如下</p><ol><li>在父工程引入所有的阿里巴巴的版本控制</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>在目标服务包下引入nacos的客户端</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- nacos客户端依赖包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>在目标服务包下修改配置</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment">#配置nacos服务器的地址</span></span><br></pre></td></tr></table></figure><ol start="4"><li>以上配置完成后，不用加任何的代码即可实现微服务间的请求负载均衡。</li></ol><h2 id="nacos的设置"><a href="#nacos的设置" class="headerlink" title="nacos的设置"></a>nacos的设置</h2><p>分级存储模型：分级模型就是将同种实例服务分布在不同地区的服务器中，避免一个服务器挂掉了使该实例服务不能提供服务的情况发生，所以一个服务实例通常会部署在不同的服务器上，每个地区的服务实例会进行一个集群，当本地的服务实例不能用时，会搜索其它地区的服务实例。</p><ol><li>集群配置</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"> <span class="attr">naocs:</span></span><br><span class="line"><span class="attr">discovery:</span></span><br><span class="line">   <span class="attr">cluster-name:</span> <span class="string">HZ</span> <span class="comment">#配置集群名称，以地名命名</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>NaocsRule负载均衡策略</p><ol><li>优先选择同集群服务实例列表</li><li>本地集群找不到提供者，才去其它集群寻找，并且会报警告</li><li>确定了可用实例列表后，再采用随机负载均衡挑选实例</li></ol></li><li><p>Naocs的实例权重设置</p><ol><li>Nacos控制台可以设置实例的权重值0~1之间</li><li>同集群内的多个实例，权重越高被访问的频率越高</li><li>权重设置为0则完全不会被访问</li></ol></li><li><p>Naocs的环境隔离</p><ol><li>namespace用来做环境隔离</li><li>每个namespace都有唯一id</li><li>不同namespace下的服务不可见（不同环境中的服务访问的话会报错，No instances available for userService）</li></ol></li></ol><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>nacos与eureka的整体原理差不多，服务提供者都要在注册中心进行一个注册，每隔一段时间注册中心都会进行一次服务的健康检测来检测一下服务提供者提供的服务是否可用，但nacos比eureka功能更完善，<strong>nacos和eureka的细节区别：</strong>nacos中存在临时实例和非临时实例，临时实例是存在服务列表缓存中，而服务消费者先从服务列表查找是否有自己需要的服务（读取缓存，速度更快）。服务消费者会定时从注册中心拉取服务，从而更新服务列表缓存，临时服务需要主动将自己的健康情况推送到注册中心中，若注册中心一定时间未检测到临时实例服务的健康情况，注册中心会将其服务去除掉，但非临时实例是相反的，注册中心会主动的询问非临时实例是否处于健康状态，就算是非健康状态注册中心也不会将其剔除，那以上的说法会产生一个新的问题，那就是当注册中心有一个临时实例挂掉了，但服务列表缓存未及时的更新，那么针对该问题，当有一个临时实例或非临时实例挂掉了，注册中心会主动将更新好的服务列表发送给服务消费者。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221211133647023.png" alt="image-20221211133647023"></p><h2 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h2><p>当nacos注册中心若存在很多的微服务，若需要进行系统升级，那每个微服务的配置都给重新配置，这样就会变得非常的麻烦，nacos提供了配置管理服务将所有的微服务同一配置管理，只要在配置管理修改配置参数，各个微服务再进行读取配置管理中的配置参数即可完成修改。那么如何实现呢？</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221211141202582.png" alt="image-20221211141202582"></p><p><strong>配置管理的实现步骤如下</strong></p><ol><li>第一步需要在nocas注册中心新建一个配置管理文件，步骤如下（最后点击发布即可）</li></ol><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221211143706538.png" alt="image-20221211143706538"></p><p>文件类型选择yaml类型</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221211144015549.png" alt="image-20221211144015549"></p><ol start="2"><li>如何让微服务读取到nacos中的配置文件呢？首先在目标服务实例中引入nacos的配置管理坐标</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入nacos的配置管理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其次在resource目录下新建一个bootsrap.yml文件，注意，该文件名称一定是这样命名的，因为bootsrap.yml配置文件加载的优先级比application.yml高，然后再文件中加上以下参数即可，当配置完成后可以用@Value注解读取配置文件中的信息。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">userService</span> <span class="comment">#服务名称</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span> <span class="comment"># 配置环境，这里的环境一定要与你在nacos注册中心文件命名的那个环境一样</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment"># 配置nacos的注册中心地址</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment"># 文件的后缀名</span></span><br></pre></td></tr></table></figure><p>从nacos中获取配置文件的信息整体流程如下</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221211150233950.png" alt="image-20221211150233950"></p><h3 id="nacos的配置自动更新（热更新）"><a href="#nacos的配置自动更新（热更新）" class="headerlink" title="nacos的配置自动更新（热更新）"></a>nacos的配置自动更新（热更新）</h3><p>概述：自动更新是不需要重启服务器就可以完成配置文件信息的更新</p><ul><li>方式一：使用注解@RefreshScope配合@value使用即可完成。@RefreshScope放在类上</li><li>方式二：使用注解@ConfigurationProperties完成自动更新。</li></ul><h3 id="nacos的文件加载优先级"><a href="#nacos的文件加载优先级" class="headerlink" title="nacos的文件加载优先级"></a>nacos的文件加载优先级</h3><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221211153109271.png" alt="image-20221211153109271"></p><h1 id="HTTP客户端Feign"><a href="#HTTP客户端Feign" class="headerlink" title="HTTP客户端Feign"></a>HTTP客户端Feign</h1><p>RestTemplate远程调用的问题：</p><ol><li>代码可读性差，编程体验不统一</li><li>参数复杂URL难以维护</li></ol><p>Feign的介绍：Feign是一个声明式的http客户端，其内部已经整合了ribbon，不用自己配置即可做到负载均衡，其作用就是帮助我们优雅的实现http请求的发送，解决上面提到的问题。官方地址: <a href="https://github.com/OpenFeign/feign">https://github.com/OpenFeign/feign</a></p><p><strong>Feigh的使用步骤如下</strong></p><ol><li>引入依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入fright依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>在启动类上开启feigh客户端驱动@EnableFeignClients</p></li><li><p>定义一个包专门来请求别的微服务模块，并编写接口如下图（注意@FeignClient()参数中不要加&#x2F;）</p></li></ol><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221215140003411.png" alt="image-20221215140003411"></p><ol start="4"><li>在业务层注入客户端的接口，如上的UserClient的bean即可直接调用接口中的方法完成微服务间的调用。</li></ol><p><strong>Fign的自定义配置</strong></p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221215141415617.png" alt="image-20221215141415617"></p><p><strong>Feign的日志配置</strong></p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221215141232182.png" alt="image-20221215141232182"></p><h2 id="Feign的性能优化"><a href="#Feign的性能优化" class="headerlink" title="Feign的性能优化"></a>Feign的性能优化</h2><p>Feign优化分为两个方面，第一Feign的日志级别不要开的太高，最好在BASIC级别即可，在日志这方面只有优化这个，第二在请求连接方面的优化。因为Feign默认的请求调用是不支持连接池的使用，每次都要创建请求和销毁请求，比较消耗性能，可以自己配置Feign的连接池，将请求连接交给连接池管理这样就不用每次请求都要进行创建和销毁，从而提高了性能，步骤如下</p><ol><li>引入依赖（使用HttpClient连接池）</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入fright的httpClient连接池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>修改配置文件，配置参数如下</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">httpclient:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment">#开启连接池的使用</span></span><br><span class="line">    <span class="attr">max-connections-per-route:</span> <span class="number">50</span> <span class="comment">#单个服务接口的最大连接数</span></span><br><span class="line">    <span class="attr">max-connections:</span> <span class="number">200</span> <span class="comment">#最大连接数</span></span><br><span class="line">    <span class="attr">time-to-live:</span> <span class="number">90</span> <span class="comment">#连接存活的时间，若超过90S未使用会自动取消连接</span></span><br></pre></td></tr></table></figure><h2 id="Feign的最佳实践"><a href="#Feign的最佳实践" class="headerlink" title="Feign的最佳实践"></a>Feign的最佳实践</h2><p>概述：Feign的远程调用中，服务消费者接口定义和服务提供者的接口定义必须一致，例如，参数个数等等，这样的用法修改起来比较麻烦，所有提供了以下两种思路</p><ol><li>继承：给消费者的FeignClient和提供者的controller定义统一的父接口作为标准。（耦合度高）</li></ol><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221215145243158.png" alt="image-20221215145243158"></p><ol start="2"><li>抽取：将Feign提供的调用接口抽取成一个微服务模块，然后让这个模块对外提供服务接口，供给服务消费者调用。</li></ol><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221215145213059.png" alt="image-20221215145213059"></p><p><strong>实现Feign的抽取步骤如下</strong></p><ol><li>创建一个新的微服务模块（maven模块）</li><li>将服务提供者和服务消费者所需要的实体类、配置和调用接口放在feign-api的服务模块中</li><li>在服务消费者的模块引入依赖，注意在这一步中需要在@EnableFeignClients中添加一个参数，否则会在Springboot启动时报Bean找不到的错误，该参数是可以让组件扫描到feign-api模块中，从而成功的加载Bean对象，如下</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients(clients = &#123;在feign-api模块中的接口.class&#125;)</span> <span class="comment">//将feign-api的接口加载到此服务模块中</span></span><br></pre></td></tr></table></figure><h1 id="Gateway网关"><a href="#Gateway网关" class="headerlink" title="Gateway网关"></a>Gateway网关</h1><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221215160258517.png" alt="image-20221215160258517"></p><p>在SpringCloud中网关的实现包括两种:</p><ul><li>gateway</li><li>zuul</li></ul><p>Zuul是基于Servlet的实现，属于阻塞式编程。而SpringCloudGateway则是基于Spring5中提供的WebFlux，属于响应式编程的实现，具备更好的性能。</p><h2 id="开发网关的步骤"><a href="#开发网关的步骤" class="headerlink" title="开发网关的步骤"></a>开发网关的步骤</h2><p>先创建一个新的maven模块，引入nacos和注册发现的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注册发现依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 路由 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改配置参数，基本的配置如下</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10011</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment"># nacos地址</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://userService</span> <span class="comment"># 以lb是LoadBalance 负载均衡</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/user/**</span> <span class="comment"># 只要请求路径中有user，则将该请求引导userService服务中</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">order-service</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://orderService</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/order/**</span></span><br></pre></td></tr></table></figure><p>当上面的步骤做完之后即可直接访问网关的路径，网关会给你的请求进行一个引导访问你需要的资源。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221224150013734.png" alt="image-20221224150013734"></p><h2 id="路由过滤器GatewayFilter的配置"><a href="#路由过滤器GatewayFilter的配置" class="headerlink" title="路由过滤器GatewayFilter的配置"></a>路由过滤器GatewayFilter的配置</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10011</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment"># nacos地址</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://userService</span> <span class="comment"># 以lb是LoadBalance 负载均衡</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/user/**</span> <span class="comment"># 只要请求路径中有user，则将该请求引导userService服务中</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">filters:</span></span><br><span class="line">        <span class="comment"># 局部过滤器</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">order-service</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://orderService</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/order/**</span></span><br><span class="line">      <span class="attr">default-filters:</span> <span class="comment"># 默认路由过滤器，会对所有的请求生效，若需要局部，可以在指定的路由下配置</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">AddRequestHeader=name,zhangsan</span></span><br></pre></td></tr></table></figure><h2 id="网关的全局过滤器"><a href="#网关的全局过滤器" class="headerlink" title="网关的全局过滤器"></a>网关的全局过滤器</h2><p>全局过滤器的作用是什么?</p><ol><li>对所有路由都生效的过滤器，并且可以自定义处理逻辑</li></ol><p>实现全局过滤器的步骤?</p><ol><li>实现GlobalFilter接口</li><li>添加@Order注解或实现Ordered接口</li><li>编写处理逻辑</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 请求访问权限过滤器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Order(-1)</span> <span class="comment">//过滤的优先级</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthorizationFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理用户的请求</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exchange：可以获取到用户的请求头或者是响应头进行处理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> chain：用来放行请求的</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> m</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">        <span class="comment">//1. 获取ServerHttpRequest对象</span></span><br><span class="line">        <span class="type">ServerHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> exchange.getRequest();</span><br><span class="line">        <span class="comment">//2. 获取请求头</span></span><br><span class="line">        MultiValueMap&lt;String, String&gt; queryParams = request.getQueryParams();</span><br><span class="line">        <span class="comment">//3. 从请求头中通过键取出值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">authorization</span> <span class="operator">=</span> queryParams.getFirst(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">        <span class="comment">//4. 判断该请求头是否是admin权限的用户</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;admin&quot;</span>.equals(authorization)) &#123;</span><br><span class="line">            <span class="comment">//是，放行</span></span><br><span class="line">            <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置一下状态码</span></span><br><span class="line">        exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">        <span class="comment">//否，拦截</span></span><br><span class="line">        <span class="keyword">return</span> exchange.getResponse().setComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>路由过滤器、defaultFilter、全局过滤器的执行顺序?</p><ul><li><p>order值越小，优先级越高</p></li><li><p>当order值一样时，顺序是defaultFilter最先，然后是局部的路由过滤器，最后是全局过滤器</p></li></ul><h2 id="跨域请求问题"><a href="#跨域请求问题" class="headerlink" title="跨域请求问题"></a>跨域请求问题</h2><p>引起原因：客户端和服务器的域名不同或者是端口号不同导致的，跨域问题是游览器不允许页面对不同的域进行一个ajax的请求，但在服务端中就不存在该问题了。如下图所示是属于跨域请求</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221229162011088.png" alt="image-20221229162011088"></p><p>解决方案：CORS</p><p>只需要在网关下配置如下参数即可解决</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">globalcors:</span> <span class="comment">#全局的跨域处理</span></span><br><span class="line">        <span class="attr">add-to-simple-url-handler-mapping:</span> <span class="literal">true</span> <span class="comment">#解决options请求被拦截问题corsConfigurations:</span></span><br><span class="line">          <span class="string">&#x27;[/**]&#x27;</span><span class="string">:</span></span><br><span class="line">            <span class="attr">allowedOrigins:</span>  <span class="comment">#允许哪些网站的跨域请求</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;http://logalhost:8090&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;http://www.leyou.com&quot;</span></span><br><span class="line">            <span class="attr">allowedMethods:</span> <span class="comment">#允许的跨域ajax的请求方式</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;GET&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;POST&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;DELETE&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;PUT&quot;</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">&quot;OPTIONS&quot;</span></span><br><span class="line">            <span class="attr">allowedHeaders:</span> <span class="string">&quot;*&quot;</span> <span class="comment">#允许在请求中携带的头信息</span></span><br><span class="line">            <span class="attr">allowCredentials:</span> <span class="literal">true</span> <span class="comment">#是否允许携带</span></span><br><span class="line">            <span class="attr">cookiemaxAge:</span> <span class="number">360000</span> <span class="comment">#这次跨域检测的有效期s</span></span><br></pre></td></tr></table></figure><p>还有一种解决方案，添加一个Bean给IOC容器管理即可，让spring框架知道请求可以跨域即可。如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解决跨域请求问题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GulimallCorsWebConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CorsWebFilter <span class="title function_">corsWebFilter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">UrlBasedCorsConfigurationSource</span> <span class="variable">source</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlBasedCorsConfigurationSource</span>();</span><br><span class="line">        <span class="comment">//配置跨域参数</span></span><br><span class="line">        <span class="type">CorsConfiguration</span> <span class="variable">configuration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorsConfiguration</span>();</span><br><span class="line">        configuration.setAllowedHeaders(Collections.singletonList(<span class="string">&quot;*&quot;</span>));</span><br><span class="line">        configuration.setAllowedMethods(Collections.singletonList(<span class="string">&quot;*&quot;</span>));</span><br><span class="line">        configuration.setAllowedOrigins(Collections.singlsetonList(<span class="string">&quot;*&quot;</span>));</span><br><span class="line">        <span class="comment">// 设置同意信任的url请求</span></span><br><span class="line">        configuration.setAllowCredentials(<span class="literal">true</span>);</span><br><span class="line">        source.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>,configuration);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CorsWebFilter</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><p><strong>项目部署问题：</strong>大型项目组件较多，运行环境也较为复杂，依赖关系复杂，容易出现兼容性问题。开发、测试、生产环境有差异</p><p><strong>Docker如何解决依赖兼容的问题？</strong></p><ul><li>Docker会将应用的Libs（函数库)、Deps（依赖)、配置与应用一起打包</li><li>将每个应用放到一个隔离容器去运行，避免互相干扰</li></ul><p>Docker是一个快速交付应用、运行应用技术。可以将程序及其依赖、运行环境一起打包为一个镜像，可以迁移到任意Linux操作系统，运行时利用沙箱机制形成隔离容器，各个应用互不干扰。启动、移除都可以通过一行命令完成，方便快捷</p><h2 id="Docker的架构"><a href="#Docker的架构" class="headerlink" title="Docker的架构"></a>Docker的架构</h2><p>Docker是采用C&#x2F;S的结构的程序，由两部分组成</p><ul><li>服务端(server)：Docker守护进程，负责处理Docker指令，管理镜像、容器等，DockerHup是Docker的服务器</li><li>客户端(client)：通过命令或RestAPI向Docker服务端发送指令。可以在本地或远程向服务端发送指令。</li></ul><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221229163742167.png" alt="image-20221229163742167"></p><h2 id="Docker的安装（Linux版本）"><a href="#Docker的安装（Linux版本）" class="headerlink" title="Docker的安装（Linux版本）"></a>Docker的安装（Linux版本）</h2><p>首先需要CentOS7的虚拟机</p><ol><li>安装yum的工具包，在控制台中输入以下命令即可</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils \</span><br><span class="line">          device-mapper-persistent-data \</span><br><span class="line">          lvm2 --skip-broken</span><br></pre></td></tr></table></figure><ol start="2"><li>更新本地镜像源</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager </span><br><span class="line">--add-repo \</span><br><span class="line">https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line">sed -i &#x27;s/down1oad.docker.com/mirrors.aliyun.com\/docker-ce/g&#x27; /etc/yum.repos.d/docker-ce.repo</span><br><span class="line"></span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure><ol start="3"><li>然后输入命令</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y docker-ce</span><br></pre></td></tr></table></figure><ol start="4"><li>安装完成后启动前需要关闭掉linux的防火墙，否则Docker会启动失败，关闭防火墙的命令如下</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭当前防火墙，但下一次开机会自启防火墙</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">永久关闭</span></span><br><span class="line">systemctl disable firewalld</span><br></pre></td></tr></table></figure><ol start="5"><li>启动Docker服务</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><ol start="6"><li>查看是否启动成功</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">若有版本号出现说明启动成功</span></span><br><span class="line">docker -v </span><br></pre></td></tr></table></figure><ol start="7"><li>因为Docker的服务器在国外，故下载速度很慢，可以配置到国内的服务器上（需要自己到阿里云官网去开通镜像服务）</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">先创建一个目录</span></span><br><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一个json文件</span></span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27; </span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://n0dwemtq.mirror.aliyunce.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启</span></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><h2 id="Docker的基本操作"><a href="#Docker的基本操作" class="headerlink" title="Docker的基本操作"></a>Docker的基本操作</h2><p><strong>镜像相关的命令如图所示</strong></p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221230095046053.png" alt="image-20221230095046053"></p><p>Docker的命令可以在控制台上进行查询通过如下命令即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker --help</span><br><span class="line">docker [具体的命令] --help</span><br></pre></td></tr></table></figure><p><strong>容器的相关命令</strong></p><p>docker exec：进入容器执行命令</p><p>docker logs：查看容器运行日志</p><p>docker ps：查看所有运行的容器及状态</p><p>docker rm：删除指定的容器</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221230101316509.png" alt="image-20221230101316509"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令解读</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker run：创建一个容器并运行</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--name containerName：起一个容器名称</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-p 80:80：端口映射，左是用户机的端口，右是服务器端口</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-d nginx：镜像名称</span></span><br><span class="line">docker run --name containerName -p 80:80 -d nginx</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令解读</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker <span class="built_in">exec</span> :进入容器内部，执行一个命令</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">it:给当前进入的容器创建一个标准输入、输出终端，允许我们与容器交互</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">mn :要进入的容器的名称</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">bash:进入容器后执行的命令，bash是一个linux终端交互命令</span></span><br><span class="line">docker exec -it mn bash</span><br></pre></td></tr></table></figure><p><strong>数据卷的相关命令</strong></p><p>数据卷的存在解决了：不便于修改，数据不可复用，升级维护困难</p><p>数据卷就是和容器内部的文件的映射，当数据卷修改时容器内部的文件也会修改。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker volume [comment]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">comment有如下选择</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">create：创建一个volume</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">inspect：显示一个或多个volume的信息</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ls</span>：列出所有的volume</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">prune：删除未使用的volume</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">rm</span>：删除一个或多个指定的volume</span></span><br></pre></td></tr></table></figure><p><strong>挂载数据卷</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在创建并运行容器时加上-v volumeName: /targetContainerPath即可,当volumeName不存在，会自动创建</span></span><br><span class="line">docker run --name containerName -p 80:80 -v volumeName: /targetContainerPath -d nginx</span><br></pre></td></tr></table></figure><h2 id="自定义镜像"><a href="#自定义镜像" class="headerlink" title="自定义镜像"></a>自定义镜像</h2><p><strong>镜像结构是分层的结构，每一层都有自己的配置</strong></p><p>Baselmage层：包含基本的系统函数库、环境变量、文件系统</p><p>Entrypoint：入口，是镜像中应用启动的命令</p><p>其它在Baselmage基础上添加依赖、安装程序、完成整个应用的安装和配置</p><p><strong>自定义镜像的步骤如下</strong></p><ol><li><p>首先定义一个自定义文件，该文件是描述镜像构建的过程</p></li><li><p>该文件的第一行必须是FROM，是从哪一层开始构建的</p></li><li><p>基础镜像可以是ubuntu也可以是别构建好的镜像java:8-alpine</p></li><li><p>准备好项目运行的压缩包并放到同一目录中</p></li><li><p>最后运行如下命令即可构建一个镜像</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t imageName:version .</span><br></pre></td></tr></table></figure><p><strong>自定义文件的构建</strong></p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221230170937335.png" alt="image-20221230170937335"></p><p>自动补全命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -L \</span><br><span class="line">https://raw.githubusercontent.com/docker/compose/1.29.1/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose</span><br></pre></td></tr></table></figure><p>修改域名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;199.232.68.133 raw.githubusercontent.com&quot; &gt;&gt; /etc/hosts</span><br></pre></td></tr></table></figure><h2 id="镜像仓库"><a href="#镜像仓库" class="headerlink" title="镜像仓库"></a>镜像仓库</h2><ul><li><p>公有仓库：DockerHub–&gt;<a href="https://hub.docker.com/">Docker</a></p></li><li><p>私有仓库：需要自己搭建</p></li></ul><p><strong>搭建私有仓库的步骤如下</strong></p><ol><li>首先创建一个文件取名：docker-compose.yml</li><li>在配置一下daemen.json的文件，顺序执行以下命令即可，目的是为了让你创建的仓库被信任</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打开要修改的文件</span></span><br><span class="line">vi /etc/docker/daemon.json</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加内容：端口号是自己电脑或虚拟机的ip</span></span><br><span class="line">&quot;insecure-registries&quot;:[&quot;http://192.168.177.131:8088&quot;] </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重加载</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启docker</span></span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><ol start="3"><li>在docker-compose.yml中的内容如下</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">version: &#x27;3.0&#x27;</span><br><span class="line">services:</span><br><span class="line">  registry:</span><br><span class="line">    image: registry</span><br><span class="line">    volumes:</span><br><span class="line">      - ./registry-data:/var/lib/registry</span><br><span class="line">  ui:</span><br><span class="line">    image: joxit/docker-registry-ui:static</span><br><span class="line">    ports:</span><br><span class="line">      - 8088:80 # 左边的端口号是为了让外界访问此仓库的，可以修改</span><br><span class="line">    environment: </span><br><span class="line">      - REGISTRY_TITLE=RegistryOfMysties # 可以顺便起个仓库名称</span><br><span class="line">      - REGISTRY_URL=http://registry:5000</span><br><span class="line">    depends_on:</span><br><span class="line">      - registry</span><br></pre></td></tr></table></figure><ol start="4"><li>但上面的配置做完之后，再执行以下命令启动</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看启动日志</span></span><br><span class="line">docker-compose logs -f</span><br></pre></td></tr></table></figure><ol start="5"><li>然后在游览器访问</li></ol><p><strong>私有仓库镜像的相关操作</strong></p><p>推送镜像到私有镜像服务必须先tag，步骤如下：</p><ol><li>重新命名镜像名称，名称前缀是私有仓库的ip，例如：192.168.177.131:8088&#x2F;</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag nginx:latest 192.168.177.131:8088/nginx:1.0</span><br></pre></td></tr></table></figure><ol start="2"><li>推送本地镜像到私有仓库</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push 192.168.177.131:8088/nginx:1.0</span><br></pre></td></tr></table></figure><ol start="3"><li>从私有仓库中拉取镜像</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull 192.168.177.131:8088/nginx:1.0</span><br></pre></td></tr></table></figure><h1 id="MQ（MessageQueue）"><a href="#MQ（MessageQueue）" class="headerlink" title="MQ（MessageQueue）"></a>MQ（MessageQueue）</h1><p><strong>同步调用：</strong>就是每增加一个新的业务时，都需要新增一个远程调用到其它的微服务实例上，所以该调用方式存在的问题，耦合度高，性能下降，资源浪费，级联失败。</p><p>异步调用会解决同步调用的问题，单异步也有缺点：依赖于Broker的可靠性、安全性、吞吐能力，架构复杂了，业务没有明显的流程线，不好追踪管理</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221231141749235.png" alt="image-20221231141749235"></p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221231142431990.png" alt="image-20221231142431990"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;认识微服务&quot;&gt;&lt;a href=&quot;#认识微服务&quot; class=&quot;headerlink&quot; title=&quot;认识微服务&quot;&gt;&lt;/a&gt;认识微服务&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;单体架构：将业务的所有功能集中在一个项目中开发，打成一个包部署。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：</summary>
      
    
    
    
    
    <category term="springcloud" scheme="http://example.com/tags/springcloud/"/>
    
  </entry>
  
  <entry>
    <title>java模拟进程运行</title>
    <link href="http://example.com/2022/11/23/java%E6%A8%A1%E6%8B%9F%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C/"/>
    <id>http://example.com/2022/11/23/java%E6%A8%A1%E6%8B%9F%E8%BF%9B%E7%A8%8B%E8%BF%90%E8%A1%8C/</id>
    <published>2022-11-23T12:09:00.000Z</published>
    <updated>2023-01-30T09:32:37.223Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java模拟进程程序流程图和概述"><a href="#java模拟进程程序流程图和概述" class="headerlink" title="java模拟进程程序流程图和概述"></a>java模拟进程程序流程图和概述</h1><ul><li><p>进程的概述</p><p>​进程是正在执行的程序是动态资源，而程序是静态资源，进程运行需要占用CPU的使用权，进程中有多个线程，进程中的资源可以被多个线程共享。更多详情请看java基础中的并发编程</p></li><li><p>进程并发执行</p><p>​进程并发执行可以从两个角度进行说明：</p><p><strong>宏观角度：</strong> 进程的并发性是指一组进程的执行在时间上是重叠的。所谓执行在时间上是重叠的，是指一个进程执行的第一条指令是在另一个进程执行的最后一条指令完成之前开始的。例如，现有进程A和进程B分别执行（a1，a2，a3）和（b1，b2，b3）这六个资源，在单处理机上这六个资源是交叉顺序执行的，假设进程A执行完a1后，CPU的使用权被进程B占用，进程B就开始执行b1，依次推理，可能的执行顺序是：a1 ，b1，a2，b2，b3，a4 等多种情况，并且程序运行是非常快的，所以给人一种错觉，进程是并发执行的。</p><p><strong>微观角度：</strong> 在单处理机上，处理机只能处理一个进程，反过来看，并发的实质是对一个处理机对多个进程之间的多路复用。</p></li><li><p>进程执行的三种基本状态</p><p>​在进程中有执行、就绪、堵塞这三种基本状态。如下图所示</p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221123212927162.png" alt="image-20221123212927162" style="zoom:50%;" /><p>​在本次模拟只模拟进程的从就绪状态到执行状态。</p></li><li><p>java模拟进程执行流程图</p><p>​思路简要说明：采用优先队列当做就绪队列，假设进程是以优先级高的先执行，优先级相等的采用FIFO法顺序执行，关于进程优先级可以百度了解（dogs）</p></li></ul><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/4BDVW7FQK76GRC~63BEPRXO.png" alt="4BDVW7FQK76GRC~63BEPRXO" style="zoom: 80%;" /><ul><li>java代码实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  模拟多进程运行</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@author</span> mysticBoy</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@creatTime</span> 2022/11/21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PCB_Experiment</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;PCB&gt; pcbs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 创建进程的数量</span></span><br><span class="line">        pcbs.add(<span class="keyword">new</span> <span class="title class_">PCB</span>(<span class="string">&quot;进程1&quot;</span>,<span class="number">10</span>,<span class="number">45</span>,<span class="number">0</span>));</span><br><span class="line">        pcbs.add(<span class="keyword">new</span> <span class="title class_">PCB</span>(<span class="string">&quot;进程2&quot;</span>,<span class="number">5</span>,<span class="number">30</span>,<span class="number">0</span>));</span><br><span class="line">        pcbs.add(<span class="keyword">new</span> <span class="title class_">PCB</span>(<span class="string">&quot;进程3&quot;</span>,<span class="number">7</span>,<span class="number">40</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 创建进程的执行对象并将进程放入到进程执行中</span></span><br><span class="line">        <span class="type">PcbExecute</span> <span class="variable">execute</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PcbExecute</span>(pcbs);</span><br><span class="line">        <span class="comment">// 进程执行</span></span><br><span class="line">        execute.executing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 进程执行类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PcbExecute</span>&#123;</span><br><span class="line">    <span class="comment">//就绪队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Queue&lt;PCB&gt; queue;</span><br><span class="line">    <span class="comment">//初始化队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PcbExecute</span><span class="params">(List&lt;PCB&gt; pcbList)</span> &#123;</span><br><span class="line">        queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;( <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;PCB&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(PCB o1, PCB o2)</span> &#123;</span><br><span class="line">                <span class="comment">//队列以进程优先级数进行排序</span></span><br><span class="line">                <span class="keyword">return</span> o2.getPriority() - o1.getPriority();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 将进程列表中的加入到队列中</span></span><br><span class="line">        queue.addAll(pcbList);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 进程执行方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executing</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 获取队列的迭代器</span></span><br><span class="line">        Iterator&lt;PCB&gt; iterator = queue.iterator();</span><br><span class="line">        <span class="comment">// 通过迭代器遍历队列中的每个进程</span></span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="comment">// 1. 获取出优先级最高的进程</span></span><br><span class="line">            <span class="type">PCB</span> <span class="variable">currPcb</span>  <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">assert</span> currPcb != <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 2. 减少当前进程的优先级</span></span><br><span class="line">            currPcb.setPriority(currPcb.getPriority() - <span class="number">3</span>);</span><br><span class="line">            <span class="comment">// 4. 判断该进程是否执行完毕 即 totalTime 是否执行完</span></span><br><span class="line">            <span class="keyword">if</span>(currPcb.getTotalTime() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 4.1 减少当前进程的所需运行时间片数</span></span><br><span class="line">                currPcb.setTotalTime(currPcb.getTotalTime() - <span class="number">1</span>);</span><br><span class="line">                currPcb.setOccupyTime(currPcb.getOccupyTime() + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 4.2 修改进程的状态</span></span><br><span class="line">                currPcb.setState(<span class="number">3</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 说明当前进程结束</span></span><br><span class="line">                currPcb.setState(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 直接将该进程加回就绪队列中</span></span><br><span class="line">            queue.add(currPcb);</span><br><span class="line">            <span class="comment">// 打印进程的信息</span></span><br><span class="line">            queue.forEach(pcb -&gt; &#123;</span><br><span class="line">                <span class="keyword">switch</span> (pcb.getState()) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                        System.out.println(pcb.getPcbName() + <span class="string">&quot;-&gt;已结束...  &quot;</span> + <span class="string">&quot;  需要时间片：&quot;</span> + pcb.getTotalTime()</span><br><span class="line">                           + <span class="string">&quot;  占用CPU时间片：&quot;</span> + pcb.getOccupyTime() + <span class="string">&quot;  优先级：&quot;</span> + pcb.getPriority());</span><br><span class="line">                        <span class="comment">// 将结束的进程从就绪队列中移除</span></span><br><span class="line">                        queue.remove(pcb);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                        System.out.println(pcb.getPcbName()+<span class="string">&quot;-&gt;就绪中...  &quot;</span> +<span class="string">&quot;  需要时间片：&quot;</span> + pcb.getTotalTime()</span><br><span class="line">                          + <span class="string">&quot;  占用CPU时间片：&quot;</span> + pcb.getOccupyTime() + <span class="string">&quot;  优先级：&quot;</span> + pcb.getPriority());</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                        System.out.println(pcb.getPcbName()+<span class="string">&quot;-&gt;运行中...  &quot;</span> +<span class="string">&quot;  需要时间片：&quot;</span> + pcb.getTotalTime()</span><br><span class="line">                           + <span class="string">&quot;  占用CPU时间片：&quot;</span> + pcb.getOccupyTime() + <span class="string">&quot;  优先级：&quot;</span> + pcb.getPriority());</span><br><span class="line">                        pcb.setState(<span class="number">2</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">      System.out.println(<span class="string">&quot;============================================================&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 进程类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PCB</span>&#123;</span><br><span class="line">    <span class="comment">// 进程名称</span></span><br><span class="line">    <span class="keyword">private</span> String pcbName;</span><br><span class="line">    <span class="comment">// 进程状态：0——结束，1——等待，2——就绪，3——运行</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">state</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 进程执行所需的时间片数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> totalTime;</span><br><span class="line">    <span class="comment">// 优先级：优先级越高，就优先执行</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> priority;</span><br><span class="line">    <span class="comment">// 进程占用CPU总时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> occupyTime;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PCB</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PCB</span><span class="params">(String pcbName, <span class="type">float</span> totalTime, <span class="type">int</span> priority, <span class="type">float</span> occupyTime)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.pcbName = pcbName;</span><br><span class="line">        <span class="built_in">this</span>.totalTime = totalTime;</span><br><span class="line">        <span class="built_in">this</span>.priority = priority;</span><br><span class="line">        <span class="built_in">this</span>.occupyTime = occupyTime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPcbName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pcbName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPcbName</span><span class="params">(String pcbName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.pcbName = pcbName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setState</span><span class="params">(<span class="type">int</span> state)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">getTotalTime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> totalTime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTotalTime</span><span class="params">(<span class="type">float</span> totalTime)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.totalTime = totalTime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getPriority</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> priority;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPriority</span><span class="params">(<span class="type">int</span> priority)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.priority = priority;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">getOccupyTime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> occupyTime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOccupyTime</span><span class="params">(<span class="type">float</span> occupyTime)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.occupyTime = occupyTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行结果如下图（由于运行结果太多只截取一部分）</li></ul><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221123214808069.png" alt="image-20221123214808069"></p><ul><li>总结：在微观角度中进程是逐个交叉运行的方式。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;java模拟进程程序流程图和概述&quot;&gt;&lt;a href=&quot;#java模拟进程程序流程图和概述&quot; class=&quot;headerlink&quot; title=&quot;java模拟进程程序流程图和概述&quot;&gt;&lt;/a&gt;java模拟进程程序流程图和概述&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;进程的概述</summary>
      
    
    
    
    
    <category term="java，进程，多线程" scheme="http://example.com/tags/java%EF%BC%8C%E8%BF%9B%E7%A8%8B%EF%BC%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>java基础（节选）</title>
    <link href="http://example.com/2022/11/23/java%E5%9F%BA%E7%A1%80%EF%BC%88%E8%8A%82%E9%80%89%EF%BC%89/"/>
    <id>http://example.com/2022/11/23/java%E5%9F%BA%E7%A1%80%EF%BC%88%E8%8A%82%E9%80%89%EF%BC%89/</id>
    <published>2022-11-22T16:00:00.000Z</published>
    <updated>2023-02-17T08:56:03.988Z</updated>
    
    <content type="html"><![CDATA[<h1 id="异常的作用"><a href="#异常的作用" class="headerlink" title="异常的作用"></a>异常的作用</h1><ol><li>提高程序的健壮性和安全性。</li><li>可以处理代码问题，防止程序出现问题后的死亡。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 程序校验年龄是否正确</span></span><br><span class="line">                <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">                System.out.print(<span class="string">&quot;请输入年龄：&quot;</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">                <span class="keyword">if</span>(age &lt; <span class="number">0</span> || age &gt; <span class="number">200</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;输入正确：&quot;</span> + age);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;年龄输入错误~~&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221123145110280.png" alt="image-20221123145110280"></p><ol start="3"><li>以上代码就是异常的实用之处，可以让出现异常的代码继续执行。</li></ol><h1 id="多线程和并发编程"><a href="#多线程和并发编程" class="headerlink" title="多线程和并发编程"></a>多线程和并发编程</h1><h2 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程?"></a>什么是进程?</h2><p>程序是静止的，运行中的程序就是进程。并行是 同一个时刻同时有多个在执行。</p><p>进程的三个特征:</p><ol><li>动态性： 进程是运行中的程序，要动态的占用内存，CPU和网络等资源。</li><li>独立性： 进程与进程之间是相互独立的，彼此有自己的独立内存区域。</li><li>并发性： 假如CPu是单核，同一个时刻其实内存中只有一个进程在被执行。CPU会分时轮询切换依次为每个进程服务，因为切换的速度非常快，给我们的感觉这些进程在同时执行，这就是并发性。</li></ol><h2 id="什么是线程？"><a href="#什么是线程？" class="headerlink" title="什么是线程？"></a>什么是线程？</h2><ol><li>线程是属于进程的。</li><li>一个进程可以包含多个线程，这就是多线程。线程是进程中的一个独立执行单元。</li><li>线程创建开销相对于进程来说比较小。线程也支持并发性。</li></ol><p>线程的作用：</p><ol><li>可以提高程序的效率，线程也支持并发性，可以有更多机会得到CPU。多线程可以解决很多业务模型。</li><li>大型高并发技术的核心技术。</li><li>设计到多线程的开发可能都比较难理解。</li></ol><h2 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h2><h3 id="继承Thread类创建（方式一）"><a href="#继承Thread类创建（方式一）" class="headerlink" title="继承Thread类创建（方式一）"></a>继承Thread类创建（方式一）</h3><ol><li><p>定义一个线程类继承并继承Thread类</p></li><li><p>重写run方法，在run方法中可以编写代码业务</p></li><li><p>创建该线程对象</p></li><li><p>调用对象中的start()方法，开启新的线程并执行业务</p><p>继承Thread的缺点：</p><p> 优点：编码简单</p><p> 缺点：线程类已经继承了Thread类无法继承其他类了，功能不能通过继承拓展（单继承）</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadTest</span> &#123;</span><br><span class="line">    <span class="comment">// 1. main是一个主进程，在main中可以运行多个线程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建线程对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">myThread</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="comment">//开启线程：start会给myThread注册进入CPU中，会与主进程竞争CPU的执行权</span></span><br><span class="line">        myThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;主进程：&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建一个线程类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="comment">//重写run方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;分支线程：&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现Runnable接口创建线程（方式二）"><a href="#实现Runnable接口创建线程（方式二）" class="headerlink" title="实现Runnable接口创建线程（方式二）"></a>实现Runnable接口创建线程（方式二）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//3. 创建MyRunnable对象</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">run</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">        <span class="comment">//4. 创建Thread方法执行线程业务</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(run,<span class="string">&quot;run1&quot;</span>);</span><br><span class="line">        <span class="comment">//开启线程任务</span></span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1. 定义一个类实现Runnable接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">//2. 重写run方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>缺点:代码复杂一点。</p></li><li><p>优点：</p></li></ol><p>避免了单继承的局限性</p><p>同一个线程任务对象可以被包装成多个线程对象</p><p>适合多个多个线程去共享同一个资源</p><p>实现解耦操作，线程任务代码可以被多个线程共享，线程任务代码和线程独立。</p><p>线程池可以放入实现Runable或callable线程任务对象。</p><p><strong>注意：其实Thread类本身也是实现了Runnable接口的。</strong></p><h3 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h3><ol><li>线程安全的说明：如下图</li></ol><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221123155806551.png" alt="image-20221123155806551"></p><ol start="2"><li>上图解析：假设小明和小红的账户余额为100000，当小明和小红一起去银行取钱，那么小明和小红取钱的行为可以看成两个进程进行取钱的操作，由于进程的并发性和CPU执行权的随机分配，会导致程序执行判断小明账户是否有余额，这时为true并且账户余额未被取出，这时小红也来取钱，程序的执行权被小红占用，这时判断是否有余额，也是true，然后小明和小红在同一个账户取了两次的钱，导致用户钱为负数，这就发生了线程安全问题。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  线程安全问题的演示</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 账户类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> cardId;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> money;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="comment">//判断是谁来取钱</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">        <span class="comment">//判断是否还有余额</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.money &gt;= money) &#123;</span><br><span class="line">            <span class="comment">//还有余额</span></span><br><span class="line">            System.out.println(name + <span class="string">&quot;取出 &quot;</span> + money);</span><br><span class="line">            <span class="comment">//扣减余额</span></span><br><span class="line">            <span class="built_in">this</span>.money = <span class="built_in">this</span>.money - money;</span><br><span class="line">            System.out.println(<span class="string">&quot;余额剩余：&quot;</span> + <span class="built_in">this</span>.money);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//余额不足</span></span><br><span class="line">            System.out.println(<span class="string">&quot;余额不足...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(<span class="type">long</span> cardId, <span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cardId = cardId;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getCardId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cardId;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCardId</span><span class="params">(<span class="type">long</span> cardId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cardId = cardId;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//取钱的线程类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DrawingMoney</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Account account;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DrawingMoney</span><span class="params">(Account account,String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.account = account;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//取钱的业务</span></span><br><span class="line">        account.drawMoney(account.getMoney());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PCBSecurity</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//初始化一个账户</span></span><br><span class="line">        <span class="type">Account</span> <span class="variable">account</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>(<span class="number">101</span>,<span class="number">10000</span>);</span><br><span class="line">        <span class="comment">//小明来取钱的线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">xiaoming</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DrawingMoney</span>(account,<span class="string">&quot;小明&quot;</span>);</span><br><span class="line">        xiaoming.start();</span><br><span class="line">        <span class="comment">//小红来取钱</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">xiaohong</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DrawingMoney</span>(account,<span class="string">&quot;小红&quot;</span>);</span><br><span class="line">        xiaohong.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​<strong>运行结果如下</strong></p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221123163012728.png"></p><h3 id="解决线程安全问题"><a href="#解决线程安全问题" class="headerlink" title="解决线程安全问题"></a>解决线程安全问题</h3><ol><li>同步代码块锁synchronized(this)：在共享资源加同步锁，以保证小明和小红能逐个从账户中取钱，代码如下，其中this对象必须保证唯一性，来保证锁的唯一</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">    <span class="comment">//判断是谁来取钱</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">    <span class="comment">//账户类就是共享资源，已账户类为加锁的标志，同一个账户只能有一个人进来取钱</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">       <span class="comment">//判断是否还有余额</span></span><br><span class="line">       <span class="keyword">if</span>(<span class="built_in">this</span>.money &gt;= money) &#123;</span><br><span class="line">           <span class="comment">//还有余额</span></span><br><span class="line">           System.out.println(name + <span class="string">&quot;取出 &quot;</span> + money);</span><br><span class="line">           <span class="comment">//扣减余额</span></span><br><span class="line">           <span class="built_in">this</span>.money = <span class="built_in">this</span>.money - money;</span><br><span class="line">           System.out.println(<span class="string">&quot;余额剩余：&quot;</span> + <span class="built_in">this</span>.money);</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//余额不足</span></span><br><span class="line">           System.out.println(<span class="string">&quot;余额不足...&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221123165517823.png" alt="image-20221123165517823"></p><ol start="2"><li><p>同步方法：在对操作共享资源的方法上加上synchronized即可加锁，在方法执行完毕后，自动释放锁。</p><p>原理： 同步方法的原理和同步代码块的底层原理其实是完全一样的，只是同步方法是把整个方法的代码都锁起来的。同步方法上锁的范围比同步代码块大，而且加锁的范围太大会大大降低执行的性能，故在加锁时可以优先考虑同步代码块，加锁范围越精确，对性能影响就越小<br>    同步方法其实底层也是有锁对象的:<br>        如果方法是实例方法：同步方法默认用this作为的锁对象。<br>        如果方法是静态方法：同步方法默认用类名.class作为的锁对象。</p></li><li><p>Lock锁方法：</p><p>​Lock锁的优点：上锁的灵活性更好。</p><p>注意：  使用该方法上锁一定需要把解锁放到finnally的代码块中。因为在finnally中无论是否出现异常都会执行，所以在finnally可以保证解锁的操作，防止死锁的出现</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> cardId;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> money;</span><br><span class="line">    <span class="comment">//创建一个lock锁对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="comment">//判断是谁来取钱</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">        <span class="comment">//上锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//判断是否还有余额</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.money &gt;= money) &#123;</span><br><span class="line">                <span class="comment">//还有余额</span></span><br><span class="line">                System.out.println(name + <span class="string">&quot;取出 &quot;</span> + money);</span><br><span class="line">                <span class="comment">//扣减余额</span></span><br><span class="line">                <span class="built_in">this</span>.money = <span class="built_in">this</span>.money - money;</span><br><span class="line">                System.out.println(<span class="string">&quot;余额剩余：&quot;</span> + <span class="built_in">this</span>.money);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//余额不足</span></span><br><span class="line">                System.out.println(<span class="string">&quot;余额不足...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//解锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(<span class="type">long</span> cardId, <span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cardId = cardId;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getCardId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cardId;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCardId</span><span class="params">(<span class="type">long</span> cardId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cardId = cardId;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221124160355767.png" alt="image-20221124160355767"></p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>概述： 线程池是一个可以容纳多个线程的容器，其中的线程可以被反复的使用，从而减少了对线程对象的创建和销毁，提高了系统资源的利用率，防止创建过多的线程而导致系统的僵死。</p><p>核心思想： 线程复用。</p><p>以下代码是最基本的线程池用法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="comment">//创建一个线程池，其中的参数是创建几个线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建线任务对象</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="comment">//将任务加入线程池中，线程池会自动帮我们创建新的线程去执行任务</span></span><br><span class="line">        pool.submit(task);</span><br><span class="line">        pool.submit(task);</span><br><span class="line">        pool.submit(task); <span class="comment">//注意：此时的线程是复用前面创建的线程，因为在pool中只有2个线程</span></span><br><span class="line">         <span class="comment">// 关闭线程池</span></span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义一个线程任务类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//线程任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;：&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221124170402567.png" alt="image-20221124170402567"></p><p>在上图的运行结果可以看出线程池中始终只有两个线程在执行，分别是thread-1和thread-2</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>概述： 死锁是程序执行中的一种情况，多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p><p><strong>死锁产生的四个必要条件</strong></p><p>（1）互斥使用，即当资源被一个线程使用(占有)时，别的线程不能使用。</p><p>（2）不可抢占，资源请求者不能强制从资源占有者手中夺取资源，资源只能由资源占有者主动释放。</p><p>（3）请求和保持，即当资源请求者在请求其他的资源的同时保持对原有资源的占有。</p><p>（4）循环等待，即存在一个等待循环队列，p1要p2的资源，p2要p1的资源。这样就形成了一个等待环路</p><p>当上述四个条件都成立的时候，便形成死锁。当然，死锁的情况下如果打破上述任何一个条件，便可让死锁消失，以下是死锁的代码演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 死锁问题：死锁问题常产生在嵌套加锁上</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeathLock</span> &#123;</span><br><span class="line">    <span class="comment">//定义两个资源</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">source1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">source2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//这里使用匿名内部类实现线程的执行</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123; <span class="comment">//第一个线程</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (source1)&#123;</span><br><span class="line">                    <span class="comment">//拿到资源1</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;线程1拿到资源1，请求资源2&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//因为产生死锁是概率问题，故为了100%产生死锁，让该线程休眠1s，让线程2可以执行</span></span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">synchronized</span> (source2) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;线程1拿到资源2，可以释放资源了&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123; <span class="comment">//第二个线程</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (source2)&#123;</span><br><span class="line">                    <span class="comment">//拿到资源1</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;线程2拿到资源2，请求资源1&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//因为产生死锁是概率问题，故为了100%产生死锁，让该线程休眠1s，让线程1可以执行</span></span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">synchronized</span> (source1) &#123; </span><br><span class="line">                        System.out.println(<span class="string">&quot;线程2拿到资源1，可以释放资源了&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221124174017855.png" alt="image-20221124174017855"></p><h2 id="并发环境下，多线程访问变量的不可见性"><a href="#并发环境下，多线程访问变量的不可见性" class="headerlink" title="并发环境下，多线程访问变量的不可见性"></a>并发环境下，多线程访问变量的不可见性</h2><p>概述： 多个线程访问同一个变量，会出现器中一个线程修改变量的值后，其它线程看不到变量的最新值。以下代码可以说明该问题，在以下代码中MyThread子线程是先执行的，理论上应该先将flag &#x3D; true，而主线程会一直打印hello world…，然而结果并非如此。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123; <span class="comment">//执行线程任何</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//这里是为了模拟业务代码的执行了一段时间后</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        flag = <span class="literal">true</span>; <span class="comment">//改变flag标志</span></span><br><span class="line">        System.out.println(<span class="string">&quot;flag已经变为true了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFlag</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFlag</span><span class="params">(<span class="type">boolean</span> flag)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.flag = flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnableVision</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个子线程对象并开启线程任务的执行</span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        t.start();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//休眠，保证子线程先执行</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//主线程执行的任务</span></span><br><span class="line">        <span class="keyword">while</span> (t.isFlag()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hello world...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码运行结果如下：可以看出在主线程中读取的flag并不为true，但子线程已将flag置为true了，这就是多线程下对共同变量值的不可见性（概率问题）。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221124204337248.png" alt="image-20221124204337248"></p><h3 id="多线程中变量不可见性的原因"><a href="#多线程中变量不可见性的原因" class="headerlink" title="多线程中变量不可见性的原因"></a>多线程中变量不可见性的原因</h3><p>JVM虚拟机对多线程内存作以下规定</p><ul><li>所有的共享变量都存储于主内存。这里所说的变量指的是实例变量和类变量。不包含局部变量，因为局部变量是线程私有的，因此不存在竞争问题。</li><li>每一个线程还存在自己的工作内存，线程的工作内存，保留了被线程使用的变量的工作副本。</li><li>线程对变量的所有的操作(读，取)都必须在工作内存中完成，而不能直接读写主内存中的变量。</li><li>不同线程之间也不能直接访问对方工作内存中的变量，线程间变量的值的传递需要通过主内存中转来完成。</li></ul><p><strong>下图是本地内存和主内存的关系</strong></p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221124210145669.png" alt="image-20221124210145669" style="zoom:67%;" /><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221124210500313.png" alt="image-20221124210500313" style="zoom:67%;" /><p>个人解读： 在第二张图中，首先变量flag在主内存中默认为false，随后键flag分配到子线程和主线程工作内存中，这时各线程的flag是为false值，其次子线程t执行后将flag改为true，将其返回主内存中，此时主内存flag也是true，但由于JVM的规定，主线程中的工作内存中的flag仍为false，所有在主线程执行时读取的速度非常快，还来不及将flag值更新，主线程就已经读取了旧值，就导致了多线程下变量的不可见性。</p><p><strong>总结：并发编程下，多线程修改变量，会出现线程间变量的不可见性。</strong></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>加锁：因为加锁的操作会清空工作内存中的值，从主内存中读取最新的值，如下代码，给主线程加锁后会清空工作内存，从而使主线程从主内存中读取读取最小的flag值，就可以触发hello world的打印</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主线程执行的任务</span></span><br><span class="line"><span class="keyword">synchronized</span> (UnableVision.class) &#123; </span><br><span class="line">    <span class="keyword">while</span> (t.isFlag()) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221124213059050.png" alt="image-20221124213059050"></p><p>用volatile修饰公共变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>原理图如下</p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221124213834640.png" alt="image-20221124213834640" style="zoom:67%;" /><p>个人解读：volatile关键字并不是将个线程的工作内存清空，而是在某个线程中改变了共同变量值后，有volatile关键字修饰的变量就会通知其它线程该变量更新了，你那个变量是旧值，然后线程会将该变量视为失效的变量值，再从主内存中读取最新值，从而实现各个线程之间变量的可见性。</p><p><strong>volatile与synchronized的区别</strong></p><ol><li><p>volatile只能修饰实例变量和类变量，而synchronized可以修饰方法，以及代码块。</p></li><li><p>volatile保证数据的可见性，但是不保证原子性(多线程进行写操作，不保证线程安全);</p></li><li><p>而synchronized是一种排他(互斥)的机制，可以保证线程安全。</p></li></ol><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>概述：原子性就是一批程序操作看成一个整体，要么执行，要么不执行。</p><p>以下代码是证明volatile不能保证原子性（线程安全问题），以下代码执行的结果理论上count应该为10000，但结果却是不到10000，这是属于线程任务未全执行完成导致的，故volatile并不能保证原子性。该运行结果是概率问题，多运行几次会出现不同的效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建线程对象</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VThread</span>();</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">           <span class="comment">//启动子线程100次</span></span><br><span class="line">           <span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">           count ++;</span><br><span class="line">           System.out.println(<span class="string">&quot;count=&quot;</span> + count);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221125195603121.png" alt="image-20221125195603121"></p><h3 id="保证原子性的方案"><a href="#保证原子性的方案" class="headerlink" title="保证原子性的方案"></a>保证原子性的方案</h3><p>加锁</p><ul><li><p>优点：实现简单</p></li><li><p>缺点：在高并发的环境下性能会变差</p></li></ul><p>如下的代码是再循环加前加上一个同步代码块锁，即可保证原子性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        System.out.println(<span class="string">&quot;count=&quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221126103607905.png" alt="image-20221126103607905"></p><p>使用原子类</p><ul><li><p>Atomiclnteger是JDK1.5版本后提供的原子类，该类的API接口可以查看API文档。</p></li><li><p>优点：性能高效，线程安全</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个原子类，其中参数是默认值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// incrementAndGet()是自动加1 并返回值</span></span><br><span class="line">            System.out.println(<span class="string">&quot;count=&quot;</span> + count.incrementAndGet());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221126104410355.png" alt="image-20221126104410355"></p><p>原子类底层原理</p><ol><li>在原子类源码中并不是一加锁的形式保证原子性的，而是利用CSA法保证原子性，那什么是CSA呢？</li></ol><p><strong>CAS的全名是：Compare And Swap(比较再交换)；是现代CPU广泛支持的一种对内存中的共享数据进行操作的一种特殊指令。CAS可以将read-modify-check-write</strong></p><p>转换为原子操作，这个原子操作直接由处理器保证。</p><p>CAS机制当中使用了3个基本操作数：内存地址V，旧的预期值A，要修改的新值B。</p><p><strong>个人理解</strong>：下图中的前提。因为线程执行顺序是有随机性的，假定进程1先执行读取值，再线程2执行读取值操作，在这种情况下若没有采取措施是会破坏原子性的。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221126111827373.png" alt="image-20221126111827373"></p><p>CSA和synchronized</p><ul><li><p>共同点： 都可以保证共享数据的安全性(原子性)</p></li><li><p>区别：CAS是没有加锁的，性能较好。（乐观锁）</p></li><li><p>synchronized是加锁操作，性能较差（悲观锁）</p></li></ul><h2 id="并发包"><a href="#并发包" class="headerlink" title="并发包"></a>并发包</h2><p>并发包是JDK本身自带的包，里面提供了很多的类供我我们使用，以下是比较常用的类。</p><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>概述：Map集合中的经典集合:HashMap它是”线程不安全”的，性能好。如果在要求线程安全的业务情况下就不能用这个集合做Map集合，否则业务会崩溃，为了保证线程安全，可以使用Hashtable。Hashtable是线程安全的Map集合，但是性能较差！(已经被淘汰了，虽然安全，但是性能差)，HashTable的底层源码所有方法都有加锁。ConcurrentHashMap集合，是性能较好，线程安全，最新的集合类。</p><ol start="2"><li>下代码是证明HashMap的线程不安全</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * map集合的线程安全测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapTest</span> &#123;</span><br><span class="line">    <span class="comment">//测试HashMap的线程安全</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建两个线程t1 和 t2</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyThread</span>(), <span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyThread</span>(), <span class="string">&quot;线程2&quot;</span>);</span><br><span class="line">        <span class="comment">// 开启线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">// 保证t1和t2执行完成后再打印</span></span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        <span class="comment">// map长度的理论上应为100000</span></span><br><span class="line">        System.out.println(<span class="string">&quot;map的长度&quot;</span> + map.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50000</span>; i++) &#123;</span><br><span class="line">            MapTest.map.put(Thread.currentThread().getName() + i,Thread.currentThread().getName() + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221126124300277.png" alt="image-20221126124300277"></p><p>Hashtable和ConcurrentHashMap集合的效率比较</p><p><strong>测试Hashtable的执行时间为多少</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String,String&gt; map = <span class="keyword">new</span> <span class="title class_">Hashtable</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221126125645268.png" alt="image-20221126125645268"></p><p><strong>测试ConcurrentHashMap测试时间多少</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String,String&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221126125801439.png" alt="image-20221126125801439"></p><p>如上图结果所示ConcurrentHashMap性能较好，那为何ConcurrentHashMap性能比Hashtable好呢？</p><p><strong>Hashtable和ConcurrentHashMap集合的底层原理概述</strong></p><p>HashTable的结构图如下，可看出在所有的链表都加锁了，故加锁的范围大，效率自然就低了。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221126130147813.png" alt="image-20221126130147813"></p><p>ConcurrentHashMap结构图如下，可见其只在一条链上加锁，故锁的范围较小，效率自然就高了。</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221126130537171.png" alt="image-20221126130537171"></p><h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><p>某个线程任务必须等待其他线程执行完毕以后才能最终触发自己执行。</p><p>需求： 公司召集5名员工开会，等5名员工都到了，会议开始。</p><p>​1. 在以下代码中，5名员工还未全部到达会议，就已经开始组织会议。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//循环创建线程，总创建5个线程代表5个员工</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i ++)&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">EmployeeThread</span>(<span class="string">&quot;员工&quot;</span> + i).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 开始会议</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Meeting</span>()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建会议开始的线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Meeting</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;员工5开始组织会议。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建员工线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmployeeThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EmployeeThread</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;进入会议&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221126135812833.png" alt="image-20221126135812833"></p><ol start="2"><li>利用并发包提供的CyclicBarrier类可以保证先让员工进入会议，在开始组织会议</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 例如:公司召集5名员工开会，等5名员工都到了，会议开始。</span></span><br><span class="line"><span class="comment"> * 我们创建5个员工线程，1个开会任务，几乎同时启动</span></span><br><span class="line"><span class="comment"> * 使用cyclicBarrier保证5名员工线程全部执行后，再执行开会线程。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 构造器:</span></span><br><span class="line"><span class="comment"> *  public cyclicBarrier(int parties,Runnable barrierAction)</span></span><br><span class="line"><span class="comment"> *       用于在线程到达屏障5时，优先执行barrierAction，方便处理更复杂的业务场景</span></span><br><span class="line"><span class="comment"> * 方法:</span></span><br><span class="line"><span class="comment"> *  public int await ()</span></span><br><span class="line"><span class="comment"> *      每个线程调用await方法告诉cyclicBarrier我已经到达了屏障，然后当前线程被阻塞</span></span><br><span class="line"><span class="comment"> *  小结:</span></span><br><span class="line"><span class="comment"> *      可以实现多线程中，某个任务在等待其他线程执行完毕以后触发。循坏屏障可以实现达到一组屏障就触发一个任务执行!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建循环屏障对象，让5个员工全部进入会议在进行开会</span></span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">cyclicBarrier</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">5</span>,<span class="keyword">new</span> <span class="title class_">Meeting</span>());</span><br><span class="line">        <span class="comment">//循环创建线程，创建5个线程代表5个员工</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i ++)&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">EmployeeThread</span>(<span class="string">&quot;员工&quot;</span> + i,cyclicBarrier).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建会议开始的线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Meeting</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;员工5开始组织会议。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建员工线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">EmployeeThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="comment">//接收CyclicBarrier的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CyclicBarrier cyclicBarrier;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EmployeeThread</span><span class="params">(String name,CyclicBarrier cyclicBarrier)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.cyclicBarrier = cyclicBarrier;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//Thread.sleep(1000);</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;进入会议&quot;</span>);</span><br><span class="line">            cyclicBarrier.await(); <span class="comment">//源码中有个计数器，当计数器为5时，就将该线程回收</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221126140145795.png" alt="image-20221126140145795"></p><ol start="3"><li>业务应用场景：可以使用以上的思路去实现多线程加载文件后再打包文件，多线程加载速度快，性能较好。</li></ol><h3 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h3><p>作用：用于两个或多个线程之间的信息通信。</p><p><strong>例子1：</strong> 在古代男女结婚大多都是通过媒婆介绍的，那么男女在没结婚之前信息或物品交换都是通过媒婆转达的，更多故事请看以下代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  现有两个人，一男一女，是通过媒婆介绍并结婚的美好故事</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExchangerTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//创建一位媒婆</span></span><br><span class="line">        Exchanger&lt;String&gt; matchmaker = <span class="keyword">new</span> <span class="title class_">Exchanger</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//男女线程，现在男孩和女孩要交换定情信物，那只能通过媒婆转达</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Boy</span>(matchmaker),<span class="string">&quot;男孩&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Girl</span>(matchmaker),<span class="string">&quot;女孩&quot;</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>); <span class="comment">//保证男女孩的定情信物的交换成功</span></span><br><span class="line">        System.out.println(<span class="string">&quot;男孩和女孩都很满意对方的定情信物，于是结婚了哈哈哈&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  男孩子，要求不高</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Boy</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="comment">//男孩要去接待媒婆的到来</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Exchanger&lt;String&gt; matchmaker;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Boy</span><span class="params">(Exchanger&lt;String&gt; matchmaker)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.matchmaker = matchmaker;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">stuff</span> <span class="operator">=</span> <span class="string">&quot;同心锁&quot;</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;男孩开始制作--&gt;&quot;</span> + stuff);</span><br><span class="line">            <span class="comment">//男孩制作完后将其交给媒婆传达并从媒婆那得到女孩的信物</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">girlOfStuff</span> <span class="operator">=</span> matchmaker.exchange(stuff); <span class="comment">// 媒婆需要等待男孩的信物做完才可转交</span></span><br><span class="line">            System.out.println(<span class="string">&quot;男孩收到了女孩的&quot;</span> + girlOfStuff);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  女孩子，要求不高</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="comment">//女孩要去接待媒婆的到来</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Exchanger&lt;String&gt; matchmaker;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Girl</span><span class="params">(Exchanger&lt;String&gt; matchmaker)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.matchmaker = matchmaker;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">stuff</span> <span class="operator">=</span> <span class="string">&quot;钥匙&quot;</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;女孩开始制作--&gt;&quot;</span> + stuff);</span><br><span class="line">            <span class="comment">//女孩制作完后将其交给媒婆传达并从媒婆那得到男孩的信物</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">boyOfStuff</span> <span class="operator">=</span> matchmaker.exchange(stuff);</span><br><span class="line">            System.out.println(<span class="string">&quot;女孩收到了男孩的&quot;</span> + boyOfStuff);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221126145632008.png" alt="image-20221126145632008"></p><p><strong>例子2：</strong>正所谓结婚是双向奔赴的结果，那上面的例子可能只是在理想的环境下发生的罢了，现实中哪有如此容易啊，那么请看以下故事的结局是如何。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  现有两个人，一男一女悲惨故事</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExchangerTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//创建一个媒婆对象</span></span><br><span class="line">        Exchanger&lt;String&gt; matchmaker = <span class="keyword">new</span> <span class="title class_">Exchanger</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//男女线程，现在男孩和女孩要交换定情信物，那只能通过媒婆转达</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Boy</span>(matchmaker),<span class="string">&quot;男孩&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Girl</span>(matchmaker),<span class="string">&quot;女孩&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  男孩子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Boy</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="comment">//男孩要去接待媒婆的到来</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Exchanger&lt;String&gt; matchmaker;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Boy</span><span class="params">(Exchanger&lt;String&gt; matchmaker)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.matchmaker = matchmaker;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">stuff</span> <span class="operator">=</span> <span class="string">&quot;同心锁&quot;</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;男孩开始制作--&gt;&quot;</span> + stuff);</span><br><span class="line">            <span class="comment">//男孩制作完后将其交给媒婆传达并从媒婆那得到女孩的信物，男孩是一位急性子，只能等5s，若女孩还没有给定情信物的话就去自杀了</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">girlOfStuff</span> <span class="operator">=</span> matchmaker.exchange(stuff,<span class="number">5</span>, TimeUnit.SECONDS); <span class="comment">// 媒婆需要等待男孩的信物做完才可转交</span></span><br><span class="line">            System.out.println(<span class="string">&quot;男孩收到了女孩的&quot;</span> + girlOfStuff);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  女孩子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Girl</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="comment">//女孩要去接待媒婆的到来</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Exchanger&lt;String&gt; matchmaker;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Girl</span><span class="params">(Exchanger&lt;String&gt; matchmaker)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.matchmaker = matchmaker;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">stuff</span> <span class="operator">=</span> <span class="string">&quot;钥匙&quot;</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;女孩开始制作--&gt;&quot;</span> + stuff);</span><br><span class="line">            <span class="comment">//女孩对未见过面的男孩犹豫了6s才将信物送出去了</span></span><br><span class="line">            Thread.sleep(<span class="number">6000</span>);</span><br><span class="line">            <span class="comment">//女孩制作完后将其交给媒婆传达并从媒婆那得到男孩的信物</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">boyOfStuff</span> <span class="operator">=</span> matchmaker.exchange(stuff);</span><br><span class="line">            System.out.println(<span class="string">&quot;女孩收到了男孩的&quot;</span> + boyOfStuff);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221126151314144.png" alt="image-20221126151314144"></p><p><strong>应用业务场景：</strong>数据校验。在公司的流水账中数据的校验，可以定义两个线程对流水账中数据先各自校验，然后再把各自的校验结果进行交换，比对对方的校验结果和自己校验结果是否一致，这样可以大大的降低流水账中数据的出错率。</p><h1 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h1><p>概述：Lambda是JDK1.8之后提供的，作用是简化匿名内部类的写法。</p><ul><li>使用Lambda表达式的条件是：一个类中只能有一个抽象方法的函数式接口。</li></ul><p>以下代码是Lambda的基本用法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LambdaTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//匿名内部类的写法</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;匿名内部类线程开启&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="comment">//lambda写法</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;lambda线程&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h1><p>概述：stream流是JDK1.8之后提供，目的是为了简化集合数据操作的写法，同时也优化了执行的性能。以下代码可以体现Stream流的便利</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 业务需求：找到姓张的并且名字长度为3的客户</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//客户列表</span></span><br><span class="line">        List&lt;String&gt; users = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        users.add(<span class="string">&quot;张三丰&quot;</span>);</span><br><span class="line">        users.add(<span class="string">&quot;张韩&quot;</span>);</span><br><span class="line">        users.add(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        users.add(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        users.add(<span class="string">&quot;刘鸥上&quot;</span>);</span><br><span class="line">        users.add(<span class="string">&quot;张麻子&quot;</span>);</span><br><span class="line">        <span class="comment">//遍历找到姓张的并且长度为3的</span></span><br><span class="line">        <span class="keyword">for</span> (String user: users) &#123;</span><br><span class="line">            <span class="keyword">if</span>(user.startsWith(<span class="string">&quot;张&quot;</span>) &amp;&amp; user.length() == <span class="number">3</span>)&#123;</span><br><span class="line">                System.out.println(user);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;----------stream流------------&quot;</span>);</span><br><span class="line">        <span class="comment">//stream流写法</span></span><br><span class="line">        users.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;张&quot;</span>)).filter(s -&gt; s.length() == <span class="number">3</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221126161207005.png" alt="image-20221126161207005"></p><h2 id="常用的API"><a href="#常用的API" class="headerlink" title="常用的API"></a>常用的API</h2><ol><li><p>forEach ：逐一处理(遍历)</p></li><li><p>long count ()： 统计个数</p></li><li><p>filter ：过滤元素<br>– stream<T> filter (Predicate&lt;? sup er T&gt; predicate)</p></li><li><p>limit：取前几个元素</p></li><li><p>skip：跳过前几个</p></li><li><p>map：数据加工方法</p></li><li><p>concat：合并流。 静态方法</p><p><strong>以上方法除了count 和forEach终结流 ，其余都是非终结流，终结流是调用方法后没有返回值，非终结流是有返回值。</strong></p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  常用API测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//客户列表</span></span><br><span class="line">        List&lt;String&gt; userList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        userList.add(<span class="string">&quot;张三丰&quot;</span>);</span><br><span class="line">        userList.add(<span class="string">&quot;张韩&quot;</span>);</span><br><span class="line">        userList.add(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line">        userList.add(<span class="string">&quot;张麻子&quot;</span>);</span><br><span class="line">        <span class="comment">//1. 过滤出姓张的客户并打印</span></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------1------------&quot;</span>);</span><br><span class="line">        userList.stream().filter(s -&gt; s.startsWith(<span class="string">&quot;张&quot;</span>)).forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------2------------&quot;</span>);</span><br><span class="line">        <span class="comment">//2. 计算出客户的个数</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> userList.stream().count();</span><br><span class="line">        System.out.println(count);</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------3------------&quot;</span>);</span><br><span class="line">        <span class="comment">//3. 取前两个的客户名</span></span><br><span class="line">        userList.stream().limit(<span class="number">2</span>).forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------4------------&quot;</span>);</span><br><span class="line">        <span class="comment">//4. 取最后两个的客户</span></span><br><span class="line">        userList.stream().skip(userList.size() - <span class="number">2</span>).forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------5------------&quot;</span>);</span><br><span class="line">        <span class="comment">//5. 在每个客户名称上都加上m字母</span></span><br><span class="line">        userList.stream().map(s -&gt; s + <span class="string">&quot;m&quot;</span>).forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------6------------&quot;</span>);</span><br><span class="line">        <span class="comment">//6. 将下面的列表合成一个列表</span></span><br><span class="line">        List&lt;String&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        temp.add(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        temp.add(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        Stream&lt;String&gt; res = Stream.concat(userList.stream(), temp.stream());</span><br><span class="line">        res.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221126164020510.png" alt="image-20221126164020510" style="zoom:67%;" /><h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><ol><li>以下是常用的API测试</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 常用Api测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileApiTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建文件对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\test.jpg&quot;</span>); <span class="comment">//以绝对路径获取文件对象</span></span><br><span class="line">        <span class="comment">//1. 获取文件的相对路径</span></span><br><span class="line">        System.out.println(f1.getPath());</span><br><span class="line">        <span class="comment">//2. 获取文件的绝对路径</span></span><br><span class="line">        System.out.println(f1.getAbsolutePath());</span><br><span class="line">        <span class="comment">//3. 获取文件的名称，带后缀</span></span><br><span class="line">        System.out.println(f1.getName());</span><br><span class="line">        <span class="comment">//4. 获取文件的大小，以字节单位</span></span><br><span class="line">        System.out.println(f1.length());</span><br><span class="line">        System.out.println(<span class="string">&quot;----------------&quot;</span>);</span><br><span class="line">        <span class="comment">//以相对路径获取文件对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;b_based_item2\\file\\temp\\hello.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//1. 获取文件的相对路径</span></span><br><span class="line">        System.out.println(f2.getPath());</span><br><span class="line">        <span class="comment">//2. 获取文件的绝对路径</span></span><br><span class="line">        System.out.println(f2.getAbsolutePath());</span><br><span class="line">        <span class="comment">//3. 获取文件的名称，带后缀</span></span><br><span class="line">        System.out.println(f2.getName());</span><br><span class="line">        <span class="comment">//4. 获取文件的大小，以字节为单位</span></span><br><span class="line">        System.out.println(f2.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>File的判断API</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建文件对象</span></span><br><span class="line"><span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\test.jpg&quot;</span>); <span class="comment">//以绝对路径获取文件对象</span></span><br><span class="line"><span class="comment">//1. 判断文件是否存在</span></span><br><span class="line">System.out.println(f1.exists());</span><br><span class="line"><span class="comment">//2. 判断是否是文件，若是，返回true 否则 返回false</span></span><br><span class="line">System.out.println(f1.isFile());</span><br><span class="line"><span class="comment">//3. 判断文件对象是否是文件夹</span></span><br><span class="line">System.out.println(f1.isDirectory());</span><br></pre></td></tr></table></figure><ol start="3"><li>File的删除和创建相关的API</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以相对路径获取文件对象</span></span><br><span class="line"><span class="type">File</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;b_based_item2\\file\\temp\\hello1.txt&quot;</span>);</span><br><span class="line"><span class="comment">// 删除文件，若删除成功返回true，否则返回false，以下操作同理</span></span><br><span class="line">f2.delete();</span><br><span class="line"><span class="comment">// 删除空文件夹，非空删除不了</span></span><br><span class="line"><span class="type">File</span> <span class="variable">f3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;b_based_item2\\file\\test&quot;</span>);</span><br><span class="line">f3.delete();</span><br><span class="line"><span class="comment">// 创建多级目录</span></span><br><span class="line"><span class="type">File</span> <span class="variable">f4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;b_based_item2\\file\\temp\\hello\\world&quot;</span>);</span><br><span class="line">f4.mkdirs();</span><br></pre></td></tr></table></figure><ol start="4"><li>File的文件夹的相关API操作</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文件列表的获取和遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FIleApiTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建文件对象</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\java\\installpackage&quot;</span>);</span><br><span class="line">        <span class="comment">//获取当前文件夹中所有的文件名称</span></span><br><span class="line">        String[] fileNames = file.list();</span><br><span class="line">       <span class="comment">//断言fileNames数组不为空，防止报错</span></span><br><span class="line">        <span class="keyword">assert</span> fileNames != <span class="literal">null</span>;</span><br><span class="line">        Arrays.stream(fileNames).forEach(System.out::println); <span class="comment">//打印</span></span><br><span class="line">        <span class="comment">//获取当前文件夹中的所有文件对象</span></span><br><span class="line">        File[] files = file.listFiles();</span><br><span class="line">        <span class="keyword">if</span>(files == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">            System.out.println(f.getAbsolutePath());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h2><p>递归算法的三要素（缺一不可）</p><ul><li><p>递归的终结点。</p></li><li><p>递归的公式。</p></li><li><p>递归的方向，递归公式必须往终结点的方向靠近。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecursionTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(f(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="comment">//递归的终结点</span></span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">1</span> &amp;&amp; x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归的公式，该递归公式为f(x-1) + 1 故在x -1 会一直若x是正数就会往x == 1终结点靠近。</span></span><br><span class="line">        <span class="keyword">return</span> f(x - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>以下是递归算法的案例</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  猴子吃桃:</span></span><br><span class="line"><span class="comment"> *      猴子第一天摘了若干个桃子，当即吃了一半，觉得好不过瘾，然后又多吃了一个。</span></span><br><span class="line"><span class="comment"> *      第二天又吃了前一天剩下的一半，觉得好不过瘾，然后又多吃了一个。</span></span><br><span class="line"><span class="comment"> *      以后每天都是如此</span></span><br><span class="line"><span class="comment"> *      等到第十天再吃的时候发现只有1个桃子，请问猴子第一天总共摘了多少个桃子。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   公式推导：假设天数为n从1开始算起，f(n)为猴子吃桃子数</span></span><br><span class="line"><span class="comment"> *      f(n + 1) = f(n) - f(n)/2 - 1</span></span><br><span class="line"><span class="comment"> *      公式变换：2f(n + 1) = 2f(n) - f(n) - 2</span></span><br><span class="line"><span class="comment"> *           =&gt; f(n) = 2f(n + 1) + 2</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   递归的三要素</span></span><br><span class="line"><span class="comment"> *      递归的终结点：f(10) = 1</span></span><br><span class="line"><span class="comment"> *      递归的公式：f(n) = 2f(n + 1) + 2</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecursionTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(f(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//递归的终结点</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归的公式</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * f(n + <span class="number">1</span>) + <span class="number">2</span>; <span class="comment">//得出答案为：1534</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  要求：求出n的阶层</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  公式推导：f(n) = n * (n-1) * ... * 3 * 2 * 1</span></span><br><span class="line"><span class="comment"> *  找规律得：f(n) = f(n - 1) * n</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  递归的三要素</span></span><br><span class="line"><span class="comment"> *      递归的终结点：f(1) = 1</span></span><br><span class="line"><span class="comment"> *      递归的公式：f(n) = f(n - 1) * n</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RecursionTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(f(<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f(n - <span class="number">1</span>) * n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递归搜索文件"><a href="#递归搜索文件" class="headerlink" title="递归搜索文件"></a>递归搜索文件</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文件搜索测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileSearchTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//在javaFileStore目录下寻找word.txt文件</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> fileSearch(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\javaFileStore&quot;</span>), <span class="string">&quot;word.txt&quot;</span>);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mkdir：目录</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileName：要查找的文件名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 若找到返回该文件的绝对路径，不存在返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">fileSearch</span><span class="params">(File mkdir,String fileName)</span>&#123;</span><br><span class="line">        <span class="comment">//1. 判断该目录是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(!mkdir.exists()) &#123;</span><br><span class="line">            <span class="comment">//说明不存在</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2. 获取该目录下的所有文件</span></span><br><span class="line">        File[] files = mkdir.listFiles();</span><br><span class="line">        <span class="comment">//3. 判断该目录下是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(files == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//说明files文件夹为空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历判断是否是文件</span></span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            <span class="keyword">if</span>(file.isFile()) &#123;</span><br><span class="line">                <span class="comment">//说明是文件</span></span><br><span class="line">                <span class="keyword">if</span>(file.getName().contains(fileName)) &#123;</span><br><span class="line">                    <span class="comment">//说明找到了</span></span><br><span class="line">                    <span class="keyword">return</span> file.getAbsolutePath();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//说明是目录，递归再寻找</span></span><br><span class="line">                <span class="keyword">return</span> fileSearch(file,fileName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221127132603389.png" alt="image-20221127132603389"></p><h2 id="I-x2F-O流"><a href="#I-x2F-O流" class="headerlink" title="I&#x2F;O流"></a>I&#x2F;O流</h2><p>概述： File类只能操作文件对象本身并不能对其进行读写操作，读写文件应是I&#x2F;O操作，I&#x2F;O流可以理解成水流模型，IO是水管，数据是水流。</p><h3 id="I-x2F-O流的分类"><a href="#I-x2F-O流的分类" class="headerlink" title="I&#x2F;O流的分类"></a>I&#x2F;O流的分类</h3><p><strong>按照流的方向分类</strong></p><ol><li><p>输出流：以内存为基准，把内存中的数据写出到磁盘文件或者网络介质中去的流称为输出流。输出流作用是写数据到文件，或者写数据发送给别人。</p></li><li><p>输入流：以内存为基准，把磁盘文件中的数据或者网络中的数据读入到内存中去的流称为输入流，输入流的作用:读取数据到内存。</p></li></ol><p><strong>按照流的内容分类</strong></p><ol><li>字节流： 流中的数据的最小单位是一个一个的字节(bit)，这个流就是字节流。(万”物”皆可字节流)</li><li>字符流： 流中的数据的最小单位是一个一个的字符，这个流就是字符流。(针对于文本内容)</li></ol><h3 id="I-x2F-O流代码实现"><a href="#I-x2F-O流代码实现" class="headerlink" title="I&#x2F;O流代码实现"></a>I&#x2F;O流代码实现</h3><ol><li><strong>字节输入流（结合图理解字节流的工作流程）</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字节流读取文件内容测试测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IOStreamTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//创建一根水管（字节输入流对象）</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;b_based_item2\\file\\temp\\hello.txt&quot;</span>); </span><br><span class="line">       <span class="comment">//定义一个桶</span></span><br><span class="line">        <span class="type">byte</span>[] buff = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">//桶中装水大小容量</span></span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="comment">//循环将桶中的水倒出（打印）</span></span><br><span class="line">        <span class="keyword">while</span> ((len = is.read(buff)) != -<span class="number">1</span>) &#123; <span class="comment">//当桶中没水了会返回一个-1</span></span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(buff,<span class="number">0</span>,len)); <span class="comment">// new String() 将字节转换成字符，可以避免输出中文乱码（桶需要比文件还大）</span></span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">//关闭水管</span></span><br><span class="line">        is.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221127143510871.png" alt="image-20221127143510871"></p><ol start="2"><li><strong>字节输出流</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字节流输出流测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IOStreamTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//创建一根输出流水管（默认会将文件中的内容覆盖）</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;b_based_item2\\file\\temp\\hello.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//不会覆盖文件中的内容，在创建对象时，加个参数true</span></span><br><span class="line">        <span class="comment">//OutputStream os = new FileOutputStream(&quot;b_based_item2\\file\\temp\\hello.txt&quot;,true);</span></span><br><span class="line">        <span class="comment">//定义一个水桶并装水（内容）</span></span><br><span class="line">        <span class="type">byte</span>[] buff = <span class="string">&quot;我本可以忍受黑暗，如果我未曾见过光明&quot;</span>.getBytes();</span><br><span class="line">        <span class="comment">//将水桶中的水倒进水池中（将内容写入文件中）</span></span><br><span class="line">        os.write(buff);</span><br><span class="line">        <span class="comment">//刷新水管</span></span><br><span class="line">        os.flush();</span><br><span class="line">        <span class="comment">//关闭水管</span></span><br><span class="line">        os.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>复制文件案例</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 复制文件测试</span></span><br><span class="line"><span class="comment"> *  需求：从一个文件中读取数据复制到另一个文件目录中</span></span><br><span class="line"><span class="comment"> *  注意：以下的写法是JDK1.7后提供的新写法 try-catch-resource java自动会释放资源</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IOCopyTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="keyword">try</span> (</span><br><span class="line">               <span class="comment">//创建字节输入流</span></span><br><span class="line">               <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;b_based_item2\\file\\temp\\hello.txt&quot;</span>);</span><br><span class="line">                <span class="comment">//创建字节输出流对象</span></span><br><span class="line">                <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;b_based_item2\\file\\temp\\hello\\hello.txt&quot;</span>);</span><br><span class="line">             )&#123;</span><br><span class="line">           <span class="comment">//从输入流中读取数据</span></span><br><span class="line">           <span class="comment">//定义一个桶</span></span><br><span class="line">           <span class="type">byte</span>[] buff = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">           <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">           <span class="comment">//从水池中抽水并通过os将水倒进另一个水池中</span></span><br><span class="line">           <span class="keyword">while</span> ((len = is.read(buff)) != -<span class="number">1</span>) &#123;</span><br><span class="line">               os.write(buff,<span class="number">0</span>,len);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>字符输入流</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文件字符输入流。</span></span><br><span class="line"><span class="comment"> *      --作用:以内存为基准，把磁盘文件的数据以字符的形式读入到内存。</span></span><br><span class="line"><span class="comment"> *          简单来说，读取文本文件内容到内存中去。</span></span><br><span class="line"><span class="comment"> *      --构造器:</span></span><br><span class="line"><span class="comment"> *          public FileReader(File file):创建一个字符输入流与源文件对象接通</span></span><br><span class="line"><span class="comment"> *           public FileReader (string filePath):创建一个字符输入流与源文件路径接通</span></span><br><span class="line"><span class="comment"> *      --方法:</span></span><br><span class="line"><span class="comment"> *          public int read():读取一个字符的编号返回!读取完毕返回-1</span></span><br><span class="line"><span class="comment"> *          public int read (char[] buffer):读取一个字符数组，</span></span><br><span class="line"><span class="comment"> *              读取多少个字符就返回多少个数量，读取完毕返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IOReadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">            <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;b_based_item2\\file\\temp\\hello.txt&quot;</span>);</span><br><span class="line">        )&#123;</span><br><span class="line">            <span class="comment">//从文件中以字符为单位读取数据</span></span><br><span class="line">            <span class="type">char</span>[] buff = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((len = fr.read(buff)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(buff,<span class="number">0</span>,len));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>字符输出流</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字符输出流测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IOWriterTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">//以追加数据的形式创建输出流</span></span><br><span class="line">                <span class="type">Writer</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;b_based_item2\\file\\temp\\hello.txt&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">             )&#123;</span><br><span class="line">            <span class="comment">//定义需要写入的数据文字</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">info1</span> <span class="operator">=</span> <span class="string">&quot;code&quot;</span>;</span><br><span class="line">            <span class="comment">//写入数据</span></span><br><span class="line">            writer.write( info1 + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">info2</span> <span class="operator">=</span> <span class="string">&quot;实力与野心不符，这是一件很可悲的事情&quot;</span>;</span><br><span class="line">            writer.write(info2 + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="I-x2F-O缓冲流"><a href="#I-x2F-O缓冲流" class="headerlink" title="I&#x2F;O缓冲流"></a>I&#x2F;O缓冲流</h3><ol><li><strong>字节缓冲输入流</strong>：因为BufferedInputStream类是继承InputStream类的，故API接口几乎不变</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字节缓冲输入流:BufferedInputStream</span></span><br><span class="line"><span class="comment"> *     --作用:可以把低级的字节输入流包装成一个高级的缓冲字节输入流管道，</span></span><br><span class="line"><span class="comment"> *            从而提高字节输入流读数据的性能。</span></span><br><span class="line"><span class="comment"> *     --构造器:public BufferedInputStream (InputStream in)</span></span><br><span class="line"><span class="comment"> *     --原理:缓冲字节输入流管道自带了一个8KB的缓冲池，每次可以直接借用操作系统的功能最多提取8KB</span></span><br><span class="line"><span class="comment"> *            的数据到缓冲池中去，以后我们直接从缓冲池读取数据，所以性能较好!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IOBufferStreamTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">              <span class="comment">//创建对象</span></span><br><span class="line">              <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;b_based_item2\\file\\temp\\hello.txt&quot;</span>))</span><br><span class="line">           )&#123;</span><br><span class="line">            <span class="comment">//定义一个桶</span></span><br><span class="line">            <span class="type">byte</span>[] buff = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((len = is.read(buff)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(buff,<span class="number">0</span>,len));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>缓冲字节输出流</strong>：BufferedOutputStream继承OutputStream类，故API接口与上面的几乎不变</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  字节缓冲输出流:BufferedOutputStream</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IOBufferStreamTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">              <span class="comment">//创建对象</span></span><br><span class="line">            <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;b_based_item2\\file\\temp\\hello.txt&quot;</span>,<span class="literal">true</span>))</span><br><span class="line">           )&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">info</span> <span class="operator">=</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">            os.write(info.getBytes());</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>字节流和字节缓冲流的性能分析</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字节流和字符缓冲字节流性能测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IOPerformanceTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        copy1();</span><br><span class="line">        copy2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//由于一个一个字节复制文件太慢了直接pass</span></span><br><span class="line">    <span class="comment">//一个一个字节数组复制文件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copy1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">//创建字节输入流</span></span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;b_based_item2\\file\\temp\\temp.mp4&quot;</span>);</span><br><span class="line">                <span class="comment">//创建字节输出流对象</span></span><br><span class="line">                <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;b_based_item2\\file\\temp\\hello\\temp1.mp4&quot;</span>);</span><br><span class="line">        )&#123;</span><br><span class="line">            <span class="comment">//从输入流中读取数据</span></span><br><span class="line">            <span class="comment">//定义一个桶</span></span><br><span class="line">            <span class="type">byte</span>[] buff = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//从水池中抽水并通过os将水倒进另一个水池中</span></span><br><span class="line">            <span class="keyword">while</span> ((len = is.read(buff)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                os.write(buff,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;字节流一次一数组复制文件所耗时：&quot;</span> + (end - start) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//缓冲字节流一次一个数组复制</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copy2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">//创建字节输入流</span></span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;b_based_item2\\file\\temp\\temp.mp4&quot;</span>));</span><br><span class="line">                <span class="comment">//创建字节输出流对象</span></span><br><span class="line">                <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;b_based_item2\\file\\temp\\hello\\temp2.mp4&quot;</span>));</span><br><span class="line">        )&#123;</span><br><span class="line">            <span class="comment">//从输入流中读取数据</span></span><br><span class="line">            <span class="comment">//定义一个桶</span></span><br><span class="line">            <span class="type">byte</span>[] buff = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//从水池中抽水并通过os将水倒进另一个水池中</span></span><br><span class="line">            <span class="keyword">while</span> ((len = is.read(buff)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                os.write(buff,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;字节缓冲流一次一数组复制文件所耗时：&quot;</span> + (end - start)  + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221127164321276.png" alt="image-20221127164321276"></p><p>总结：如上图结果显示，字节缓冲流的性能比普通的字节流性能还要好。</p><ol start="4"><li><strong>字符输入缓冲流</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字符缓冲流测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IOBufferReadTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="keyword">try</span> (</span><br><span class="line">               <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;b_based_item2\\file\\temp\\hello.txt&quot;</span>));</span><br><span class="line">           )&#123;</span><br><span class="line">           <span class="comment">//从文件中读取数据</span></span><br><span class="line">           <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">           <span class="comment">//一次读取一行字符</span></span><br><span class="line">           <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">               System.out.println(line);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>字符缓冲输出流</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字符缓冲输出流测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IOBufferWriteTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//创建字符缓冲输出对象(新添加的内容加入到文件的末尾)</span></span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;b_based_item2\\file\\temp\\hello.txt&quot;</span>,<span class="literal">true</span>));</span><br><span class="line">        <span class="comment">//换一行</span></span><br><span class="line">        bw.newLine();</span><br><span class="line">        <span class="comment">//写入数据</span></span><br><span class="line">        bw.write(<span class="string">&quot;我本可以忍受黑暗&quot;</span>);</span><br><span class="line">        <span class="comment">//换一行</span></span><br><span class="line">        bw.newLine();</span><br><span class="line">        <span class="comment">//再写入数据</span></span><br><span class="line">        bw.write(<span class="string">&quot;假如我为曾见过光明&quot;</span>);</span><br><span class="line"></span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;异常的作用&quot;&gt;&lt;a href=&quot;#异常的作用&quot; class=&quot;headerlink&quot; title=&quot;异常的作用&quot;&gt;&lt;/a&gt;异常的作用&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;提高程序的健壮性和安全性。&lt;/li&gt;
&lt;li&gt;可以处理代码问题，防止程序出现问题后的死亡。&lt;/li&gt;
&lt;</summary>
      
    
    
    
    
    <category term="java基础" scheme="http://example.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>node.js安装说明及环境配置</title>
    <link href="http://example.com/2022/11/20/node-js%E5%AE%89%E8%A3%85%E8%AF%B4%E6%98%8E%E5%8F%8A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>http://example.com/2022/11/20/node-js%E5%AE%89%E8%A3%85%E8%AF%B4%E6%98%8E%E5%8F%8A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</id>
    <published>2022-11-20T04:31:48.000Z</published>
    <updated>2023-01-26T12:48:24.535Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装node-js步骤"><a href="#安装node-js步骤" class="headerlink" title="安装node.js步骤"></a>安装node.js步骤</h2><p>（一）官网下载安装包</p><ol><li>官网下载：<a href="https://nodejs.org/en/">Node.js (nodejs.org)</a></li></ol><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221120143619510.png" alt="image-20221120143619510" style="zoom:50%" /><ol start="2"><li>解压安装包进入你所安装的目录下，并创建两个目录分别为node_global和node_cache，<ol><li>node_globe：全局目录，下载的文件是保存于此</li><li>node_cache：缓存目录，保存一些node运行时的日志文件等等</li></ol></li><li>前两步完成后使用快捷键win+r输入cmd进入命令窗口，输入命令：<ol><li>node -v ：查看node是否安装成功</li><li>npm -v：查看npm命令是否安装成功，若安装成功如下图所示</li></ol></li></ol><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221120160703329.png" alt="image-20221120160703329"></p><p>（二）设置自定义全局目录和缓存目录</p><p>以上步骤完成后，以管理员身份运行cmd，输入以下命令</p><p>（三）配置环境变量</p><pre><code>      1. 将【用户变量】下的【Path】修改为【D:\Nodejs\node_global】，之后点击确定。</code></pre><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221120161915822.png" alt="image-20221120161915822"></p><ol start="2"><li>在【系统变量】下新建【NODE_PATH】【D:\Nodejs\node_global\node_modules】</li></ol><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221120162015871.png" alt="image-20221120162015871"></p><ol start="3"><li>在【系统变量】下的【Path】新建添加node全局文件夹【D:\Nodejs\node_global】，之后点击确定。</li></ol><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221120162114934.png" alt="image-20221120162114934" style="zoom:67%;" /><p>（四）下载cnpm命令</p><ol><li><p>说明：npm 默认的 registry ,也就是下载 npm 包时是从国外的服务器下载，国内很慢，一般都会指向淘宝 <a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a></p></li><li><p>npm config get registry         查看下当前的镜像源</p></li><li><p>npm config set registry <a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org/</a>     更换镜像为淘宝镜像</p></li><li><p>npm config get registry        检查配置是否成功 </p></li><li><p>npm install -g cnpm –registry&#x3D;<a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a>      全局安装基于淘宝源的cnpm</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;安装node-js步骤&quot;&gt;&lt;a href=&quot;#安装node-js步骤&quot; class=&quot;headerlink&quot; title=&quot;安装node.js步骤&quot;&gt;&lt;/a&gt;安装node.js步骤&lt;/h2&gt;&lt;p&gt;（一）官网下载安装包&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;官网下载：&lt;a hr</summary>
      
    
    
    
    
    <category term="node.js" scheme="http://example.com/tags/node-js/"/>
    
  </entry>
  
  <entry>
    <title>spring+springmvc+maven笔记</title>
    <link href="http://example.com/2022/11/20/spring+springmvc+maven%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2022/11/20/spring+springmvc+maven%E7%AC%94%E8%AE%B0/</id>
    <published>2022-11-19T16:00:00.000Z</published>
    <updated>2023-01-26T11:18:16.884Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><strong>概念</strong>：Spring是分层的Java SE&#x2F;EE应用full-stack轻量级开源框架，以loC ( Inverse Of Control:反转控制)和AOP (Aspect Oriented Programming :面向切面编程)为内核。</p><p><strong>应用</strong>：提供了展现层SpringMVC和持久层Spring JDBCTemplate 以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的JavaEE企业应用开源框架”</p><p><strong>优势</strong></p><p>（1）方便解耦，简化开发</p><p>通过Spring提供的lOC容器，可以将对象间的依赖关系交由Spring进行控制，避免硬编码所造成的过度耦合。用户也不必再为单例模式类、属性文件解析等这些很底层的需求编写代码，可以更专注于上层的应用。</p><p>（2）AOP编程的支持</p><p>通过Spring的AOP功能，方便进行面向切面编程，许多不容易用传统OOP实现的功能可以通过AOP轻松实现。</p><p>（3）声明式事务的支持</p><p>可以将我们从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活的进行事务管理提高开发效率和质量。</p><p>（4）方便集成各种优秀框架</p><p>Spring对各种优秀框架(Struts、Hibernate、Hessian、Quartz等)的支持。</p><p>（5）降低JavaEE API的使用难度</p><p>Spring对JavaEEAPI(如JDBC、JavaMail、远程调用等）进行了薄薄的封装层，使这些API的使用难度大为降低。</p><p>（6）Java源码是经典学习范例</p><p>Spring的源代码设计精妙、结构清晰、匠心独用，处处体现着大师对Java设计模式灵活运用以及对Java技术的高深造诣。它的源代码无疑是Java技术的最佳实践的范例。</p><h2 id="Spring-framework"><a href="#Spring-framework" class="headerlink" title="Spring framework"></a>Spring framework</h2><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221130172942524.png" alt="image-20221130172942524"></p><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><h3 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h3><p>概述：使用对象时，由主动new产生对象转换为由外部提供对象，此过程中对象创建控制权由程序转移到外部，此思想称为控制反转技术对IOC思想进行了实现，Spring提供了一个容器，称为IoC容器，用来充当IoC思想中的 “外部“，IoC容器负责对象的创建、初始化等一系列工作，被创建或被管理的对象在IoC容器中统称为Bean。</p><p><strong>创建Bean的步骤如下</strong></p><ol><li>pom.xml文件中导入spring-context坐标（版本5.0.5.RELEASE）</li><li>resource目录下创建spring的配置文件，通常将其命名为applicationContext.xml</li><li>在applicationContext.xml利用bean标签创建即可，如下所示</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 将bookDaoImpl类交给Spring的IOC管理(将其变为bean) --&gt;</span><br><span class="line">   &lt;!-- id值随便取，class值是指向实例类 --&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;bookDao&quot;</span> class=<span class="string">&quot;com.springbased.dao.impl.BookDaoImpl&quot;</span> /&gt;</span><br><span class="line">&lt;!-- 将bookServiceImpl类交给Spring的IOC管理(将其变为bean) --&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;bookService&quot;</span> class=<span class="string">&quot;com.springbased.service.impl.BookServiceImpl&quot;</span>  /&gt;</span><br></pre></td></tr></table></figure><ul><li>从IOC容器中获取bean</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//获取IOC容器</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//根据id获取具体的bean 两种方法：</span></span><br><span class="line">        <span class="comment">//1)通过id方式获取  Object getBean(String id);</span></span><br><span class="line">        <span class="comment">//2)通过类对象获取  Class getBean(类名称.class);</span></span><br><span class="line">        <span class="type">BookService</span> <span class="variable">bookDao</span> <span class="operator">=</span> (BookService)ac.getBean(<span class="string">&quot;bookService&quot;</span>);</span><br><span class="line">        <span class="comment">//调用方法</span></span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Bean基本属性"><a href="#Bean基本属性" class="headerlink" title="Bean基本属性"></a>Bean基本属性</h2><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221130175356015.png" alt="image-20221130175356015"></p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221130175501245.png" alt="image-20221130175501245"></p><p>scope默认单例的原因是：在非单例下，Ioc容器创建同一个类的bean多是不同的，对bean的复用性不高，当bean创建过多会导致性能的下降，还会浪费内存空间资源，故在单例模式下的优势在于，能避免实例重复创建；应用于避免存在多个实例引起程序逻辑错误的场合；较节约内存。</p><h2 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h2><ul><li>生命周期︰从创建到消亡的完整过程</li><li>bean生命周期：bean从创建到销毁的整体过程</li><li>bean生命周期控制：在bean创建后到销毁前做一些事情</li></ul><p>bean的生命周期可以实现InitializingBean，DisposableBean来重写bean的初始化和销毁的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span>, InitializingBean, DisposableBean &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;saving....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Bean被销毁前执行的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;destroy ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建Bean的初始化方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><p>概述：依赖注入(Dependency Injection) :它是Spring框架核心IOC的具体实现。在编写程序时，通过控制反转，把对象的创建交给了Spring，但是代码中不可能出现没有依赖的情况。IOC解耦只是降低他们的依赖关系，但不会消除。例如:业务层仍会调用持久层的方法。那这种业务层和持久层的依赖关系，在使用Spring之后，就让Spring来维护了。简单的说，就是坐等框架把持久层对象传入业务层，而不用我们自己去获取。</p><p><strong>setter依赖注入方式</strong></p><ol><li>在service层中定义成员变量来接收来自bean的注入</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="comment">//1. 创建一个dao对象，接收来自XMl文件注入bean</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    <span class="comment">//2. 构造set方法接收</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        bookDao.save();</span><br><span class="line">        System.out.println(<span class="string">&quot;service save ......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>在applicationContext.xml文件中配置如下，注意：其中name对应的值是set后边的单词，以小写开头，ref的值是将name的值赋值给定的类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 将bookDaoImpl类交给Spring的IOC管理(将其变为bean) --&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;bookDao&quot;</span> class=<span class="string">&quot;com.springbased.dao.impl.BookDaoImpl&quot;</span> /&gt;</span><br><span class="line">&lt;!-- 将bookServiceImpl类交给Spring的IOC管理(将其变为bean) --&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;bookService&quot;</span> class=<span class="string">&quot;com.springbased.service.impl.BookServiceImpl&quot;</span> &gt;</span><br><span class="line">    &lt;!--将service和dao通过property标签进行绑定--&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">        注意点：</span><br><span class="line">          name：是指向类属性的名称</span><br><span class="line">          ref：是指向bean中id为bookDao</span><br><span class="line">     --&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;bookDao&quot;</span> ref=<span class="string">&quot;bookDao&quot;</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221130181123964.png" alt="image-20221130181123964"></p><p><strong>构造器依赖注入</strong></p><ol><li>在service层中创建一个构造器如下</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="comment">//1. 创建一个dao对象，接收来自XMl文件注入bean</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BookServiceImpl</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. 创建一个构造器，为成员变量赋值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BookServiceImpl</span><span class="params">(BookDao bookDao, UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        bookDao.save();</span><br><span class="line">        System.out.println(<span class="string">&quot;service save ......&quot;</span>);</span><br><span class="line">        userDao.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>xml的配置如下，构造器注入的标签是constructor-arg</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 将bookDaoImpl类交给Spring的IOC管理(将其变为bean) --&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;bookDao&quot;</span> class=<span class="string">&quot;com.springbased1.dao.impl.BookDaoImpl&quot;</span>/&gt;</span><br><span class="line">&lt;!-- 将userDao加载成bean --&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;userDao&quot;</span> class=<span class="string">&quot;com.springbased1.dao.impl.UserDaoImpl&quot;</span>/&gt;</span><br><span class="line">&lt;!-- 将bookServiceImpl类交给Spring的IOC管理(将其变为bean) --&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;bookService&quot;</span> class=<span class="string">&quot;com.springbased1.service.impl.BookServiceImpl&quot;</span>&gt;</span><br><span class="line">    &lt;constructor-arg name=<span class="string">&quot;userDao&quot;</span> ref=<span class="string">&quot;userDao&quot;</span> /&gt;  </span><br><span class="line">    &lt;constructor-arg name=<span class="string">&quot;bookDao&quot;</span> ref=<span class="string">&quot;bookDao&quot;</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li>构造器注入的过程</li></ol><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221130183436290.png" alt="image-20221130183436290"></p><h2 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h2><p>配置中使用bean标签autowire属性设置自动装配的类型，如下所示是applicationContext.xml的配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 将bookDaoImpl类交给Spring的IOC管理(将其变为bean) --&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;bookDao&quot;</span> class=<span class="string">&quot;com.springbased1.dao.impl.BookDaoImpl&quot;</span>/&gt;</span><br><span class="line">&lt;!-- 将userDao加载成bean --&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;userDao&quot;</span> class=<span class="string">&quot;com.springbased1.dao.impl.UserDaoImpl&quot;</span>/&gt;</span><br><span class="line">&lt;!-- byType是按类型注入 还有按名称注入byName--&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;bookService&quot;</span> class=<span class="string">&quot;com.springbased1.service.impl.BookServiceImpl&quot;</span> autowire=<span class="string">&quot;byType&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="comment">//1. 创建一个dao对象，接收来自XMl文件注入bean</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="comment">//在自动注入，必须提供一个setter方法，Spring的IOC容器会从setter方法作为入口赋值给该类的成员变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBookDao</span><span class="params">(BookDao bookDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.bookDao = bookDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        bookDao.save();</span><br><span class="line">        System.out.println(<span class="string">&quot;service save ......&quot;</span>);</span><br><span class="line">        userDao.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用自动装配时需注意一下几点</p><ul><li>自动装配用于引用类型依赖注入，不能对简单类型进行操作</li><li>使用按类型装配时( byType )必须保障容器中相同类型的bean唯一，推荐使用</li><li>使用按名称装配时（byName )必须保障容器中具有指定名称的bean，因变量名与配置耦合，不推荐使用</li><li>自动装配优先级低于setter注入与构造器注入，同时出现时自动装配配置失效</li></ul><h2 id="整合第三方数据源"><a href="#整合第三方数据源" class="headerlink" title="整合第三方数据源"></a>整合第三方数据源</h2><ol><li>导入druid坐标</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">1.2</span><span class="number">.11</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>在applicationContext.xml中配置如下</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;dataSource&quot;</span> class=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;driverClassName&quot;</span> value=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span> /&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;username&quot;</span> value=<span class="string">&quot;root&quot;</span> /&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;password&quot;</span> value=<span class="string">&quot;123456&quot;</span> /&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;url&quot;</span> value=<span class="string">&quot;jdbc:mysql//localhost:3306/test&quot;</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li>整合成功的标志</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//获取IOC容器中的Bean对象</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//从容器中获取数据源</span></span><br><span class="line">        <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> (DataSource)ac.getBean(<span class="string">&quot;dataSource&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221201130442404.png" alt="image-20221201130442404"></p><h3 id="加载properties配置文件中的配置信息"><a href="#加载properties配置文件中的配置信息" class="headerlink" title="加载properties配置文件中的配置信息"></a>加载properties配置文件中的配置信息</h3><p>开启context的命名空间，在xml页面上方增加如下信息</p><p><img src="https://code-blog.oss-cn-hangzhou.aliyuncs.com/images/image-20221201131141810.png" alt="image-20221201131141810"></p><p>在resource目录下定义一个装连接数据库的配置文件.properties，配置信息如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jdbc.url=jdbc:mysql<span class="comment">//localhost:3306/test</span></span><br><span class="line">jdbc.druidName=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=<span class="number">123456</span></span><br></pre></td></tr></table></figure><p>在数据库连接配置中，使用占位符方式取出.properties文件中对应的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 利用context命令，使用通配符* 将所有的.properties文件引入--&gt;</span><br><span class="line">&lt;context:property-placeholder location=<span class="string">&quot;classpath:*.properties&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 使用$占位符方式，从.properties文件取出对应的值--&gt;</span><br><span class="line">&lt;bean id=<span class="string">&quot;dataSource&quot;</span> class=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;driverClassName&quot;</span> value=<span class="string">&quot;$&#123;jdbc.druidName&#125;&quot;</span> /&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;username&quot;</span> value=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span> /&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;password&quot;</span> value=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span> /&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;url&quot;</span> value=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><h2 id="注解开发"><a href="#注解开发" class="headerlink" title="注解开发"></a>注解开发</h2><p><strong>使用注解@Component加载Bean</strong></p><ol><li>开启xml文件组件扫描，使用context命令</li><li>在需要的类上加上注解@Component(“bean名称”)即可将此类加载成Bean</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 开启组件扫描，若没有开启扫描，注解将会失效 base-<span class="keyword">package</span>是扫描的范围--&gt;</span><br><span class="line">&lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">&quot;com.springbased1&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">//将此类加载成Bean，未给这个bean命名，则默认类型加载</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;service save ......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//获取IOC容器中的Bean对象</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//根据数据类型获取bean</span></span><br><span class="line">        <span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> ac.getBean(BookService.class);</span><br><span class="line">        bookService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用@ComponentScan注解代替xml中的组件扫描</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">//标记该类是配置类</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.springbased1&quot;)</span> <span class="comment">//开启组件扫描</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComponentConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在用配置类替换xml配置文件则需从配置类中获取容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//从配置类中获取容器</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(ComponentConfig.class);</span><br><span class="line">        <span class="comment">//根据数据类型获取bean，根据数据类型获取时应注意在IOC容器中只能有一个该类型的数据。</span></span><br><span class="line">        <span class="type">BookService</span> <span class="variable">bookService</span> <span class="operator">=</span> ac.getBean(BookService.class);</span><br><span class="line">        bookService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring&quot;&gt;&lt;a href=&quot;#Spring&quot; class=&quot;headerlink&quot; title=&quot;Spring&quot;&gt;&lt;/a&gt;Spring&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;</summary>
      
    
    
    
    
    <category term="ssm" scheme="http://example.com/tags/ssm/"/>
    
  </entry>
  
</feed>
